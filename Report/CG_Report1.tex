\documentclass[11pt,a4paper]{article}

% ---------------------- BASIC PAGE SETUP ----------------------
\usepackage[a4paper,inner=2cm,outer=2cm,top=2.5cm,bottom=2.5cm]{geometry}

% ---------------------- FONTS ----------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[default]{lato}           % cleaner, rounder sans-serif
\usepackage[scaled=0.9]{inconsolata} % monospace for code
\renewcommand*\familydefault{\sfdefault}

\usepackage{setspace}
\usepackage{lmodern}
\onehalfspacing

% Letterspacing helper (for sporty title look)
\usepackage{microtype}

% ---------------------- COLORS / LINKS ----------------------
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{amsmath,amssymb}
\usepackage{amsthm}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=cyan!70!black,
	urlcolor=blue,
	citecolor=cyan!70!black,
	pdfauthor={Your Name},
	pdftitle={Computer Graphics Report},
	pdfcreator={PDFLaTeX},
	pdfproducer={PDFLaTeX}
}

% ---------------------- HEADER / FOOTER ----------------------
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\headrule}{
	\hbox to\headwidth{
		\color{cyan!70!black}\leaders\hrule height 0.4pt\hfill
	}
}
\lhead{\textbf{Computer Graphics Report}}
\rhead{\textbf{Page \thepage}}
\fancyfoot{} % no footer text
\usepackage{subcaption}

% ---------------------- CODE LISTINGS (DARK BOXES) ----------------------
\usepackage{listings}

\definecolor{codebg}{RGB}{235,235,235}
\definecolor{codeframe}{RGB}{0,180,200}
\definecolor{codekeyword}{RGB}{0,0,160}
\definecolor{codecomment}{RGB}{0,128,0}
\definecolor{codestring}{RGB}{160,80,0}
\definecolor{codelinenum}{RGB}{110,110,120}
\definecolor{codefg}{RGB}{0,0,0}

\lstdefinestyle{cgstyle}{
	backgroundcolor=\color{codebg},
	frame=single,
	rulecolor=\color{codeframe},
	frameround=tttt,
	basicstyle=\ttfamily\footnotesize\color{codefg},
	keywordstyle=\color{codekeyword}\bfseries,
	commentstyle=\color{codecomment}\itshape,
	stringstyle=\color{codestring},
	identifierstyle=\color{codefg},
	numberstyle=\tiny\color{codelinenum},
	numbers=left,
	stepnumber=1,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	tabsize=4,
	xleftmargin=1.8em,
	framexleftmargin=1.4em
}

% ---------------------- YOUR MACROS (from macros.tex) ----------------------
\newcommand{\ra}[1]{\renewcommand{\arraystretch}{#1}}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{defn}[thm]{Definition}
\newtheorem{rem}[thm]{Remark}
\numberwithin{equation}{section}

\newcommand{\homework}[6]{
	\pagestyle{myheadings}
	\thispagestyle{plain}
	\newpage
	\setcounter{page}{1}
	\noindent
	\begin{center}
		\framebox{
			\vbox{\vspace{2mm}
				\hbox to 6.28in { {\bf CS 6780:~Advanced Machine Learning \hfill {\small (#2)}} }
				\vspace{6mm}
				\hbox to 6.28in { {\Large \hfill #1  \hfill} }
				\vspace{6mm}
				\hbox to 6.28in { {\it Instructor: {\rm #3} \hfill Name: {\rm #5}, Netid: {\rm #6}} }
				\vspace{2mm}}
		}
	\end{center}
	\markboth{#5 -- #1}{#5 -- #1}
	\vspace*{4mm}
}

\newcommand{\problem}[2]{~\\\fbox{\textbf{Problem #1}}\hfill (#2 points)\newline\newline}
\newcommand{\subproblem}[1]{~\newline\textbf{(#1)}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\Hy}{\mathcal{H}}
\newcommand{\VS}{\textrm{VS}}
\newcommand{\solution}{~\newline\textbf{\textit{(Solution)}} }

\newcommand{\bbF}{\mathbb{F}}
\newcommand{\bbX}{\mathbb{X}}
\newcommand{\bI}{\mathbf{I}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\bY}{\mathbf{Y}}
\newcommand{\bepsilon}{\boldsymbol{\epsilon}}
\newcommand{\balpha}{\boldsymbol{\alpha}}
\newcommand{\bbeta}{\boldsymbol{\beta}}
\newcommand{\0}{\mathbf{0}}

% ---------------------- REPORT METADATA ----------------------
\newcommand{\reportTitle}{Computer Graphics Report}
\newcommand{\courseName}{Computer Graphics Lab}
\newcommand{\submissionDate}{November 21, 2025}
\newcommand{\universityName}{Jadavpur University}
\newcommand{\departmentName}{Department of Computer Science and Engineering}
\newcommand{\batchName}{UG 3rd Year, 1st Semester}
\newcommand{\repositoryLink}{\url{https://github.com/shadowbeast0/Braking-Bad}}

% Sport-style title macro (big, bold, italic, all caps, extra spacing)
\newcommand{\sporttitle}[1]{%
	{\textls[150]{\fontsize{30}{34}\selectfont\bfseries\slshape\MakeUppercase{#1}}}%
}

% ============================================================
%                       DOCUMENT
% ============================================================
\begin{document}
	
	% ---------------------- COVER PAGE ----------------------
	\thispagestyle{empty}
	\begin{center}
		\vspace*{2cm}
		% Sport-style title split across two lines with extra space between
		\sporttitle{Computer Graphics}\\[0.8cm]
		\sporttitle{Report}\par
		\vspace{0.8cm}
		{\Large\itshape \courseName\par}
		
		\vspace{2cm}
		% Replace "cg-logo" with your actual image filename
		\includegraphics[width=0.7\textwidth]{images/project}
		
		\vspace{2cm}
		{\large
			\begin{tabular}{@{}p{4cm}p{9cm}@{}}
				\textbf{Name} & \textbf{Roll Number} \\[0.5em]
				Shinjan Roy      & 002310501083 \\
				Souradeep De     & 002310501084 \\
				Arko Dasgupta    & 002310501085 \\
				Arjeesh Palai    & 002310501086 \\[1.0em]
				\textbf{Submission Date:} & \submissionDate \\[0.3em]
				\textbf{University:}      & \universityName \\[0.3em]
				\textbf{Department:}      & \departmentName \\[0.3em]
				\textbf{Batch:}           & \batchName      \\[0.3em]
                \textbf{Repository:}      & \repositoryLink
                \\
			\end{tabular}
		}
	\end{center}
	\clearpage
	
	% ---------------------- INDEX / TOC ----------------------
	\pagenumbering{roman}
	\setcounter{page}{1}
	
	\tableofcontents
	\clearpage
	
	% ---------------------- CONTRIBUTIONS ----------------------
	\section*{Contributions}
	\addcontentsline{toc}{section}{Contributions}
	
	\begin{itemize}
		\item \textbf{Shinjan Roy (002310501083):}
		\begin{itemize}
			\item Circle Drawing Algorithms.
			\item Ellipse Drawing Algorithms.
		\end{itemize}
		\item \textbf{Souradeep De (002310501084):}
		\begin{itemize}
			\item Line Drawing Algorithms.
			\item Cubic Bézier Curve.
		\end{itemize}
		\item \textbf{Arko Dasgupta (002310501085):}
		\begin{itemize}
			\item Line Clipping
			\item Polygon Clipping.
		\end{itemize}
		\item \textbf{Arjeesh Palai (002310501086):}
		\begin{itemize}
			\item Seed-Fill and Scanline Fill.
			\item 2D Transformations.
		\end{itemize}
	\end{itemize}
	
	\clearpage
	
	% ---------------------- MAIN CONTENT ----------------------
	\pagenumbering{arabic}
	\setcounter{page}{1}
	
	% ============================================================
	%                    PART 1: ASSIGNMENTS
	% ============================================================
	\section*{Part 1: Laboratory Assignments}
	\addcontentsline{toc}{section}{Part 1: Laboratory Assignments}
	
	% -------- ASSIGNMENT 1 --------
	\subsection*{Assignment 1: Line Drawing Algorithms}
	\addcontentsline{toc}{subsection}{Assignment 1: Line Drawing Algorithms}
	
	\subsubsection*{Problem Statement}
	Implement a line drawing algorithm to draw lines between two end points in the raster grid using:
	\begin{itemize}
		\item Digital Differential Analyzer (DDA)
		\item Bresenham's line drawing algorithm
	\end{itemize}
	Measure and report the execution time for each algorithm in milliseconds (ms). 
	Test and verify the implementations for line endpoints located in all four quadrants.
	
	\subsubsection*{Code and Theoretical Explanation}

\paragraph{Digital Differential Analyzer (DDA).}

In my implementation, the function \texttt{drawLineDDA()} realises the classical Digital Differential Analyzer algorithm in an incremental form over a raster grid.

Given two end points
\[
P_0(x_0,y_0),\qquad P_1(x_1,y_1),
\]
the continuous line is described by the slope--intercept form
\[
y = m x + b,\qquad 
m = \frac{y_1-y_0}{x_1-x_0},\qquad
b = y_0 - m x_0.
\]
Instead of directly evaluating $y = mx + b$ for each integer $x$ (which would involve a multiplication and rounding in every step), DDA works with incremental updates. Let
\[
\Delta x = x_1 - x_0,\qquad
\Delta y = y_1 - y_0.
\]
I choose the number of plotting steps as
\[
\text{steps} = \max(|\Delta x|, |\Delta y|),
\]
which means that I always step along the dominant direction (either $x$ or $y$ depending on $|m|$). The code fragment
\begin{lstlisting}[style=cgstyle,language=C++]
int x0 = box0.x(), y0 = box0.y(), x1 = box1.x(), y1 = box1.y();
int dx = x1 - x0, dy = y1 - y0;
int steps = std::max(std::abs(dx), std::abs(dy));
\end{lstlisting}
implements these $\Delta x$, $\Delta y$ and the choice of \(\text{steps}\).

The parametric form of the line can be written as
\[
x_k = x_0 + k\cdot\frac{\Delta x}{\text{steps}},\qquad
y_k = y_0 + k\cdot\frac{\Delta y}{\text{steps}},\qquad
k = 0,1,\dots,\text{steps}.
\]
Hence the incremental updates are
\[
x_{k+1} = x_k + x_{\mathrm{inc}},\qquad
y_{k+1} = y_k + y_{\mathrm{inc}},
\]
where
\[
x_{\mathrm{inc}} = \frac{\Delta x}{\text{steps}},\qquad
y_{\mathrm{inc}} = \frac{\Delta y}{\text{steps}}.
\]
This directly matches the implementation:
\begin{lstlisting}[style=cgstyle,language=C++]
double x_inc = static_cast<double>(dx) / steps;
double y_inc = static_cast<double>(dy) / steps;
double x = x0, y = y0;

for (int i = 0; i <= steps; i++) {
    to_fill.append(QPoint{static_cast<int>(std::round(x)),
                          static_cast<int>(std::round(y))});
    x += x_inc;
    y += y_inc;
}
\end{lstlisting}

The use of \texttt{std::round} corresponds to mapping the real-valued $(x_k,y_k)$ to the nearest pixel centre,
\[
(x_k,y_k) \;\longrightarrow\; (\operatorname{round}(x_k),\operatorname{round}(y_k)).
\]
Successive additions of the floating-point increments $x_{\mathrm{inc}}$ and $y_{\mathrm{inc}}$ may accumulate small numerical deviations, which are then discretised by this rounding step.

The timing code via \texttt{QElapsedTimer} is kept strictly outside the core recurrence so that the measured time corresponds purely to the computational part of the algorithm (the incremental updates and rounding), not to the Qt drawing calls.

\medskip
In summary, my DDA code is a direct implementation of the incremental equations
\[
(x_{k+1},y_{k+1}) = (x_k,y_k) + (x_{\mathrm{inc}},y_{\mathrm{inc}})
\]
with $x_{\mathrm{inc}}$ and $y_{\mathrm{inc}}$ derived from the geometric slope of the line and the dominant direction of traversal.
\includegraphics[width=0.5\textwidth]{images/dda}

\paragraph{Bresenham's Line Drawing Algorithm.}

The function \texttt{drawLineBresenham()} implements an integer-only version of Bresenham's line algorithm, which improves over DDA by eliminating floating-point arithmetic and explicit rounding.

Again I start from the endpoints
\[
P_0(x_0,y_0),\qquad P_1(x_1,y_1),
\]
and define
\[
\Delta x = |x_1 - x_0|,\qquad
\Delta y = |y_1 - y_0|.
\]
This corresponds to the code
\begin{lstlisting}[style=cgstyle,language=C++]
int x0 = box0.x(), y0 = box0.y(), x1 = box1.x(), y1 = box1.y();
int dx = std::abs(x1 - x0);
int dy = std::abs(y1 - y0);
\end{lstlisting}
and matches the usual notation $\Delta x$, $\Delta y$ in the standard derivation.

For the basic case $0 \le m \le 1$ and $\Delta x > 0$, Bresenham's algorithm considers, at each step, two candidate pixels:
\[
E = (x_k+1,\,y_k),\qquad
NE = (x_k+1,\,y_k+1),
\]
and chooses the one that is closer to the true line. This decision is encoded in a \emph{decision parameter} $p_k$ which is a scaled form of the difference of line-function values at two points. For a line with slope $m=\Delta y/\Delta x$ one obtains the recurrence
\[
p_0 = 2\Delta y - \Delta x,
\]
\[
p_{k+1} =
\begin{cases}
p_k + 2\Delta y, & \text{if } p_k < 0 \quad (\text{choose }E),\\[4pt]
p_k + 2\Delta y - 2\Delta x, & \text{if } p_k \ge 0 \quad (\text{choose }NE).
\end{cases}
\]

My implementation uses an equivalent but slightly more symmetric formulation that automatically handles all octants. After determining the step directions
\[
s_x = \operatorname{sign}(x_1-x_0),\qquad
s_y = \operatorname{sign}(y_1-y_0),
\]
the code initialises
\begin{lstlisting}[style=cgstyle,language=C++]
int sx = (x1 >= x0) ? 1 : -1;
int sy = (y1 >= y0) ? 1 : -1;

int err = dx - dy;
int x = x0;
int y = y0;
\end{lstlisting}
Here the variable \texttt{err} represents a scaled form of the decision parameter; for the shallow-slope case it is proportional to $(2\Delta y - \Delta x)$ from the classical recurrence. The main loop is
\begin{lstlisting}[style=cgstyle,language=C++]
while (true) {
    to_fill.append(QPoint{x, y});
    if (x == x1 && y == y1)
        break;

    int e2 = 2 * err;

    if (e2 > -dy) {
        err -= dy;
        x += sx;
    }
    if (e2 < dx) {
        err += dx;
        y += sy;
    }
}
\end{lstlisting}

Mathematically, the quantity \(\texttt{err}\) accumulates the difference between the ideal continuous line and the current discrete raster position. At each iteration, I compute
\[
e_2 = 2\,\texttt{err},
\]
and compare it against \(-\Delta y\) and \(\Delta x\). When \(e_2 > -\Delta y\), the accumulated error indicates that I can move one step along the $x$-direction without deviating too much from the line; algebraically this corresponds to the case where the decision parameter prefers the horizontal (or $E$-like) advance. I then update
\[
\texttt{err} \leftarrow \texttt{err} - \Delta y,\qquad x \leftarrow x + s_x.
\]
Similarly, when \(e_2 < \Delta x\) the error suggests that I need to move in $y$ as well to stay close to the ideal line, which corresponds to the $NE$ case in the standard formulation:
\[
\texttt{err} \leftarrow \texttt{err} + \Delta x,\qquad y \leftarrow y + s_y.
\]
\includegraphics[width=0.5\textwidth]{images/bresenham_line}

If both conditions hold in the same iteration (for steep slopes or negative slopes), both coordinates are updated and a diagonal move is made. This is how the generalised Bresenham algorithm handles all eight octants with a single integer-based scheme.

Crucially, all these updates are integer additions and subtractions; there are no floating-point multiplications or explicit rounding steps. This realises the two key advantages:
\begin{itemize}
  \item the algorithm is purely incremental (each step uses only the previous state), and
  \item it uses only integer arithmetic, avoiding the rounding-error accumulation and performance cost present in DDA.
\end{itemize}

\medskip
As with DDA, the drawing of pixels is kept outside the timing section; the measured time therefore reflects just the integer decision logic of Bresenham's algorithm.

	\subsubsection*{Code}
    DDA:
	\begin{lstlisting}[style=cgstyle,language=C++]
	qint64 MainWindow::drawLineDDA(const QPoint& box0, const QPoint& box1, const bool draw) {
    QVector<QPoint> to_fill;

    int x0 = box0.x(), y0 = box0.y(), x1 = box1.x(), y1 = box1.y();
    int dx = x1 - x0, dy = y1 - y0;
    int steps = std::max(std::abs(dx), std::abs(dy));
    to_fill.reserve(steps + 1);

    QElapsedTimer timer;
    timer.start();  // Start timing only for computation

    if (steps == 0) {
        to_fill.append(box0);
    } else {
        double x_inc = static_cast<double>(dx) / steps;
        double y_inc = static_cast<double>(dy) / steps;
        double x = x0, y = y0;


        for (int i = 0; i <= steps; i++) {
            to_fill.append(QPoint{static_cast<int>(std::round(x)), static_cast<int>(std::round(y))});
            x += x_inc;
            y += y_inc;
        }
    }
    qint64 time = timer.nsecsElapsed();  // Stop timing after computation

    // Perform drawing outside the timed section
    if (draw) addPoints(to_fill, QColor(20, 120, 250));

    return time;
}
	\end{lstlisting}

    Bresenham Line Drawing:
    \begin{lstlisting}[style=cgstyle, language=C++]
    qint64 MainWindow::drawLineBresenham(const QPoint& box0, const QPoint& box1, const bool draw) {
    QVector<QPoint> to_fill;

    int x0 = box0.x(), y0 = box0.y(), x1 = box1.x(), y1 = box1.y();
    int dx = std::abs(x1 - x0);
    int dy = std::abs(y1 - y0);
    int max_steps = std::max(dx, dy) + 1;
    to_fill.reserve(max_steps);

    QElapsedTimer timer;
    timer.start();  // Start timing only for computation

    int sx = (x1 >= x0) ? 1 : -1;
    int sy = (y1 >= y0) ? 1 : -1;

    int err = dx - dy;
    int x = x0;
    int y = y0;

    while (true) {
        to_fill.append(QPoint{x, y});

        if (x == x1 && y == y1)
            break;

        int e2 = 2 * err;

        if (e2 > -dy) {
            err -= dy;
            x += sx;
        }
        if (e2 < dx) {
            err += dx;
            y += sy;
        }
    }

    qint64 time = timer.nsecsElapsed();  // Stop timing after computation

    // Perform drawing outside the timed section
    if (draw) addPoints(to_fill, QColor(30, 30, 100));

    return time;
}
    \end{lstlisting}
	\clearpage
	\subsubsection*{Outputs}

% --- Selecting endpoints / DDA line ---
\begin{figure}[h]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/1.1 - Selecting endpoints for line.png}
        \caption{Selecting endpoints for line}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/1.2 - DDA Line from selected endpoints.png}
        \caption{DDA Line from selected endpoints}
    \end{subfigure}
\end{figure}

% --- Bresenham line / comparison example ---
\begin{figure}[h]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/1.3 - Bresenham Line from selecd endpoints.png}
        \caption{Bresenham Line from selected endpoints}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/example.png}
        \caption{Example where DDA and Bresenham differ}
    \end{subfigure}
\end{figure}
\subsubsection*{Output Explanation}

To compare the behaviour of DDA and Bresenham fairly, I always draw both lines
for the \emph{same} pair of endpoints \((x_0,y_0)\) and \((x_1,y_1)\).
In the first output screenshot I select these endpoints on the grid. Once the
points are fixed, I invoke \texttt{drawLineDDA()} and \texttt{drawLineBresenham()}
with the corresponding integer grid coordinates \texttt{box0} and \texttt{box1}.
Both functions therefore approximate exactly the same underlying continuous line.

In the DDA output, the plotted pixels follow the incremental equations
\[
x_{k+1} = x_k + \frac{\Delta x}{\text{steps}}, \qquad
y_{k+1} = y_k + \frac{\Delta y}{\text{steps}},
\]
with each \((x_k,y_k)\) rounded to the nearest integer grid location. Visually,
this produces a staircase pattern that is very close to the ideal straight line,
but at the discrete level some decisions are biased by how the floating-point
values happen to round.

In the Bresenham output, the same endpoints are connected using the integer
decision parameter described in the previous subsection. Here the next pixel is
chosen by testing the accumulated error term rather than by rounding a
floating-point position. As a result, the rasterised line is still an 8-connected
path between the same endpoints, but the exact sequence of visited pixels is
governed by the sign of the decision parameter instead of by
\(\operatorname{round}(\cdot)\).

To make this difference explicit, I also render an overlay where both DDA and
Bresenham are drawn for the same segment using different colours. Most of the
plotted pixels coincide, because both algorithms approximate the same ideal
line and share the same initial point \((x_0,y_0)\) and final point
\((x_1,y_1)\). However, in the middle portion of the segment there are two grid
points where the DDA and Bresenham paths diverge: DDA chooses the pixel that is
closest to its floating-point sample, whereas Bresenham, following its integer
recurrence, steps to a neighbouring pixel on the other side of the ideal line.
These non-overlapping pixels highlight the subtle difference between
floating-point rounding and integer decision logic.

For performance comparison, each function measures only the core computation
time using a \texttt{QElapsedTimer}. In both algorithms I start the timer just
before the stepping loop and stop it immediately after the sequence of raster
points has been generated; the actual drawing (the call to \texttt{addPoints})
is performed outside the timed region. The functions return the elapsed time in
nanoseconds. 


When the push buttons for drawing the lines are clicked, the algorithms are ran 8 times without invoking the drawing command, just to measure the time averaged over 8 iterations of the same algorithm so that variable factors do not affect the time measurement much. After that the actual drawing invocation is done.


In all of my experiments, the reported time for Bresenham is consistently smaller than for DDA for the same endpoints. This matches the theoretical expectation: DDA performs floating-point additions and rounding at every step, whereas Bresenham uses only integer additions, subtractions and comparisons, so
its inner loop is lighter and avoids floating-point rounding overhead.

	
	\clearpage
	
	% -------- ASSIGNMENT 2 --------
	\subsection*{Assignment 2: Circle Drawing Algorithms}
	\addcontentsline{toc}{subsection}{Assignment 2: Circle Drawing Algorithms}
	
	\subsubsection*{Problem Statement}
	Implement a circle drawing algorithm to draw a circle with a given radius in the raster grid using:
	\begin{itemize}
		\item Polar (parametric) method
		\item Bresenham's Midpoint circle drawing algorithm
	\end{itemize}
	Demonstrate eight-point symmetry of the circle using an animation.
	
	\noindent\textbf{Optional:}
	\begin{itemize}
		\item Implement the Cartesian circle drawing method.
		\item Measure the execution time of each algorithm in milliseconds (ms).
	\end{itemize}
	
	
	\subsubsection*{Code and Theoretical Explanation}

\paragraph{Polar (parametric) circle method.}

For a circle of centre \(C(x_c,y_c)\) and radius \(r\), the Cartesian equation
\[
(x-x_c)^2 + (y-y_c)^2 = r^2
\]
can be rewritten in polar (parametric) form as
\[
x(\theta) = x_c + r\cos\theta,\qquad
y(\theta) = y_c + r\sin\theta,\qquad 0 \le \theta < 2\pi.
\]
Sampling this parametric curve with a suitable angular step \(\Delta\theta\) gives a discrete set of points on the circle. To get roughly one pixel per step along the circumference, I use the approximation
\[
\Delta\theta \approx \frac{1}{r},
\]
because the arc length associated with a small angle is \(r\,\Delta\theta\), so choosing \(r\,\Delta\theta\approx 1\) keeps consecutive points about one pixel apart. :contentReference[oaicite:0]{index=0}

In the function \texttt{draw\_circle\_polar()}:

\begin{lstlisting}[style=cgstyle,language=C++]
for (double theta = 0; theta <= M_PI/4; theta += 1.0 / radius) {
    int x = std::round(radius * std::cos(theta));
    int y = std::round(radius * std::sin(theta));
    ...
}
\end{lstlisting}

the loop parameter \texttt{theta} corresponds to \(\theta\) above, and \texttt{x}, \texttt{y} are the rounded integer versions of \((r\cos\theta, r\sin\theta)\). I only iterate from \(0\) to \(\pi/4\), i.e. over the first octant, and then explicitly exploit the eight-way symmetry of the circle:
\[
(x_c \pm x,\; y_c \pm y),\qquad (x_c \pm y,\; y_c \pm x).
\]
This is reflected in the eight \texttt{push\_back} calls in the code, which generate all symmetric points from a single parametric sample. This reduces computation while still drawing the full circle.

The animation function \texttt{animate\_circle\_polar()} uses the same parametric equations, but draws only the current octant point (and its symmetric copies) for the present value of \(\theta\). A \texttt{QTimer} updates \(\theta\) over time, giving a visual demonstration of how the eight-way symmetry gradually builds the circle.

\paragraph{Cartesian circle method.}

Starting from the same circle equation
\[
(x-x_c)^2 + (y-y_c)^2 = r^2,
\]
we can solve for \(x\) in terms of \(y\):
\[
x = x_c \pm \sqrt{r^2 - (y-y_c)^2}.
\]
If the centre is taken as the origin in the integer grid coordinates (\(x_c=0, y_c=0\)), this simplifies to
\[
x = \pm \sqrt{r^2 - y^2}.
\]
The Cartesian method steps through integer \(y\) values and computes the corresponding \(x\) by evaluating this square root. To avoid redundant computation, I again restrict to the first octant and reproduce points in the remaining octants using symmetry.

In \texttt{draw\_circle\_cartesian()} I first compute an integer bound
\[
r' = \left\lfloor\frac{r}{\sqrt{2}}\right\rceil,
\]
which corresponds to the intersection of the circle with the line \(y = x\) (i.e. the boundary between the first and second octants). Then I iterate over
\[
y = 0,1,\dots,r',
\]
and for each \(y\) compute
\[
x = \operatorname{round}\!\bigl(\sqrt{r^2 - y^2}\bigr).
\]

This matches the code:

\begin{lstlisting}[style=cgstyle,language=C++]
int r = std::round(radius / std::sqrt(2));
...
for (int y = 0; y <= r; ++y) {
    int x = std::round(std::sqrt(radius * radius - y * y));
    ...
}
\end{lstlisting}

The subsequent eight insertions into \texttt{point} again realise the symmetric set
\[
(\pm x_c \pm x,\; \pm y_c \pm y),\qquad
(\pm x_c \pm y,\; \pm y_c \pm x).
\]
Mathematically, this method is straightforward but uses costly square-root operations and floating-point rounding, so it is mainly included as an optional reference implementation.

The animation routine \texttt{animate\_circle\_cartesian()} runs the same recurrence for a single \(y\) value per timer tick and draws only that ring of eight symmetric pixels. This visually illustrates how the circle is traced as \(y\) moves from \(0\) to \(r'\).

\paragraph{Bresenham midpoint circle algorithm.}

The Bresenham midpoint circle algorithm is an incremental, integer-only technique based on evaluating the implicit circle function
\[
f_{\text{circle}}(x,y)
= x^2 + y^2 - r^2.
\]
For any grid point \((x,y)\), the sign of \(f_{\text{circle}}(x,y)\) classifies it as:
\[
f_{\text{circle}}(x,y) < 0 \;\Rightarrow\; \text{inside the circle},\qquad
f_{\text{circle}}(x,y) = 0 \;\Rightarrow\; \text{on the circle},\qquad
f_{\text{circle}}(x,y) > 0 \;\Rightarrow\; \text{outside the circle}.
\]

The algorithm walks along the circle in the first octant with integer coordinates, maintaining a decision parameter \(p_k\) that approximates \(f_{\text{circle}}\) at the midpoint between two candidate pixels. When the current point is \((x_k,y_k)\), the next \(x\)-coordinate is incremented by one, and there are two choices for the next pixel:
\[
E = (x_k+1,\; y_k),\qquad
SE = (x_k+1,\; y_k-1).
\]
The midpoint between these two candidates is
\[
M = \Bigl(x_k + 1,\; y_k - \tfrac{1}{2}\Bigr),
\]
and the decision parameter is defined as
\[
p_k = f_{\text{circle}}(M)
    = \Bigl(x_k + 1\Bigr)^2 + \Bigl(y_k - \tfrac{1}{2}\Bigr)^2 - r^2.
\]
If \(p_k < 0\), the midpoint is inside the circle and \(E\) is closer to the ideal circle, so the next point is \((x_{k+1},y_{k+1}) = (x_k+1,y_k)\). If \(p_k \ge 0\), the midpoint lies on or outside the circle and the better choice is \((x_{k+1},y_{k+1}) = (x_k+1,y_k-1)\).

Algebraic manipulation yields an integer recurrence for the decision parameter. Starting with
\[
x_0 = 0,\quad y_0 = r,\quad
p_0 = 1 - r,
\]
one can derive
\[
p_{k+1} =
\begin{cases}
p_k + 2x_k + 3, & \text{if } p_k < 0 \quad (\text{E step}),\\[4pt]
p_k + 2x_k - 2y_k + 5, & \text{if } p_k \ge 0 \quad (\text{SE step}).
\end{cases}
\]
Multiplying everything by \(2\) gives a form that matches the implementation constants used in my code. :contentReference[oaicite:1]{index=1}

In \texttt{draw\_circle\_bresenham()} I keep the circle centre \((x_c,y_c)\) separate and iterate in a local coordinate system:

\begin{lstlisting}[style=cgstyle,language=C++]
int x = 0, y = radius;
int d = 3 - 2 * radius;

while (x <= y) {
    point.push_back(QPoint(cx + x, cy + y));
    ...
    if (d < 0)
        d += 4 * x + 6;
    else {
        y--;
        d += 4 * (x - y) + 10;
    }
    x++;
}
\end{lstlisting}

Here \texttt{d} is a scaled version of the decision parameter \(p_k\). The initial value \(\texttt{d = 3 - 2r}\) is proportional to \(4p_0 = 4(1-r)\) plus a constant. The updates
\[
d \leftarrow d + 4x + 6 \quad\text{or}\quad
d \leftarrow d + 4(x-y) + 10
\]
are the integer recurrences corresponding to the E and SE cases. Only additions and subtractions on integers are used; there are no multiplications by non-integer constants, no square roots, and no trigonometric functions.

As in the other methods, I compute points only for the first octant where \(0 \le x \le y\), and for each \((x,y)\) I generate all eight symmetric points around the circle by adding and subtracting \(x\) and \(y\) to the centre coordinates. This symmetry is also used in \texttt{animate\_circle\_bresenham()}, which updates \texttt{x}, \texttt{y}, and \texttt{d} one step at a time, drawing eight new pixels per timer tick and thereby animating the growth of the circle.

In the non-animated path of \texttt{draw\_circle()}, I benchmark the polar and Bresenham methods by repeating each algorithm \(100\) times and measuring the accumulated nanoseconds with \texttt{QElapsedTimer}. Dividing by \(100\) gives an average time per run, which is displayed in the labels \texttt{polarcircletime} and \texttt{bresenhamcircletime}. As expected from the absence of trigonometric and square-root operations, the Bresenham midpoint method consistently completes faster than the polar and Cartesian methods.
\includegraphics[width=0.5\textwidth]{images/circle1}
\includegraphics[width=0.5\textwidth]{images/circle2}
\includegraphics[width=0.5\textwidth]{images/circle3}
\includegraphics[width=0.5\textwidth]{images/circle4}
\includegraphics[width=0.5\textwidth]{images/circle5}
These images together support the theoretical discussion of the polar, Cartesian and Bresenham circle algorithms and make the behaviour of my implementation visually clear.

	\subsubsection*{Code}
	circle.pro
    \begin{lstlisting}[style=cgstyle,language=C++]
QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++17

#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000

SOURCES += \
    main.cpp \
    mainwindow.cpp \
    my_label.cpp

HEADERS += \
    mainwindow.h \
    my_label.h

FORMS += \
    mainwindow.ui

qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target
\end{lstlisting}

mainwindow.h
\begin{lstlisting}[style=cgstyle,language=C++]
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QPoint>
#include <QSet>

namespace Ui {
class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:
    void Mouse_Pressed();
    void showMousePosition(QPoint&);
    void on_clear_clicked();
    void on_draw_line_clicked();
    void draw_grid();
    std::vector<QPoint> draw_line_bresenham(QPoint, QPoint);

    void on_spinBox_valueChanged(int);
    void repaint();

    void paint(std::vector<QPoint>, QColor);
    void paint(QPoint, QColor, QPainter&);

    void on_draw_circle_clicked();
    void draw_circle(QPoint, int);
    std::vector<QPoint> draw_circle_polar(QPoint, int);
    std::vector<QPoint> draw_circle_bresenham(QPoint, int);
    std::vector<QPoint> draw_circle_cartesian(QPoint, int);

    void animate_circle_polar(QPoint, int, double);
    void animate_circle_cartesian(QPoint, int, int);
    void animate_circle_bresenham(QPoint, int&, int&, int&);

    void on_circle_type_currentIndexChanged(int);

    void on_undo_clicked();

private:
    Ui::MainWindow *ui;
    void addPoint(int x, int y, int c = 1);

    QPoint lastPoint1, lastPoint2;
    int sc_x, sc_y;
    int org_x, org_y;
    int width, height;

    std::vector<std::pair<std::vector<QPoint>, QColor>> colormap;
    int gap;
    bool acircle;
    int fcircle;
};

#endif // MAINWINDOW_H
\end{lstlisting}

my\_label.h
\begin{lstlisting}[style=cgstyle,language=C++]
#ifndef MY_LABEL_H
#define MY_LABEL_H

#include <QLabel>
#include <QMouseEvent>

class my_label : public QLabel
{
    Q_OBJECT
public:
    explicit my_label(QWidget *parent = nullptr);
    int x, y;

protected:
    void mouseMoveEvent(QMouseEvent *ev);
    void mousePressEvent(QMouseEvent *ev);

signals:
    void sendMousePosition(QPoint&);
    void Mouse_Pos();
};

#endif // MY_LABEL_H
\end{lstlisting}

main.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "mainwindow.h"

#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}
\end{lstlisting}

my\_label.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "my_label.h"

my_label::my_label(QWidget *parent) : QLabel(parent)
{
    this->setMouseTracking(true);
}

void my_label::mouseMoveEvent(QMouseEvent *ev)
{
    QPoint pos = ev->pos();
    if (pos.x() >= 0 && pos.y() >= 0 && pos.x() < this->width() && pos.y() < this->height()) {
        emit sendMousePosition(pos);
    }
}

void my_label::mousePressEvent(QMouseEvent *ev)
{
    if (ev->button() == Qt::LeftButton) {
        x = ev->x();
        y = ev->y();
        emit Mouse_Pos();
    }
}
\end{lstlisting}

mainwindow.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QPixmap>
#include <QImage>
#include <QPainter>
#include <QDebug>
#include <QTimer>

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    lastPoint1 = QPoint(-100000, -100000);
    lastPoint2 = QPoint(-100000, -100000);

    connect(ui->frame, SIGNAL(Mouse_Pos()), this, SLOT(Mouse_Pressed()));
    connect(ui->frame, SIGNAL(sendMousePosition(QPoint&)), this, SLOT(showMousePosition(QPoint&)));

    gap = 10;
    fcircle = 0;
    acircle = true;

    width = 750;
    height = 450;

    draw_grid();
    ui->polarcircletime->setText("Polar: 0 ns");
    ui->bresenhamcircletime->setText("Bresenham: 0 ns");

    ui->filled->setText("Filled: 0 pixels");

    ui->undo->setEnabled(false);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::showMousePosition(QPoint &pos)
{
    sc_x = pos.x();
    sc_y = pos.y();
    ui->mouse_movement->setText("X : " + QString::number((sc_x-sc_x%gap-((width/2)-(width/2)%gap))/gap) + ", Y : " + QString::number(-(sc_y-sc_y%gap-((height/2)-(height/2)%gap))/gap));
}

void MainWindow::Mouse_Pressed()
{
    org_x = sc_x;
    org_y = sc_y;

    int x = (sc_x-sc_x%gap-((width/2)-(width/2)%gap))/gap;
    int y = (sc_y-sc_y%gap-((height/2)-(height/2)%gap))/gap;

    ui->mouse_pressed->setText("X : " + QString::number(x) + ", Y : " + QString::number(y));

    lastPoint1 = lastPoint2;

    lastPoint2 = QPoint(x, y);
}

void MainWindow::on_clear_clicked()
{
    lastPoint1 = lastPoint2 = QPoint(-100000, -100000);
    vertices.clear();
    edges.clear();
    colormap.clear();
    draw_grid();
    ui->polarcircletime->setText("Polar: 0 ns");
    ui->bresenhamcircletime->setText("Bresenham: 0 ns");

    ui->filled->setText("Filled: 0 pixels");
}


void MainWindow::draw_grid()
{
    QPixmap pix(ui->frame->width(), ui->frame->height());
    pix.fill(QColor(255, 255, 255));
    ui->frame->setPixmap(pix);

    QPixmap pm = ui->frame->pixmap();
    QPainter painter(&pm);
    painter.setPen(QPen(QColor(200, 200, 200)));
    for(int i=0; i<=width; i+=gap) painter.drawLine(QPoint(i,0), QPoint(i, height));
    for(int i=0; i<=height; i+=gap) painter.drawLine(QPoint(0, i), QPoint(width, i));

    painter.end();
    ui->frame->setPixmap(pm);

    paint(draw_line_bresenham(QPoint(-100000, 0), QPoint(100000, 0)), QColor(0, 0, 0));
    paint(draw_line_bresenham(QPoint(0, -100000), QPoint(0, 100000)), QColor(0, 0, 0));
}


void MainWindow::paint(std::vector<QPoint> points, QColor color){
    QPixmap pm = ui->frame->pixmap();
    QPainter painter(&pm);
    for(QPoint p:points){
        int x = p.x()*gap, y = p.y()*gap;
        painter.fillRect(QRect(x+((width/2) - (width/2)%gap), y+((height/2) - (height/2)%gap), gap, gap), color);
    }
    painter.end();
    ui->frame->setPixmap(pm);
    ui->filled->setText("Filled: " + QString::number(points.size()) + " pixels");
}

void MainWindow::paint(QPoint point, QColor color, QPainter& painter){
    int x = point.x()*gap, y = point.y()*gap;
    painter.fillRect(QRect(x+((width/2) - (width/2)%gap), y+((height/2) - (height/2)%gap), gap, gap), color);
}


std::vector<QPoint> MainWindow::draw_line_bresenham(QPoint a, QPoint b) {
    int x1 = a.x(), y1 = a.y();
    int x2 = b.x(), y2 = b.y();

    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);

    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;

    int err = dx - dy;

    std::vector<QPoint> point;

    while (true) {
        point.push_back(QPoint(x1, y1));

        if (x1 == x2 && y1 == y2) break;

        int e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x1 += sx; }
        if (e2 < dx)  { err += dx; y1 += sy; }
    }

    return point;
}

void MainWindow::on_spinBox_valueChanged(int value)
{
    gap = value;
    repaint();
}


void MainWindow::repaint(){
    draw_grid();
    QPixmap pm = ui->frame->pixmap();
    QPainter painter(&pm);
    for(const auto& pair : colormap){
        for(QPoint p : pair.first){
            paint(p, pair.second, painter);
        }
    }
    painter.end();
    ui->frame->setPixmap(pm);
}


void MainWindow::on_draw_circle_clicked()
{
    int cx = lastPoint1.x();
    int cy = lastPoint1.y();
    int dx = lastPoint2.x() - lastPoint1.x();
    int dy = lastPoint2.y() - lastPoint1.y();
    int radius = std::round(std::sqrt(dx * dx + dy * dy));

    QPoint centre = QPoint(cx, cy);

    draw_circle(centre, radius);
}


void MainWindow::draw_circle(QPoint centre, int radius){
    if(acircle && ui->animate_circle->isChecked()){
        if(fcircle == 0){
            auto theta = std::make_shared<double>(0);
            QTimer *timer = new QTimer(this);
            connect(timer, &QTimer::timeout, this, [this, timer, theta, centre, radius]() {
                if (*theta > M_PI/4) {
                    timer->stop();
                    timer->deleteLater();
                    ui->undo->setEnabled(true);
                }
                animate_circle_polar(centre, radius, *theta);
                *theta += 1.0/radius;
            });
            timer->start(100);
        }
        else if(fcircle == 1){
            QTimer *timer = new QTimer(this);
            auto x = std::make_shared<int>(0);
            auto y = std::make_shared<int>(radius);
            auto d = std::make_shared<int>(3 - 2*radius);
            connect(timer, &QTimer::timeout, this, [this, timer, centre, x, y, d]() {
                if (*x > *y) {
                    timer->stop();
                    timer->deleteLater();
                }
                animate_circle_bresenham(centre, *x, *y, *d);
            });
            timer->start(100);
        }
        else{
            int r = std::round(radius / std::sqrt(2));
            QTimer *timer = new QTimer(this);
            auto y = std::make_shared<int>(0);
            connect(timer, &QTimer::timeout, this, [this, timer, y, r, centre, radius]() {
                if (*y > r) {
                    timer->stop();
                    timer->deleteLater();
                    ui->undo->setEnabled(true);
                }
                animate_circle_cartesian(centre, radius, *y);
                (*y)++;
            });
            timer->start(100);
        }
        std::vector<QPoint> point = fcircle ? draw_circle_cartesian(centre, radius) : draw_circle_bresenham(centre, radius);
        colormap.push_back(std::pair(point, fcircle? QColor(150, 0, 0) : QColor(255, 150, 0)));
        ui->undo->setEnabled(true);
    }


    else{
        QElapsedTimer timer;
        qint64 time = 0;
        std::vector<QPoint> point;
        if(fcircle == 0){
            for(int i=0; i<100; i++){
                timer.start();
                point = draw_circle_polar(centre, radius);
                time += timer.nsecsElapsed();
            }
            ui->polarcircletime->setText("Polar: " + QString::number(time/100) + " ns");
        }
        else if(fcircle == 1){
            for(int i=0; i<100; i++){
                timer.start();
                point = draw_circle_bresenham(centre, radius);
                time += timer.nsecsElapsed();
            }
            ui->bresenhamcircletime->setText("Bresenham: " + QString::number(time/100) + " ns");
        }
        else{
            point = draw_circle_cartesian(centre, radius);
        }
        colormap.push_back(std::pair(point, fcircle==0? QColor(150, 0, 0) : fcircle==1? QColor(255, 150, 0) : QColor(255, 200, 0)));
        paint(point, fcircle==0? QColor(150, 0, 0) : fcircle==1? QColor(255, 150, 0) : QColor(255, 200, 0));
    }
}


std::vector<QPoint> MainWindow::draw_circle_polar(QPoint centre, int radius){
    int cx = centre.x();
    int cy = centre.y();

    std::vector<QPoint> point;
    for(double theta = 0; theta <= M_PI/4; theta += 1.0/radius){
        int x = std::round(radius * cos(theta)), y = std::round(radius * sin(theta));
        point.push_back(QPoint(cx + x, cy + y));
        point.push_back(QPoint(cx - x, cy + y));
        point.push_back(QPoint(cx + x, cy - y));
        point.push_back(QPoint(cx - x, cy - y));
        point.push_back(QPoint(cx + y, cy + x));
        point.push_back(QPoint(cx - y, cy + x));
        point.push_back(QPoint(cx + y, cy - x));
        point.push_back(QPoint(cx - y, cy - x));
    }

    return point;
}


std::vector<QPoint> MainWindow::draw_circle_cartesian(QPoint centre, int radius){
    int r = std::round(radius / std::sqrt(2));

    int cx = centre.x();
    int cy = centre.y();

    std::vector<QPoint> point;
    for(int y = 0; y<=r; y++){
        int x = std::round(std::sqrt(radius * radius - y * y));
        point.push_back(QPoint(cx + x, cy + y));
        point.push_back(QPoint(cx - x, cy + y));
        point.push_back(QPoint(cx + x, cy - y));
        point.push_back(QPoint(cx - x, cy - y));
        point.push_back(QPoint(cx + y, cy + x));
        point.push_back(QPoint(cx - y, cy + x));
        point.push_back(QPoint(cx + y, cy - x));
        point.push_back(QPoint(cx - y, cy - x));
    }

    return point;
}

std::vector<QPoint> MainWindow::draw_circle_bresenham(QPoint centre, int radius){
    int cx = centre.x();
    int cy = centre.y();

    int x = 0, y = radius;
    int d = 3 - 2 * radius;

    std::vector<QPoint> point;

    while(x <= y){
        point.push_back(QPoint(cx + x, cy + y));
        point.push_back(QPoint(cx - x, cy + y));
        point.push_back(QPoint(cx + x, cy - y));
        point.push_back(QPoint(cx - x, cy - y));
        point.push_back(QPoint(cx + y, cy + x));
        point.push_back(QPoint(cx - y, cy + x));
        point.push_back(QPoint(cx + y, cy - x));
        point.push_back(QPoint(cx - y, cy - x));
        if(d < 0) d += 4 * x + 6;
        else{
            y--;
            d += 4 * (x - y) + 10;
        }
        x++;
    }

    return point;
}

void MainWindow::animate_circle_polar(QPoint centre, int radius, double theta){
    int cx = centre.x();
    int cy = centre.y();

    QPixmap pm = ui->frame->pixmap();
    QPainter painter(&pm);

    int x = std::round(radius * cos(theta)), y = std::round(radius * sin(theta));

    paint(QPoint(cx + x, cy + y), QColor(150, 0, 0), painter);
    paint(QPoint(cx - x, cy + y), QColor(150, 0, 0), painter);
    paint(QPoint(cx + x, cy - y), QColor(150, 0, 0), painter);
    paint(QPoint(cx - x, cy - y), QColor(150, 0, 0), painter);
    paint(QPoint(cx + y, cy + x), QColor(150, 0, 0), painter);
    paint(QPoint(cx - y, cy + x), QColor(150, 0, 0), painter);
    paint(QPoint(cx + y, cy - x), QColor(150, 0, 0), painter);
    paint(QPoint(cx - y, cy - x), QColor(150, 0, 0), painter);
    painter.end();
    ui->frame->setPixmap(pm);
}

void MainWindow::animate_circle_cartesian(QPoint centre, int radius, int y){
    int cx = centre.x();
    int cy = centre.y();

    QPixmap pm = ui->frame->pixmap();
    QPainter painter(&pm);
    int x = std::round(std::sqrt(radius * radius - y * y));
    paint(QPoint(cx + x, cy + y), QColor(255, 200, 0), painter);
    paint(QPoint(cx - x, cy + y), QColor(255, 200, 0), painter);
    paint(QPoint(cx + x, cy - y), QColor(255, 200, 0), painter);
    paint(QPoint(cx - x, cy - y), QColor(255, 200, 0), painter);
    paint(QPoint(cx + y, cy + x), QColor(255, 200, 0), painter);
    paint(QPoint(cx - y, cy + x), QColor(255, 200, 0), painter);
    paint(QPoint(cx + y, cy - x), QColor(255, 200, 0), painter);
    paint(QPoint(cx - y, cy - x), QColor(255, 200, 0), painter);
    painter.end();
    ui->frame->setPixmap(pm);
}

void MainWindow::animate_circle_bresenham(QPoint centre, int& x, int& y, int& d){
    int cx = centre.x();
    int cy = centre.y();

    QPixmap pm = ui->frame->pixmap();
    QPainter painter(&pm);
    paint(QPoint(cx + x, cy + y), QColor(255, 150, 0), painter);
    paint(QPoint(cx - x, cy + y), QColor(255, 150, 0), painter);
    paint(QPoint(cx + x, cy - y), QColor(255, 150, 0), painter);
    paint(QPoint(cx - x, cy - y), QColor(255, 150, 0), painter);
    paint(QPoint(cx + y, cy + x), QColor(255, 150, 0), painter);
    paint(QPoint(cx - y, cy + x), QColor(255, 150, 0), painter);
    paint(QPoint(cx + y, cy - x), QColor(255, 150, 0), painter);
    paint(QPoint(cx - y, cy - x), QColor(255, 150, 0), painter);
    painter.end();
    ui->frame->setPixmap(pm);
    if(d < 0) d += 4 * x + 6;
    else{
        y--;
        d += 4 * (x - y) + 10;
    }
    x++;
}

void MainWindow::on_circle_type_currentIndexChanged(int index)
{
    fcircle = index;
}


void MainWindow::on_undo_clicked()
{
    colormap.pop_back();
    if(colormap.empty()) ui->undo->setEnabled(false);
    repaint();
}
\end{lstlisting}

	
	\clearpage
	\subsubsection*{Outputs}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{images/bresenham_circle}
    \caption{bresenham\_circle}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{images/polar_circle}
    \caption{polar\_circle}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{images/cartesian_circle}
    \caption{cartesian\_circle}
\end{figure}
\clearpage
	\subsubsection*{Output Explanation}

For validating the three circle algorithms, I fixed the circle centre at the origin of the grid and chose a single radius \(r\). Using the same two mouse clicks (first for the centre, second for a point on the circumference), the program first computes the integer radius
\[
r = \left\lfloor \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} \right\rceil
\]
and then draws three circles of radius \(r\) using the polar, Cartesian and Bresenham midpoint methods.

Visually, all three circles are centred at the origin and exhibit correct eight-way symmetry. Because of different rounding strategies, a few pixels differ between methods, but the overall shapes are almost indistinguishable at this resolution. The polar and Cartesian methods both rely on floating-point \(\cos\theta\), \(\sin\theta\) or \(\sqrt{\cdot}\) evaluations, while the Bresenham circle uses only integer additions and subtractions driven by the midpoint decision parameter.

To quantify this difference, I measured the execution time of the polar and Bresenham implementations using the built-in benchmarking in \texttt{draw\_circle()}. For each method, the circle is generated \(100\) times in a tight loop and the elapsed time in nanoseconds is accumulated with \texttt{QElapsedTimer}; the average
\[
T_{\text{avg}} = \frac{1}{100}\sum_{i=1}^{100} T_i
\]
is then displayed in the UI as ``Polar: 8286 ns'' and ``Bresenham: 2977 ns''. Across repeated runs for the same radius, the reported average time for the Bresenham circle is consistently lower than that of the polar circle. This empirically confirms the theoretical expectation: avoiding trigonometric and square-root computations and using purely incremental integer arithmetic makes the Bresenham midpoint algorithm noticeably faster, while still producing a visually accurate rasterisation of the circle.

	\clearpage
	
	% -------- ASSIGNMENT 3 --------
	\subsection*{Assignment 3: Ellipse Drawing Algorithms}
	\addcontentsline{toc}{subsection}{Assignment 3: Ellipse Drawing Algorithms}
	
	\subsubsection*{Problem Statement}
	Implement an ellipse drawing algorithm to draw an ellipse with given radii in the raster grid using:
	\begin{itemize}
		\item Polar (parametric) method
		\item Bresenham's Midpoint ellipse drawing algorithm
	\end{itemize}
	Measure and report the execution time for each algorithm in nanoseconds (ns).
	
	
	\subsubsection*{Code and Theoretical Explanation}

\paragraph{Polar (parametric) ellipse method.}

In my implementation, the function \texttt{draw\_ellipse\_polar()} realises the standard parametric form of an axis–aligned ellipse with centre
\[
C = (x_c,y_c), \qquad \text{semi–major axis } a,\ \text{semi–minor axis } b.
\]
The continuous ellipse satisfies
\[
\frac{(x - x_c)^2}{a^2} + \frac{(y - y_c)^2}{b^2} = 1
\]
and can be written parametrically as
\[
x(\theta) = x_c + a\cos\theta, \qquad
y(\theta) = y_c + b\sin\theta, \qquad 0 \le \theta < 2\pi.
\]

I first extract the integer centre coordinates and prepare a container of raster points:
\begin{lstlisting}[style=cgstyle,language=C++]
int cx = centre.x();
int cy = centre.y();

std::vector<QPoint> point;
\end{lstlisting}

Instead of using a fixed angular increment, I adapt the step in \(\theta\) so that the points stay roughly one pixel apart along the curve.  
For the parametric curve \(\mathbf{r}(\theta)=(a\cos\theta, b\sin\theta)\), the speed is
\[
\left\lVert \frac{d\mathbf{r}}{d\theta}\right\rVert
= \sqrt{(-a\sin\theta)^2 + (b\cos\theta)^2}
= \sqrt{a^2\sin^2\theta + b^2\cos^2\theta}.
\]
If I target an arc–length step \(\Delta s \approx 0.5\) pixels, then
\[
\Delta\theta \approx \frac{\Delta s}{\sqrt{a^2\cos^2\theta + b^2\sin^2\theta}}.
\]
This is encoded directly as
\begin{lstlisting}[style=cgstyle,language=C++]
for (double theta = 0; theta < M_PI/2;
     theta += 0.5 / std::sqrt(a*a*std::cos(theta)*std::cos(theta) +
                              b*b*std::sin(theta)*std::sin(theta))) {
\end{lstlisting}
which samples only the first quadrant \(0 \le \theta < \pi/2\).  
At each step I evaluate the parametric equations and round to the nearest pixel:
\[
x = \big\lfloor x_c + a\cos\theta + 0.5 \big\rfloor, \qquad
y = \big\lfloor y_c + b\sin\theta + 0.5 \big\rfloor.
\]
In code,
\begin{lstlisting}[style=cgstyle,language=C++]
    int x = std::round(a * std::cos(theta));
    int y = std::round(b * std::sin(theta));
\end{lstlisting}

The symmetry of the ellipse with respect to both axes allows me to generate all four quadrants from one computed point \((x,y)\):
\[
(x_c \pm x,\, y_c \pm y).
\]
This four–way symmetry is implemented by pushing four points per sample:
\begin{lstlisting}[style=cgstyle,language=C++]
    point.push_back(QPoint(cx + x, cy + y));
    point.push_back(QPoint(cx - x, cy + y));
    point.push_back(QPoint(cx + x, cy - y));
    point.push_back(QPoint(cx - x, cy - y));
\end{lstlisting}

Overall, \texttt{draw\_ellipse\_polar()} is therefore a direct discretisation of the continuous parametric equations \(x(\theta),y(\theta)\), with an adaptive angular step chosen from the analytic expression of the ellipse’s local speed and four–way symmetry used to cover the entire curve efficiently.

\paragraph{Cartesian ellipse method.}

The Cartesian method starts from the implicit equation of an ellipse with centre \(C=(x_c,y_c)\):
\[
\frac{(x - x_c)^2}{a^2} + \frac{(y - y_c)^2}{b^2} = 1.
\]
Solving for \(y\) in terms of \(x\) gives
\[
y(x) = \pm b\sqrt{1 - \frac{(x-x_c)^2}{a^2}},
\]
and solving for \(x\) in terms of \(y\) gives
\[
x(y) = \pm a\sqrt{1 - \frac{(y-y_c)^2}{b^2}}.
\]

In my code I work in a local coordinate system with the centre at the origin and then shift by \((x_c,y_c)\) when storing the points. The function \texttt{draw\_ellipse\_cartesian()} reflects exactly these formulas:
\begin{lstlisting}[style=cgstyle,language=C++]
int cx = centre.x();
int cy = centre.y();

std::vector<QPoint> point;
for (int x = 0; x <= a; x++) {
    int y = std::round(b * std::sqrt(1 - (float)(x * x) / (a * a)));
    point.push_back(QPoint(cx + x, cy + y));
    point.push_back(QPoint(cx - x, cy + y));
    point.push_back(QPoint(cx + x, cy - y));
    point.push_back(QPoint(cx - x, cy - y));
}
\end{lstlisting}
For each integer \(x\) between \(0\) and \(a\), I compute
\[
y = \operatorname{round}\!\left(b\sqrt{1 - \frac{x^2}{a^2}}\right),
\]
and then replicate \((x,y)\) to all four quadrants via \((\pm x,\pm y)\).  

However, sampling only in \(x\) would undersample the portions of the ellipse where the curve is steep (near the top and bottom). To avoid gaps, I add a second pass where I sample in \(y\) and solve for \(x\):
\begin{lstlisting}[style=cgstyle,language=C++]
for (int y = 0; y <= b; y++) {
    int x = std::round(a * std::sqrt(1 - (float)(y * y) / (b * b)));
    point.push_back(QPoint(cx + x, cy + y));
    point.push_back(QPoint(cx - x, cy + y));
    point.push_back(QPoint(cx + x, cy - y));
    point.push_back(QPoint(cx - x, cy - y));
}
\end{lstlisting}
This corresponds to using
\[
x = \operatorname{round}\!\left(a\sqrt{1 - \frac{y^2}{b^2}}\right)
\]
and again exploiting four–way symmetry.  
Thus the Cartesian method in my code numerically evaluates the explicit functions \(y(x)\) and \(x(y)\) derived from the ellipse equation, combining both to obtain a visually smooth rasterisation.

\paragraph{Bresenham (midpoint) ellipse algorithm.}

The midpoint ellipse algorithm is an extension of the midpoint circle method.  
It uses the implicit form
\[
F(x,y) = b^2x^2 + a^2y^2 - a^2b^2 = 0
\]
of the ellipse. For any integer point \((x,y)\),
\[
F(x,y) < 0 \Rightarrow \text{point inside ellipse},\qquad
F(x,y) = 0 \Rightarrow \text{point on ellipse},\qquad
F(x,y) > 0 \Rightarrow \text{point outside ellipse}.
\]

The method starts in the upper–middle point \((0,b)\) in the first quadrant and walks around the quadrant using only increments of \(1\) in \(x\) and/or \(y\), deciding at each step which neighbouring pixel is closer to the true ellipse. This decision is based on evaluating \(F\) at a midpoint between candidate pixels, which leads to simple integer recurrences.

\medskip
\emph{Region~1: \(\boldsymbol{dx < dy}\).}

In the first region, the slope of the ellipse satisfies \(|dy/dx| \le 1\) and we primarily increment \(x\).  
The initial values in my code are
\begin{lstlisting}[style=cgstyle,language=C++]
int x = 0, y = b;
int d1 = b*b - a*a*b + a*a/4;
int dx = 2 * b*b * x;
int dy = 2 * a*a * y;
\end{lstlisting}
The expression
\[
d_1 = b^2 - a^2b + \frac{a^2}{4}
\]
is the value of the decision function at the midpoint between the first two candidate pixels:
\[
d_1 = F\!\left(x_0+1,\; y_0-\tfrac{1}{2}\right)
    = b^2(x_0+1)^2 + a^2\!\left(y_0-\tfrac{1}{2}\right)^2 - a^2b^2
\]
with \((x_0,y_0)=(0,b)\). In order to avoid fractions, the derivation scales this by a constant factor, which yields the integer form used in the code.

At each step there are two possible moves:

- \(E\): \((x+1,\,y)\),
- \(SE\): \((x+1,\,y-1)\).

If \(d_1 < 0\), the midpoint lies inside the ellipse, so the closer pixel is \(E\); otherwise it is \(SE\).  
The corresponding integer recurrences obtained from \(F\) are:
\[
\begin{aligned}
\text{if } d_1 < 0 &:\quad x \leftarrow x+1,\quad
d_1 \leftarrow d_1 + 2b^2x + b^2, \\[2mm]
\text{else } &:\quad x \leftarrow x+1,\ y \leftarrow y-1, \\
&\quad d_1 \leftarrow d_1 + 2b^2x - 2a^2y + b^2.
\end{aligned}
\]
My implementation uses the incremental variables \texttt{dx} and \texttt{dy} to accumulate the terms \(2b^2x\) and \(2a^2y\):
\begin{lstlisting}[style=cgstyle,language=C++]
while (dx < dy) {
    point.push_back(QPoint(cx + x, cy + y));
    point.push_back(QPoint(cx - x, cy + y));
    point.push_back(QPoint(cx + x, cy - y));
    point.push_back(QPoint(cx - x, cy - y));

    if (d1 < 0) {
        x = x + 1;
        dx += 2 * b*b;
        d1 += dx + b*b;
    } else {
        x++;
        y--;
        dx += 2 * b*b;
        dy -= 2 * a*a;
        d1 += dx - dy + b*b;
    }
}
\end{lstlisting}
The four calls to \texttt{push\_back} implement the symmetry
\((\pm x,\pm y)\) across both axes. The inequalities \(\texttt{dx < dy}\) and the updates of \texttt{dx}, \texttt{dy} follow directly from
\[
dx = 2b^2x, \qquad dy = 2a^2y,
\]
which are the partial derivatives of \(F\) with respect to \(x\) and \(y\), scaled appropriately.

\medskip
\emph{Region~2: \(\boldsymbol{dx \ge dy}\).}

When the condition \(dx < dy\) no longer holds, the slope satisfies \(|dy/dx| > 1\) and we primarily decrement \(y\). The decision parameter is reinitialised using a midpoint appropriate for the second region:
\[
d_2 = F\!\left(x+\tfrac{1}{2},\, y-1\right)
    = b^2(x+\tfrac{1}{2})^2 + a^2(y-1)^2 - a^2b^2,
\]
which is encoded as
\begin{lstlisting}[style=cgstyle,language=C++]
int d2 = b*b * (x + 0.5) * (x + 0.5)
       + a*a * (y - 1)   * (y - 1)   - a*a * b*b;
\end{lstlisting}

In this second region the two possible moves are

- \(S\): \((x,\,y-1)\),
- \(SE\): \((x+1,\,y-1)\).

The corresponding integer recurrences are
\[
\begin{aligned}
\text{if } d_2 > 0 &:\quad y \leftarrow y-1,\quad
d_2 \leftarrow d_2 - 2a^2y + a^2,\\[2mm]
\text{else } &:\quad x \leftarrow x+1,\ y \leftarrow y-1,\\
&\quad d_2 \leftarrow d_2 + 2b^2x - 2a^2y + a^2.
\end{aligned}
\]
This is reflected in my implementation:
\begin{lstlisting}[style=cgstyle,language=C++]
while (y >= 0) {
    point.push_back(QPoint(cx + x, cy + y));
    point.push_back(QPoint(cx - x, cy + y));
    point.push_back(QPoint(cx + x, cy - y));
    point.push_back(QPoint(cx - x, cy - y));

    if (d2 > 0) {
        y--;
        dy -= 2 * a*a;
        d2 += a*a - dy;
    } else {
        y--;
        x++;
        dx += 2 * b*b;
        dy -= 2 * a*a;
        d2 += dx - dy + a*a;
    }
}
\end{lstlisting}
Again \texttt{dx} and \texttt{dy} maintain \(2b^2x\) and \(2a^2y\) so that the decision parameter updates remain purely additive.  

Throughout both regions, the algorithm uses only integer additions and subtractions; there are no calls to \texttt{sqrt}, \texttt{sin} or \texttt{cos}, and no explicit rounding inside the decision loop. This makes the midpoint ellipse significantly faster and more numerically stable than the purely trigonometric polar approach.

\includegraphics[width=0.5\textwidth]{images/ellipse1}
\includegraphics[width=0.5\textwidth]{images/ellipse2}
\includegraphics[width=0.5\textwidth]{images/ellipse3}
\includegraphics[width=0.5\textwidth]{images/ellipse4}
\includegraphics[width=0.5\textwidth]{images/ellipse5}
\includegraphics[width=0.5\textwidth]{images/ellipse6}

These figures complement the mathematical derivations above and visually connect the formulas with the discrete pixel trajectories produced by the three functions \texttt{draw\_ellipse\_polar()}, \texttt{draw\_ellipse\_cartesian()} and \texttt{draw\_ellipse\_bresenham()}.

	
	\subsubsection*{Code}
	ellipse.pro
    \begin{lstlisting}[style=cgstyle,language=C++]
QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++17

#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 

SOURCES += \
    main.cpp \
    mainwindow.cpp \
    my_label.cpp

HEADERS += \
    mainwindow.h \
    my_label.h

FORMS += \
    mainwindow.ui

qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target

}
\end{lstlisting}

my\_label.h
\begin{lstlisting}[style=cgstyle,language=C++]
#ifndef MY_LABEL_H
#define MY_LABEL_H

#include <QLabel>
#include <QMouseEvent>

class my_label : public QLabel
{
    Q_OBJECT
public:
    explicit my_label(QWidget *parent = nullptr);
    int x, y;

protected:
    void mouseMoveEvent(QMouseEvent *ev);
    void mousePressEvent(QMouseEvent *ev);

signals:
    void sendMousePosition(QPoint&);
    void Mouse_Pos();
};

#endif // MY_LABEL_H
\end{lstlisting}

mainwindow.h
\begin{lstlisting}[style=cgstyle,language=C++]
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QPoint>

namespace Ui {
class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:
    void Mouse_Pressed();
    void showMousePosition(QPoint&);
    void on_clear_clicked();
    void draw_grid();
    std::vector<QPoint> draw_line_bresenham(QPoint, QPoint);

    void on_spinBox_valueChanged(int);
    void repaint();

    void paint(std::vector<QPoint>, QColor);
    void paint(QPoint, QColor, QPainter&);

    void draw_ellipse(QPoint, int, int);
    std::vector<QPoint> draw_ellipse_polar(QPoint, int, int);
    std::vector<QPoint> draw_ellipse_bresenham(QPoint, int, int);
    std::vector<QPoint> draw_ellipse_cartesian(QPoint, int, int);

    void on_draw_ellipse_clicked();

    void on_ellipse_type_currentIndexChanged(int index);

    void on_undo_clicked();

private:
    Ui::MainWindow *ui;
    void addPoint(int x, int y, int c = 1);

    QPoint lastPoint1, lastPoint2;
    int sc_x, sc_y;
    int org_x, org_y;
    int width, height;

    std::vector<std::pair<std::vector<QPoint>, QColor>> colormap;
    int gap;
    int fellipse;
};

#endif // MAINWINDOW_H
\end{lstlisting}

main.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "mainwindow.h"

#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}
\end{lstlisting}

my\_label.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "my_label.h"

my_label::my_label(QWidget *parent) : QLabel(parent)
{
    this->setMouseTracking(true);
}

void my_label::mouseMoveEvent(QMouseEvent *ev)
{
    QPoint pos = ev->pos();
    if (pos.x() >= 0 && pos.y() >= 0 && pos.x() < this->width() && pos.y() < this->height()) {
        emit sendMousePosition(pos);
    }
}

void my_label::mousePressEvent(QMouseEvent *ev)
{
    if (ev->button() == Qt::LeftButton) {
        x = ev->x();
        y = ev->y();
        emit Mouse_Pos();
    }
}
\end{lstlisting}

mainwindow.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QPixmap>
#include <QImage>
#include <QPainter>
#include <QDebug>
#include <QTimer>
#include <QQueue>
#include <QSet>

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    lastPoint1 = QPoint(-100000, -100000);
    lastPoint2 = QPoint(-100000, -100000);

    connect(ui->frame, SIGNAL(Mouse_Pos()), this, SLOT(Mouse_Pressed()));
    connect(ui->frame, SIGNAL(sendMousePosition(QPoint&)), this, SLOT(showMousePosition(QPoint&)));

    gap = 10;
    fellipse = 0;
    
    width = 750;
    height = 450;

    draw_grid();
    ui->polarellipsetime->setText("Polar: 0 ns");
    ui->bresenhamellipsetime->setText("Bresenham: 0 ns");

    ui->filled->setText("Filled: 0 pixels");

    ui->undo->setEnabled(false);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::showMousePosition(QPoint &pos)
{
    sc_x = pos.x();
    sc_y = pos.y();
    ui->mouse_movement->setText("X : " + QString::number((sc_x-sc_x%gap-((width/2)-(width/2)%gap))/gap) + ", Y : " + QString::number(-(sc_y-sc_y%gap-((height/2)-(height/2)%gap))/gap));
}

void MainWindow::Mouse_Pressed()
{
    org_x = sc_x;
    org_y = sc_y;

    int x = (sc_x-sc_x%gap-((width/2)-(width/2)%gap))/gap;
    int y = (sc_y-sc_y%gap-((height/2)-(height/2)%gap))/gap;

    ui->mouse_pressed->setText("X : " + QString::number(x) + ", Y : " + QString::number(y));

    lastPoint1 = lastPoint2;

    lastPoint2 = QPoint(x, y);
}

void MainWindow::on_clear_clicked()
{
    lastPoint1 = lastPoint2 = QPoint(-100000, -100000);
    colormap.clear();
    draw_grid();
    ui->polarellipsetime->setText("Polar: 0 ns");
    ui->bresenhamellipsetime->setText("Bresenham: 0 ns");

    ui->filled->setText("Filled: 0 pixels");
}

void MainWindow::draw_grid()
{
    QPixmap pix(ui->frame->width(), ui->frame->height());
    pix.fill(QColor(255, 255, 255));
    ui->frame->setPixmap(pix);

    QPixmap pm = ui->frame->pixmap();
    QPainter painter(&pm);
    painter.setPen(QPen(QColor(200, 200, 200)));
    for(int i=0; i<=width; i+=gap) painter.drawLine(QPoint(i,0), QPoint(i, height));
    for(int i=0; i<=height; i+=gap) painter.drawLine(QPoint(0, i), QPoint(width, i));

    painter.end();
    ui->frame->setPixmap(pm);

    paint(draw_line_bresenham(QPoint(-100000, 0), QPoint(100000, 0)), QColor(0, 0, 0));
    paint(draw_line_bresenham(QPoint(0, -100000), QPoint(0, 100000)), QColor(0, 0, 0));
}

void MainWindow::paint(std::vector<QPoint> points, QColor color){
    QPixmap pm = ui->frame->pixmap();
    QPainter painter(&pm);
    for(QPoint p:points){
        int x = p.x()*gap, y = p.y()*gap;
        painter.fillRect(QRect(x+((width/2) - (width/2)%gap), y+((height/2) - (height/2)%gap), gap, gap), color);
    }
    painter.end();
    ui->frame->setPixmap(pm);
    ui->filled->setText("Filled: " + QString::number(points.size()) + " pixels");
}

void MainWindow::paint(QPoint point, QColor color, QPainter& painter){
    int x = point.x()*gap, y = point.y()*gap;
    painter.fillRect(QRect(x+((width/2) - (width/2)%gap), y+((height/2) - (height/2)%gap), gap, gap), color);
}

std::vector<QPoint> MainWindow::draw_line_bresenham(QPoint a, QPoint b) {
    int x1 = a.x(), y1 = a.y();
    int x2 = b.x(), y2 = b.y();

    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);

    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;

    int err = dx - dy;

    std::vector<QPoint> point;

    while (true) {
        point.push_back(QPoint(x1, y1));

        if (x1 == x2 && y1 == y2) break;

        int e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x1 += sx; }
        if (e2 < dx)  { err += dx; y1 += sy; }
    }

    return point;
}

void MainWindow::on_spinBox_valueChanged(int value)
{
    gap = value;
    repaint();
}


void MainWindow::repaint(){
    draw_grid();
    QPixmap pm = ui->frame->pixmap();
    QPainter painter(&pm);
    for(const auto& pair : colormap){
        for(QPoint p : pair.first){
            paint(p, pair.second, painter);
        }
    }
    painter.end();
    ui->frame->setPixmap(pm);
}

void MainWindow::on_draw_ellipse_clicked()
{
    if(lastPoint2 == QPoint(-100000, -100000)) return;
    draw_ellipse(lastPoint2, ui->ellipse_a->value(), ui->ellipse_b->value());
}

void MainWindow::draw_ellipse(QPoint centre, int a, int b){
    std::vector<QPoint> point;
    QElapsedTimer timer;
    qint64 time = 0;
    if(fellipse == 0){
        for(int i=0; i<100; i++){
            timer.start();
            point = draw_ellipse_polar(centre, a, b);
            time += timer.nsecsElapsed();
        }
        ui->polarellipsetime->setText("Polar: " + QString::number(time/100) + " ns");
    }
    else if(fellipse == 1){
        for(int i=0; i<100; i++){
            timer.start();
            point = draw_ellipse_bresenham(centre, a, b);
            time += timer.nsecsElapsed();
        }
        ui->bresenhamellipsetime->setText("Bresenham: " + QString::number(time/100) + " ns");
    }
    else{
        point = draw_ellipse_cartesian(centre, a, b);
    }
    colormap.push_back(std::pair(point, fellipse==0? QColor(0, 150, 150) : fellipse==1? QColor(150, 0, 150) : QColor(255, 100, 200)));
    paint(point, fellipse==0? QColor(0, 150, 150) : fellipse==1? QColor(150, 0, 150) : QColor(255, 100, 200));
    ui->undo->setEnabled(true);
}


std::vector<QPoint> MainWindow::draw_ellipse_polar(QPoint centre, int a, int b){
    int cx = centre.x();
    int cy = centre.y();

    std::vector<QPoint> point;

    for(double theta = 0; theta < M_PI/2; theta += 0.5/std::sqrt(a*a*cos(theta)*cos(theta) + b*b*sin(theta)*sin(theta))){
        int x = std::round(a * cos(theta)), y = std::round(b * sin(theta));
        point.push_back(QPoint(cx + x, cy + y));
        point.push_back(QPoint(cx - x, cy + y));
        point.push_back(QPoint(cx + x, cy - y));
        point.push_back(QPoint(cx - x, cy - y));
    }

    return point;
}


std::vector<QPoint> MainWindow::draw_ellipse_cartesian(QPoint centre, int a, int b){
    int cx = centre.x();
    int cy = centre.y();

    std::vector<QPoint> point;
    for(int x = 0; x<=a; x++){
        int y = std::round(b * std::sqrt(1 - (float)(x * x)/(a * a)));
        point.push_back(QPoint(cx + x, cy + y));
        point.push_back(QPoint(cx - x, cy + y));
        point.push_back(QPoint(cx + x, cy - y));
        point.push_back(QPoint(cx - x, cy - y));
    }
    for(int y = 0; y<=b; y++){
        int x = std::round(a * std::sqrt(1 - (float)(y * y)/(b * b)));
        point.push_back(QPoint(cx + x, cy + y));
        point.push_back(QPoint(cx - x, cy + y));
        point.push_back(QPoint(cx + x, cy - y));
        point.push_back(QPoint(cx - x, cy - y));
    }

    return point;
}


std::vector<QPoint> MainWindow::draw_ellipse_bresenham(QPoint centre, int a, int b){
    int cx = centre.x();
    int cy = centre.y();

    std::vector<QPoint> point;

    int x = 0, y = b;
    int d1 = b*b - a*a*b + a*a/4;
    int dx = 2 * b*b * x;
    int dy = 2 * a*a * y;


    while(dx < dy){
        point.push_back(QPoint(cx + x, cy + y));
        point.push_back(QPoint(cx - x, cy + y));
        point.push_back(QPoint(cx + x, cy - y));
        point.push_back(QPoint(cx - x, cy - y));

        if (d1 < 0){
            x = x + 1;
            dx += 2 * b*b;
            d1 += dx + b*b;
        }
        else{
            x++;
            y--;
            dx += 2 * b*b;
            dy -= 2 * a*a;
            d1 += dx - dy + b*b;
        }
    }


    int d2 = b*b * (x+0.5)(x+0.5) + a*a * (y-1)(y-1) - a*a * b*b;

    while(y >= 0){
        point.push_back(QPoint(cx + x, cy + y));
        point.push_back(QPoint(cx - x, cy + y));
        point.push_back(QPoint(cx + x, cy - y));
        point.push_back(QPoint(cx - x, cy - y));

        if(d2 > 0){
            y--;
            dy -= 2 * a*a;
            d2 += a*a - dy;
        }
        else{
            y--;
            x++;
            dx += 2 * b*b;
            dy -= 2 * a*a;
            d2 += dx - dy + a*a;
        }
    }

    return point;
}

void MainWindow::on_ellipse_type_currentIndexChanged(int index)
{
    fellipse = index;
}

void MainWindow::on_undo_clicked()
{
    colormap.pop_back();
    if(colormap.empty()) ui->undo->setEnabled(false);
    repaint();
}
\end{lstlisting}
	
	\clearpage
	\subsubsection*{Outputs}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{images/bresenham_ellipse}
    \caption{bresenham\_ellipse}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{images/polar_ellipse}
    \caption{polar\_ellipse}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{images/cartesian_ellipse}
    \caption{cartesian\_ellipse}
\end{figure}

	
	\clearpage
    \subsubsection*{Output Explanation}

For comparing the three ellipse drawing algorithms, I fixed the ellipse centre at the origin of the grid
\((0,0)\) and used the same pair of semi–axes \((a,b)\) for all methods. Using the GUI, I first selected the
origin as the centre and then specified identical values of \(a\) and \(b\) for:

\begin{itemize}
  \item the polar (parametric) ellipse,
  \item the Cartesian ellipse,
  \item the Bresenham (midpoint) ellipse.
\end{itemize}

All three algorithms therefore approximate the same continuous ellipse
\[
\frac{x^{2}}{a^{2}} + \frac{y^{2}}{b^{2}} = 1,
\]
and any differences in the rasterised curves are purely due to their numerical treatment and rounding.

The timing is performed inside \texttt{draw\_ellipse()} using \texttt{QElapsedTimer}. For each selected method,
I call the corresponding routine (\texttt{draw\_ellipse\_polar()} or \texttt{draw\_ellipse\_bresenham()})
100 times in a loop and accumulate the elapsed time in nanoseconds; the value displayed in the UI is the
integer average over these 100 runs. The Cartesian variant is drawn for visual comparison.

With this setup, the measured average times for one ellipse of fixed \((a,b)\) centred at the origin are:
\begin{align*}
  T_{\text{polar}}      &\approx 21996~\text{ns},\\
  T_{\text{Bresenham}}  &\approx 4586~\text{ns}.
\end{align*}
Thus, the midpoint ellipse is roughly five times faster than the polar implementation. This directly reflects
the algorithmic differences: the polar method repeatedly evaluates trigonometric functions and square roots,
whereas Bresenham’s ellipse uses only incremental integer additions and subtractions inside its main loop.

Minor pixel–level deviations are visible near regions of high curvature,
where the polar and Cartesian methods round independently computed real coordinates, while the midpoint method
follows a purely incremental decision process. Overall, the experiment shows that the Bresenham ellipse achieves
comparable visual quality at a significantly lower computational cost compared to the polar method.

	\clearpage
	% -------- ASSIGNMENT 4 --------
	\subsection*{Assignment 4: Seed-Fill and Scanline Fill}
	\addcontentsline{toc}{subsection}{Assignment 4: Seed-Fill and Scanline Fill}
	
	\subsubsection*{Problem Statement}
	\begin{itemize}
		\item Implement seed-fill algorithms:
		\begin{itemize}
			\item Boundary fill
			\item Flood fill
		\end{itemize}
		\item Implement the scanline fill algorithm:
		\begin{itemize}
			\item Draw a closed polygon and apply the scanline fill algorithm to fill the polygon.
		\end{itemize}
	\end{itemize}
	
	
\subsubsection*{Code and Theoretical Explanation}

\paragraph{Boundary Fill Algorithm.}

In the boundary fill approach, I assume that the polygon boundary has already been rasterised with a distinct \emph{boundary colour} and that the interior may contain arbitrary colours except this boundary colour and the chosen \emph{fill colour}. Starting from a seed pixel
\[
p_0 = (x_0,y_0),
\]
the interior region to be filled is defined as the maximal connected set
\[
R = \bigl\{ (x,y) \,\big|\,
\text{there exists a path from } p_0 \text{ to } (x,y)
\text{ using only non–boundary, non–fill pixels} \bigr\}.
\]
Connectivity can be either 4-connected,
\[
N_4(x,y) = \{(x\pm1,y), (x,y\pm1)\},
\]
or 8-connected,
\[
N_8(x,y) = N_4(x,y) \cup \{(x\pm1,y\pm1)\},
\]
as illustrated in the neighbourhood diagrams.:contentReference[oaicite:0]{index=0}

The classical recursive definition of boundary fill is:
\[
\mathrm{BF}(x,y) =
\begin{cases}
\text{return}, & \text{if } C(x,y)=C_{\text{boundary}} \text{ or } C(x,y)=C_{\text{fill}},\\[2mm]
C(x,y)\gets C_{\text{fill}}, & \text{otherwise, and recursively apply BF to neighbours}.
\end{cases}
\]
Here \(C(x,y)\) denotes the current colour at pixel \((x,y)\).

My implementation uses an explicit stack instead of recursion, but the logic is the same. Around the middle of \texttt{boundaryFill()} I build a work stack and repeatedly pop cells:
\begin{lstlisting}[style=cgstyle,language=C++]
QSet<QPair<int,int>> visited;
QVector<QPoint> stack;
stack.append(QPoint(gx0, gy0));
...
while (!stack.isEmpty()) {
    QPoint p = stack.takeLast();
    int gx = p.x(), gy = p.y();
    ...
    QColor cur = img.pixelColor(cx, cy);
    if (cur == newColor) continue;      // already filled
    if (cur == boundaryColor) continue; // stop at boundary
    ...
    painter.fillRect(rect, QBrush(newColor, Qt::SolidPattern));
    ...
    if (connectivityMode == Connectivity::Eight) {
        push8(gx, gy);
    } else {
        push4(gx, gy);
    }
}
\end{lstlisting}
The predicates
\[
C(x,y)=C_{\text{boundary}}, \qquad C(x,y)=C_{\text{fill}}
\]
are implemented by the two early \texttt{continue} checks on \texttt{cur}. The functions \texttt{push4()} and \texttt{push8()} generate the appropriate neighbourhood \(N_4\) or \(N_8\), which matches the 4-connected / 8-connected patterns shown in the neighbourhood figures.

Because I operate in grid coordinates, each logical cell \((g_x,g_y)\) is mapped to the rectangular pixel block
\[
[x_{\min},x_{\max}] \times [y_{\min},y_{\max}],
\quad
x_{\min}=g_x \cdot \text{grid\_box},\;
y_{\min}=g_y \cdot \text{grid\_box},
\]
and I fill this block via \texttt{painter.fillRect}. This maintains a consistent one–cell–one–colour model for analysis of interior versus boundary.

\paragraph{Flood Fill Algorithm.}

Flood fill differs conceptually from boundary fill in the region predicate. Instead of stopping at a fixed boundary colour, I define the region to be the maximal set of pixels having the same \emph{old colour} as the seed:
\[
R = \bigl\{(x,y)\,\big|\,
C(x,y) = C_{\text{old}} \text{ and connected to } p_0 \bigr\}.
\]
The recursive specification is
\[
\mathrm{FF}(x,y) =
\begin{cases}
\text{return}, & \text{if } C(x,y) \neq C_{\text{old}},\\[1mm]
C(x,y)\gets C_{\text{new}}, & \text{otherwise and recursively apply FF to neighbours}.
\end{cases}
\]

In my \texttt{floodFill()} implementation, I first determine the logical seed cell and read its colour from the image:
\begin{lstlisting}[style=cgstyle,language=C++]
int gx0 = qFloor(x / (double)this->grid_box);
int gy0 = qFloor(y / (double)this->grid_box);
...
QImage img = pm.toImage();
int cx0 = gx0 * this->grid_box + this->grid_box / 2;
int cy0 = gy0 * this->grid_box + this->grid_box / 2;
QColor seed = img.pixelColor(cx0, cy0);
\end{lstlisting}
From this I derive a \emph{region colour} (\texttt{regionColor}) that plays the role of \(C_{\text{old}}\). All pixels that are part of the connected component with this colour are candidates for replacement by \texttt{newColor}. The main loop contains the core test:
\begin{lstlisting}[style=cgstyle,language=C++]
QColor cur = img.pixelColor(cx, cy);
...
if (cur == Qt::white) cur = regionColor;
if (isSeed && seedIsYellow) cur = regionColor;
if (cur != regionColor) continue;
\end{lstlisting}
This sequence implements \(C(x,y) = C_{\text{old}}\): only if the effective colour equals \texttt{regionColor} does the algorithm fill the cell. The subsequent call
\begin{lstlisting}[style=cgstyle,language=C++]
painter.fillRect(rect, QBrush(newColor, Qt::SolidPattern));
\end{lstlisting}
realises the assignment \(C(x,y)\gets C_{\text{new}}\).

As in boundary fill, I use either 4-connected or 8-connected neighbours:
\begin{lstlisting}[style=cgstyle,language=C++]
if (connectivityMode == Connectivity::Eight) {
    push8(gx, gy);
} else {
    push4(gx, gy);
}
\end{lstlisting}
This matches the theoretical characterisation of flood fill as a region-growing process over a discrete lattice using a chosen connectivity.

\paragraph{Scanline Polygon Fill Algorithm.}

For scanline fill, the polygon is considered in terms of its edges. Let the vertices in Cartesian coordinates be
\[
P_i = (x_i,y_i), \quad i=0,\dots,n-1,
\]
with edges
\[
E_i: P_i \rightarrow P_{i+1}, \qquad P_n \equiv P_0.
\]
For a fixed integer scanline \(y\), I find all intersections between this horizontal line and the polygon edges. For any non-horizontal edge from \((x_1,y_1)\) to \((x_2,y_2)\), parameterised as
\[
x(t) = x_1 + t(x_2-x_1),\quad
y(t) = y_1 + t(y_2-y_1),\quad t\in[0,1],
\]
the value of \(t\) at which the edge crosses the scanline is obtained by solving
\[
y(t) = y + \tfrac{1}{2}
\quad\Rightarrow\quad
t = \frac{(y+0.5)-y_1}{y_2-y_1}.
\]
The corresponding intersection \(x\)-coordinate is
\[
x_{\text{int}} = x_1 + t(x_2-x_1).
\]

This is implemented in the loop over edges:
\begin{lstlisting}[style=cgstyle,language=C++]
for (int i = 0; i < n; ++i) {
    const QPoint p1 = poly.vertices[i];
    const QPoint p2 = poly.vertices[(i + 1) % n];
    ...
    if (y >= yminEdge && y < ymaxEdge) {
        const double t  = ((y + 0.5) - y1) / double(y2 - y1);
        const double ix = x1 + t * (x2 - x1);
        interX.append(ix);
    }
}
\end{lstlisting}
The half-pixel offset \((y+0.5)\) corresponds to evaluating the intersection through the centre of each scanline band, avoiding ambiguity at vertex positions.

Once all intersections \(\{x_k\}\) for that scanline are collected, they are sorted:
\[
x_{(0)} \le x_{(1)} \le \cdots \le x_{(m-1)}.
\]
The even–odd rule is then applied: for each pair \((x_{(2k)},x_{(2k+1)})\) I consider the interval between them as being inside the polygon and fill all cells whose centres lie strictly within that interval. This is reflected in the code:
\begin{lstlisting}[style=cgstyle,language=C++]
std::sort(interX.begin(), interX.end());
for (int k = 0; k + 1 < interX.size(); k += 2) {
    const double L = std::min(interX[k],   interX[k+1]);
    const double R = std::max(interX[k],   interX[k+1]);

    int xLeft  = int(std::ceil (L + epsx));
    int xRight = int(std::floor(R - epsx));
    if (xRight < xLeft) continue;

    for (int lx = xLeft; lx <= xRight; ++lx) {
        int gx = lx + this->center;
        int gy = this->center - y;
        ...
        QRect rect(gx * this->grid_box, gy * this->grid_box,
                   this->grid_box, this->grid_box);
        painter.fillRect(rect, QBrush(fillColor, Qt::SolidPattern));
    }
    maybeAnimate();
}
\end{lstlisting}
The use of \(\lceil L+\varepsilon\rceil\) and \(\lfloor R-\varepsilon\rfloor\) corresponds to including only pixels whose centres lie strictly between two consecutive intersection points, which matches the theoretical requirement that we do not overwrite the boundary itself. The mapping from logical coordinates \((l_x, y)\) to raster cells uses the same centre-based transform as in the line and circle assignments.\newline
\includegraphics[width=0.5\textwidth]{images/boundaryfill}
\includegraphics[width=0.5\textwidth]{images/scanline}\newline
Together, these figures visually support the mathematical characterisation and the implemented algorithms described above.

	
	\subsubsection*{Code}
	filling.pro
	\begin{lstlisting}[style=cgstyle,language=C++]
		QT += core gui widgets
		CONFIG += c++17
		
		SOURCES += \
		main.cpp \
		mainwindow.cpp \
		my_label.cpp
		
		HEADERS += \
		mainwindow.h \
		my_label.h
		
		FORMS += \
		mainwindow.ui
	\end{lstlisting}
	
	mainwindow.h
	\begin{lstlisting}[style=cgstyle,language=C++]
		#ifndef MAINWINDOW_H
		#define MAINWINDOW_H
		
		#include <QMainWindow>
		#include <QPoint>
		#include <QVector>
		#include <QPixmap>
		#include <QPainter>
		#include <QColor>
		#include <QMap>
		#include <QComboBox>
		#include <QLabel>
		
		QT_BEGIN_NAMESPACE
		namespace Ui { class MainWindow; }
		QT_END_NAMESPACE
		
		struct Polygon {
			QVector<QPoint> vertices;
			Qt::GlobalColor col = Qt::blue;
			
			bool   floodFilled  = false;
			QColor floodCol     = Qt::red;
			QPoint floodSeedPx  = QPoint(-1, -1);
			
			bool   boundaryFilled  = false;
			QColor boundaryCol     = Qt::green;          
			QPoint boundarySeedPx  = QPoint(-1, -1);
			
			bool   scanFilled  = false;
			QColor scanCol     = Qt::blue;               
		};
		
		class MainWindow : public QMainWindow
		{
			Q_OBJECT
			
			public:
			explicit MainWindow(QWidget *parent = nullptr);
			~MainWindow();
			
			private slots:
			void showMousePosition(const QPoint& pos);
			void Mouse_Pressed();
			
			void on_draw_grid_clicked();
			void on_clear_clicked();
			void on_grid_size_valueChanged(int grid);
			
			void on_start_polygon_clicked();
			void on_close_polygon_clicked();
			void on_fill_polygon_clicked();
			void on_clear_fill_clicked();
			
			void on_algo_select_currentIndexChanged(int index);
			
			private:
			Ui::MainWindow *ui;
			
			int  grid_box;     
			int  grid_size;    
			int  center;       
			bool draw_clicked;
			
			int sc_x, sc_y;
			int org_x, org_y;
			QPoint lastPoint1, lastPoint2;
			
			bool polygonFlag;
			Polygon currPoly;
			QVector<Polygon> polygons;
			
			QMap<QPair<int,int>, QColor> paintedCells;
			
			enum class Algo { Flood, Boundary, Scan };
			Algo currentAlgo;
			
			enum class Connectivity { Four, Eight };
			Connectivity connectivityMode = Connectivity::Four;
			QComboBox* connectivitySelect = nullptr; 
			
			void draw_axes(QPainter& painter);
			void refreshCanvas();          
			void redraw();                 
			void drawPaintedCells(QPainter& painter);
			
			void draw_line_grid(int X1, int X2, int Y1, int Y2, QPainter& painter, QColor col);
			
			void draw_polygon(QPainter& painter, const Polygon& poly);                  
			void draw_polygon_preview(QPainter& painter, const QVector<QPoint>& verts); 
			void draw_vertex_markers(QPainter& painter, const QVector<QPoint>& verts);
			
			void floodFill(int x_px, int y_px, const QColor& newColor);                          
			void boundaryFill(int x_px, int y_px, const QColor& newColor, const QColor& boundaryColor);
			void scanlineFill(const Polygon& poly, const QColor& fillColor, bool animate);
			
			void paintCellAtPixel(int x_px, int y_px);
		};
		
		#endif 
	\end{lstlisting}
	
	my\_label.h
	\begin{lstlisting}[style=cgstyle, language=c++]
		#ifndef MY_LABEL_H
		#define MY_LABEL_H
		
		#include <QLabel>
		#include <QMouseEvent>
		
		class my_label : public QLabel
		{
			Q_OBJECT
			public:
			explicit my_label(QWidget *parent = nullptr);
			int x, y;
			
			protected:
			void mouseMoveEvent(QMouseEvent *ev) override;
			void mousePressEvent(QMouseEvent *ev) override;
			
			signals:
			void sendMousePosition(const QPoint&);
			void Mouse_Pos();
		};
		
		#endif 
	\end{lstlisting}
	
	main.cpp
	\begin{lstlisting}[style=cgstyle, language=C++]
		#include <QApplication>
		#include "mainwindow.h"
		
		int main(int argc, char *argv[]) {
			QApplication a(argc, argv);
			MainWindow w;
			w.show();
			return a.exec();
		}
	\end{lstlisting}
	
	mainwindow.cpp
	\begin{lstlisting}[style=cgstyle, language=C++]
		#include "mainwindow.h"
		#include "ui_mainwindow.h"
		
		#include <QPixmap>
		#include <QImage>
		#include <QPainter>
		#include <QDebug>
		#include <QtMath>
		#include <QThread>
		#include <QCoreApplication>
		#include <QSet>
		#include <QLabel>
		#include <QComboBox>
		#include <algorithm>
		
		static inline QPair<int,int> cellOfPx(int x_px, int y_px, int grid_box) {
			return qMakePair(qFloor(x_px / double(grid_box)), qFloor(y_px / double(grid_box)));
		}
		
		MainWindow::MainWindow(QWidget *parent) :
		QMainWindow(parent),
		ui(new Ui::MainWindow)
		{
			ui->setupUi(this);
			
			draw_clicked = false;
			
			lastPoint1 = QPoint(-1, -1);
			lastPoint2 = QPoint(-1, -1);
			
			
			QPixmap pix(ui->frame->width(), ui->frame->height());
			pix.fill(Qt::black);
			ui->frame->setPixmap(pix);
			
			
			connect(ui->frame, SIGNAL(Mouse_Pos()), this, SLOT(Mouse_Pressed()));
			connect(ui->frame, SIGNAL(sendMousePosition(const QPoint&)),this, SLOT(showMousePosition(const QPoint&)));
			
			
			grid_box  = 10;                               
			grid_size = ui->frame->frameSize().width();   
			center    = 0;
			
			
			polygonFlag = false;
			currPoly.col = Qt::blue;
			currPoly.vertices.clear();
			
			
			currentAlgo = Algo::Flood;
			{
				auto *connLabel = new QLabel("Connectivity:", this);
				connectivitySelect = new QComboBox(this);
				connectivitySelect->setObjectName("connectivity_select");
				connectivitySelect->addItem("4-neighbour");
				connectivitySelect->addItem("8-neighbour");
				
				
				int idx = ui->verticalLayout->indexOf(ui->algo_select);
				ui->verticalLayout->insertWidget(idx + 1, connLabel);
				ui->verticalLayout->insertWidget(idx + 2, connectivitySelect);
				
				
				connect(connectivitySelect, &QComboBox::currentIndexChanged, this, [this](int i){
					connectivityMode = (i == 1) ? Connectivity::Eight : Connectivity::Four;
				});
				connectivitySelect->setCurrentIndex(0); 
			}
			
			
			on_draw_grid_clicked();
		}
		
		MainWindow::~MainWindow()
		{
			delete ui;
		}
		
		
		
		
		void MainWindow::showMousePosition(const QPoint &pos)
		{
			sc_x = pos.x();
			sc_y = pos.y();
			
			int X = (sc_x / this->grid_box) - this->center;
			int Y = -(sc_y / this->grid_box) + this->center;
			
			ui->mouse_movement->setText("X : " + QString::number(X) + ", Y : " + QString::number(Y));
		}
		
		void MainWindow::Mouse_Pressed()
		{
			org_x = sc_x;
			org_y = sc_y;
			
			int X = (sc_x / this->grid_box) - this->center;
			int Y = -(sc_y / this->grid_box) + this->center;
			
			lastPoint1 = lastPoint2;
			lastPoint2 = QPoint(org_x, org_y);
			
			if (polygonFlag) {
				
				currPoly.vertices.push_back(QPoint(X, Y));
				ui->mouse_pressed->setText("Vertex: X=" + QString::number(X) + ", Y=" + QString::number(Y));
				
				
				redraw();
				QPixmap pm = ui->frame->pixmap();
				QPainter painter(&pm);
				draw_polygon_preview(painter, currPoly.vertices);
				draw_vertex_markers(painter, currPoly.vertices);
				painter.end();
				ui->frame->setPixmap(pm);
			} else {
				
				ui->mouse_pressed->setText("Painted: X=" + QString::number(X) + ", Y=" + QString::number(Y));
				paintCellAtPixel(org_x, org_y);
			}
		}
		
		
		
		
		void MainWindow::on_draw_grid_clicked()
		{
			draw_clicked = true;
			
			QPixmap pm = ui->frame->pixmap();
			QPainter painter(&pm);
			
			const int total_cells = this->grid_size / this->grid_box;
			this->center = total_cells / 2;
			
			
			draw_axes(painter);
			
			
			painter.setPen(QPen(Qt::white, 1));
			for (int i = 0; i <= total_cells; i++) {
				int pos = i * this->grid_box;
				painter.drawLine(QPoint(pos, 0), QPoint(pos, this->grid_size));
				painter.drawLine(QPoint(0, pos), QPoint(this->grid_size, pos));
			}
			
			painter.end();
			ui->frame->setPixmap(pm);
		}
		
		void MainWindow::draw_axes(QPainter& painter)
		{
			int c = this->center;
			draw_line_grid(-c,  c, 0, 0, painter, Qt::white); 
			draw_line_grid(0, 0, -c,  c, painter, Qt::white); 
		}
		
		
		
		
		void MainWindow::draw_line_grid(int X1, int X2, int Y1, int Y2,
		QPainter& painter, QColor col)
		{
			const int cells = this->grid_size / this->grid_box;
			
			
			int gx1 = X1 + this->center;
			int gy1 = this->center - Y1;
			int gx2 = X2 + this->center;
			int gy2 = this->center - Y2;
			
			QSet<QRect> rects;
			
			int dx = std::abs(gx2 - gx1);
			int dy = std::abs(gy2 - gy1);
			int sx = (gx1 < gx2) ? 1 : -1;
			int sy = (gy1 < gy2) ? 1 : -1;
			int err = dx - dy;
			
			while (true) {
				if (gy1 >= 0 && gy1 < cells && gx1 >= 0 && gx1 < cells) {
					rects.insert(QRect(gx1 * this->grid_box, gy1 * this->grid_box,
					this->grid_box, this->grid_box));
				}
				if (gx1 == gx2 && gy1 == gy2) break;
				int e2 = 2 * err;
				if (e2 > -dy) { err -= dy; gx1 += sx; }
				if (e2 <  dx) { err += dx; gy1 += sy; }
			}
			
			for (const QRect &rect : rects) {
				painter.fillRect(rect, QBrush(col, Qt::SolidPattern));
			}
		}
		
		
		
		
		void MainWindow::on_clear_clicked()
		{
			lastPoint1 = QPoint(-1, -1);
			lastPoint2 = QPoint(-1, -1);
			currPoly.vertices.clear();
			polygons.clear();
			paintedCells.clear();
			
			QPixmap pix(ui->frame->width(), ui->frame->height());
			pix.fill(Qt::black);
			ui->frame->setPixmap(pix);
			
			on_draw_grid_clicked(); 
		}
		
		void MainWindow::refreshCanvas()
		{
			QPixmap pix(ui->frame->width(), ui->frame->height());
			pix.fill(Qt::black);
			ui->frame->setPixmap(pix);
			on_draw_grid_clicked();
		}
		
		void MainWindow::drawPaintedCells(QPainter& painter)
		{
			for (auto it = paintedCells.constBegin(); it != paintedCells.constEnd(); ++it) {
				const QPair<int,int>& cell = it.key();
				const QColor& color = it.value();
				QRect rect(cell.first * this->grid_box, cell.second * this->grid_box,
				this->grid_box, this->grid_box);
				painter.fillRect(rect, QBrush(color, Qt::SolidPattern));
			}
		}
		
		void MainWindow::redraw()
		{
			QPixmap pm = ui->frame->pixmap();
			QPainter painter(&pm);
			
			
			drawPaintedCells(painter);
			
			
			for (const auto &poly : std::as_const(polygons)) {
				if (poly.vertices.size() >= 2) {
					draw_polygon(painter, poly);
				}
			}
			
			painter.end();
			ui->frame->setPixmap(pm);
			
			
			for (const auto &poly : std::as_const(polygons)) {
				if (poly.boundaryFilled && poly.boundarySeedPx != QPoint(-1, -1)) {
					boundaryFill(poly.boundarySeedPx.x(), poly.boundarySeedPx.y(),
					poly.boundaryCol, QColor(poly.col));
				}
				if (poly.floodFilled && poly.floodSeedPx != QPoint(-1, -1)) {
					floodFill(poly.floodSeedPx.x(), poly.floodSeedPx.y(), poly.floodCol);
				}
				if (poly.scanFilled) {
					scanlineFill(poly, poly.scanCol, false);
				}
			}
		}
		
		
		
		
		void MainWindow::on_grid_size_valueChanged(int grid)
		{
			if (grid < 2) return;
			this->grid_box = grid;
			
			if (!draw_clicked) return;
			
			refreshCanvas();
			redraw();
		}
		
		
		
		
		void MainWindow::draw_polygon(QPainter& painter, const Polygon& poly)
		{
			if (poly.vertices.size() < 2) return;
			
			for (int i = 0; i < poly.vertices.size() - 1; ++i) {
				const QPoint p1 = poly.vertices[i];
				const QPoint p2 = poly.vertices[i + 1];
				draw_line_grid(p1.x(), p2.x(), p1.y(), p2.y(), painter, QColor(poly.col));
			}
			
			draw_line_grid(poly.vertices.back().x(), poly.vertices.front().x(),
			poly.vertices.back().y(), poly.vertices.front().y(),
			painter, QColor(poly.col));
		}
		
		void MainWindow::draw_polygon_preview(QPainter& painter, const QVector<QPoint>& verts)
		{
			if (verts.size() < 1) return;
			
			for (int i = 0; i + 1 < verts.size(); ++i) {
				const QPoint p1 = verts[i];
				const QPoint p2 = verts[i + 1];
				draw_line_grid(p1.x(), p2.x(), p1.y(), p2.y(), painter, QColor(Qt::blue));
			}
		}
		
		void MainWindow::draw_vertex_markers(QPainter& painter, const QVector<QPoint>& verts)
		{
			const int cells = this->grid_size / this->grid_box;
			for (const QPoint &v : verts) {
				int gx = v.x() + this->center;
				int gy = this->center - v.y();
				if (gx < 0 || gy < 0 || gx >= cells || gy >= cells) continue;
				QRect rect(gx * this->grid_box, gy * this->grid_box, this->grid_box, this->grid_box);
				painter.fillRect(rect, QBrush(Qt::cyan, Qt::SolidPattern)); 
			}
		}
		
		void MainWindow::on_start_polygon_clicked()
		{
			polygonFlag = true;
			currPoly = Polygon();          
			currPoly.col = Qt::blue;
			currPoly.vertices.clear();
		}
		
		void MainWindow::on_close_polygon_clicked()
		{
			if (currPoly.vertices.size() < 3) {
				qDebug() << "Need at least 3 points to form a polygon.";
			} else {
				polygonFlag = false;
				polygons.push_back(currPoly);
				
				
				QPixmap pm = ui->frame->pixmap();
				QPainter painter(&pm);
				draw_polygon(painter, currPoly);
				painter.end();
				ui->frame->setPixmap(pm);
			}
			currPoly.vertices.clear();
		}
		
		
		
		
		void MainWindow::paintCellAtPixel(int x_px, int y_px)
		{
			auto cell = cellOfPx(x_px, y_px, this->grid_box);
			const int gx = cell.first;
			const int gy = cell.second;
			
			const int cells = this->grid_size / this->grid_box;
			if (gx < 0 || gy < 0 || gx >= cells || gy >= cells) return;
			
			paintedCells[qMakePair(gx, gy)] = Qt::yellow;
			
			QPixmap pm = ui->frame->pixmap();
			QPainter painter(&pm);
			
			QRect rect(gx * this->grid_box, gy * this->grid_box,
			this->grid_box, this->grid_box);
			painter.fillRect(rect, QBrush(Qt::yellow, Qt::SolidPattern));
			painter.end();
			
			ui->frame->setPixmap(pm);
		}
		
		
		
		
		void MainWindow::floodFill(int x, int y, const QColor& newColor)
		{
			QPixmap pm = ui->frame->pixmap();
			if (pm.isNull()) return;
			
			const int cells = this->grid_size / this->grid_box;
			int gx0 = qFloor(x / (double)this->grid_box);
			int gy0 = qFloor(y / (double)this->grid_box);
			if (gx0 < 0 || gy0 < 0 || gx0 >= cells || gy0 >= cells) return;
			
			QImage img = pm.toImage();
			
			
			int cx0 = gx0 * this->grid_box + this->grid_box / 2;
			int cy0 = gy0 * this->grid_box + this->grid_box / 2;
			QColor seed = img.pixelColor(cx0, cy0);
			const bool seedIsYellow = (seed == Qt::yellow);
			
			QColor regionColor;
			if (seed == Qt::white || seedIsYellow) {
				regionColor = Qt::black;         
			} else {
				regionColor = seed;
			}
			
			if (regionColor == newColor) return;
			
			
			paintedCells.remove(qMakePair(gx0, gy0));
			
			QSet<QPair<int, int>> visited;
			QVector<QPoint> stack;
			stack.append(QPoint(gx0, gy0));
			
			QPainter painter(&pm);
			
			auto maybeAnimate = [&]() {
				ui->frame->setPixmap(pm);
				QCoreApplication::processEvents();
				QThread::msleep(15);
			};
			
			auto push4 = [&](int gx, int gy) {
				stack.append(QPoint(gx + 1, gy));
				stack.append(QPoint(gx - 1, gy));
				stack.append(QPoint(gx, gy + 1));
				stack.append(QPoint(gx, gy - 1));
			};
			auto push8 = [&](int gx, int gy) {
				push4(gx, gy);
				stack.append(QPoint(gx + 1, gy + 1));
				stack.append(QPoint(gx - 1, gy + 1));
				stack.append(QPoint(gx + 1, gy - 1));
				stack.append(QPoint(gx - 1, gy - 1));
			};
			
			while (!stack.isEmpty()) {
				QPoint p = stack.takeLast();
				int gx = p.x();
				int gy = p.y();
				
				if (gx < 0 || gy < 0 || gx >= cells || gy >= cells) continue;
				
				QPair<int, int> key(gx, gy);
				if (visited.contains(key)) continue;
				visited.insert(key);
				
				int cx = gx * this->grid_box + this->grid_box / 2;
				int cy = gy * this->grid_box + this->grid_box / 2;
				
				QColor cur = img.pixelColor(cx, cy);
				
				const bool isSeed = (gx == gx0 && gy == gy0);
				
				
				if (cur == Qt::yellow && !isSeed) continue;
				
				
				if (cur == Qt::white) cur = regionColor;
				
				
				if (isSeed && seedIsYellow) cur = regionColor;
				
				if (cur != regionColor) continue;
				
				QRect rect(gx * this->grid_box, gy * this->grid_box, this->grid_box, this->grid_box);
				painter.fillRect(rect, QBrush(newColor, Qt::SolidPattern));
				
				maybeAnimate();
				
				if (connectivityMode == Connectivity::Eight) {
					push8(gx, gy);
				} else {
					push4(gx, gy);
				}
			}
			
			painter.end();
			ui->frame->setPixmap(pm);
		}
		
		
		void MainWindow::boundaryFill(int x, int y, const QColor& newColor, const QColor& boundaryColor)
		{
			QPixmap pm = ui->frame->pixmap();
			if (pm.isNull()) return;
			
			const int cells = this->grid_size / this->grid_box;
			int gx0 = qFloor(x / (double)this->grid_box);
			int gy0 = qFloor(y / (double)this->grid_box);
			if (gx0 < 0 || gy0 < 0 || gx0 >= cells || gy0 >= cells) return;
			
			QImage img = pm.toImage();
			
			QSet<QPair<int,int>> visited;
			QVector<QPoint> stack;
			stack.append(QPoint(gx0, gy0));
			
			QPainter painter(&pm);
			
			auto maybeAnimate = [&]() {
				ui->frame->setPixmap(pm);
				QCoreApplication::processEvents();
				QThread::msleep(15);
			};
			
			auto push4 = [&](int gx, int gy) {
				stack.append(QPoint(gx + 1, gy));
				stack.append(QPoint(gx - 1, gy));
				stack.append(QPoint(gx, gy + 1));
				stack.append(QPoint(gx, gy - 1));
			};
			auto push8 = [&](int gx, int gy) {
				push4(gx, gy);
				stack.append(QPoint(gx + 1, gy + 1));
				stack.append(QPoint(gx - 1, gy + 1));
				stack.append(QPoint(gx + 1, gy - 1));
				stack.append(QPoint(gx - 1, gy - 1));
			};
			
			while (!stack.isEmpty()) {
				QPoint p = stack.takeLast();
				int gx = p.x();
				int gy = p.y();
				if (gx < 0 || gy < 0 || gx >= cells || gy >= cells) continue;
				
				QPair<int,int> key(gx, gy);
				if (visited.contains(key)) continue;
				visited.insert(key);
				
				int cx = gx * this->grid_box + this->grid_box / 2;
				int cy = gy * this->grid_box + this->grid_box / 2;
				
				QColor cur = img.pixelColor(cx, cy);
				if (cur == newColor) continue;             
				if (cur == boundaryColor) continue;        
				
				QRect rect(gx * this->grid_box, gy * this->grid_box, this->grid_box, this->grid_box);
				painter.fillRect(rect, QBrush(newColor, Qt::SolidPattern));
				
				maybeAnimate();
				
				if (connectivityMode == Connectivity::Eight) {
					push8(gx, gy);
				} else {
					push4(gx, gy);
				}
			}
			
			painter.end();
			ui->frame->setPixmap(pm);
		}
		
		void MainWindow::scanlineFill(const Polygon& poly, const QColor& fillColor, bool animate)
		{
			if (poly.vertices.size() < 3) return;
			
			int ymin = poly.vertices.front().y();
			int ymax = ymin;
			for (const QPoint &v : poly.vertices) {
				ymin = std::min(ymin, v.y());
				ymax = std::max(ymax, v.y());
			}
			
			QPixmap pm = ui->frame->pixmap();
			if (pm.isNull()) return;
			
			const int cells = this->grid_size / this->grid_box;
			const int n = poly.vertices.size();
			
			QPainter painter(&pm);
			QImage   img = pm.toImage();
			
			auto maybeAnimate = [&]() {
				if (animate) {
					ui->frame->setPixmap(pm);
					QCoreApplication::processEvents();
					QThread::msleep(20);
				}
			};
			
			const double epsx = 1e-6;
			
			for (int y = ymin; y <= ymax; ++y) {
				QVector<double> interX;
				interX.reserve(n);
				
				for (int i = 0; i < n; ++i) {
					const QPoint p1 = poly.vertices[i];
					const QPoint p2 = poly.vertices[(i + 1) % n];
					const int x1 = p1.x(), y1 = p1.y();
					const int x2 = p2.x(), y2 = p2.y();
					
					if (y1 == y2) continue;
					
					const int yminEdge = std::min(y1, y2);
					const int ymaxEdge = std::max(y1, y2);
					if (y >= yminEdge && y < ymaxEdge) {
						const double t  = ((y + 0.5) - y1) / double(y2 - y1);
						const double ix = x1 + t * (x2 - x1);
						interX.append(ix);
					}
				}
				
				if (interX.isEmpty()) continue;
				std::sort(interX.begin(), interX.end());
				
				for (int k = 0; k + 1 < interX.size(); k += 2) {
					const double L = std::min(interX[k],   interX[k+1]);
					const double R = std::max(interX[k],   interX[k+1]);
					
					int xLeft  = int(std::ceil (L + epsx));
					int xRight = int(std::floor(R - epsx));
					if (xRight < xLeft) continue;
					
					for (int lx = xLeft; lx <= xRight; ++lx) {
						int gx = lx + this->center;
						int gy = this->center - y;
						if (gx < 0 || gy < 0 || gx >= cells || gy >= cells) continue;
						
						const int cx = gx * this->grid_box + this->grid_box / 2;
						const int cy = gy * this->grid_box + this->grid_box / 2;
						const QColor cur = img.pixelColor(cx, cy);
						
						if (cur == QColor(poly.col) ) continue;
						
						QRect rect(gx * this->grid_box, gy * this->grid_box,
						this->grid_box, this->grid_box);
						painter.fillRect(rect, QBrush(fillColor, Qt::SolidPattern));
					}
					maybeAnimate();
				}
			}
			
			painter.end();
			ui->frame->setPixmap(pm);
		}
		
		
		void MainWindow::on_fill_polygon_clicked()
		{
			if (polygons.isEmpty()) return;
			
			Polygon &poly = polygons.last();
			
			if (currentAlgo == Algo::Boundary) {
				if (lastPoint2 == QPoint(-1, -1)) return;
				poly.boundaryFilled = true;
				poly.boundaryCol = Qt::green;
				poly.boundarySeedPx = lastPoint2;
				boundaryFill(lastPoint2.x(), lastPoint2.y(), poly.boundaryCol, QColor(poly.col));
			} else if (currentAlgo == Algo::Flood) {
				if (lastPoint2 == QPoint(-1, -1)) return;
				poly.floodFilled = true;
				poly.floodCol = Qt::red;
				poly.floodSeedPx = lastPoint2;
				floodFill(lastPoint2.x(), lastPoint2.y(), poly.floodCol);
			} else { 
				poly.scanFilled = true;
				poly.scanCol = Qt::magenta;
				scanlineFill(poly, poly.scanCol, true);
			}
		}
		
		void MainWindow::on_clear_fill_clicked()
		{
			
			for (auto &poly : polygons) {
				poly.floodFilled = false;     poly.floodSeedPx = QPoint(-1,-1);
				poly.boundaryFilled = false;  poly.boundarySeedPx = QPoint(-1,-1);
				poly.scanFilled = false;
			}
			refreshCanvas();
			redraw();
		}
		
		void MainWindow::on_algo_select_currentIndexChanged(int)
		{
			const QString txt = ui->algo_select->currentText().toLower();
			if (txt.contains("boundary")) { currentAlgo = Algo::Boundary; return; }
			if (txt.contains("flood"))    { currentAlgo = Algo::Flood;    return; }
			if (txt.contains("scan"))     { currentAlgo = Algo::Scan;     return; }
			currentAlgo = Algo::Flood; 
		}
	\end{lstlisting}
	my\_label.cpp
	\begin{lstlisting}[style=cgstyle, language=C++]
		#include "my_label.h"
		
		my_label::my_label(QWidget *parent) : QLabel(parent)
		{
			this->setMouseTracking(true);
		}
		
		void my_label::mouseMoveEvent(QMouseEvent *ev)
		{
			QPoint pos = ev->pos();
			if (pos.x() >= 0 && pos.y() >= 0 && pos.x() < this->width() && pos.y() < this->height()) {
				emit sendMousePosition(pos);
			}
		}
		
		void my_label::mousePressEvent(QMouseEvent *ev)
		{
			if (ev->button() == Qt::LeftButton) {
				x = ev->x();
				y = ev->y();
				emit Mouse_Pos();
			}
		}
	\end{lstlisting}
	\clearpage
	\subsubsection*{Outputs}
	\vspace{-0.9em} 
	
	% ---------- Boundary Fill ----------
	\begin{figure}[h]
		\centering
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{images/boundaryfill_before_filling_8_neighbour}
			\caption{boundaryfill\_before\_filling\_8\_neighbour}
		\end{subfigure}
		\hfill
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{images/boundaryfill_before_filling_4_neighbour}
			\caption{boundaryfill\_before\_filling\_4\_neighbour}
		\end{subfigure}
		
		\vspace{0.5em}
		
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{images/boundaryfill_after_filling_8_neighbour}
			\caption{boundaryfill\_after\_filling\_8\_neighbour}
		\end{subfigure}
		\hfill
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{images/boundaryfill_after_filling_4_neighbour}
			\caption{boundaryfill\_after\_filling\_4\_neighbour}
		\end{subfigure}
		
		\caption{Boundary fill outputs.}
	\end{figure}
	
	\clearpage
	
	% ---------- Flood Fill ----------
	\begin{figure}[h]
		\centering
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{images/floodfill_before_filling_8_neighbour}
			\caption{floodfill\_before\_filling\_8\_neighbour}
		\end{subfigure}
		\hfill
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{images/floodfill_before_filling_4_neighbour}
			\caption{floodfill\_before\_filling\_4\_neighbour}
		\end{subfigure}
		
		\vspace{0.5em}
		
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{images/floodfill_after_filling_8_neighbour}
			\caption{floodfill\_after\_filling\_8\_neighbour}
		\end{subfigure}
		\hfill
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{images/floodfill_after_filling_4_neighbour}
			\caption{floodfill\_after\_filling\_4\_neighbour}
		\end{subfigure}
		
		\caption{Flood fill outputs.}
	\end{figure}
	
	\clearpage
	
	% ---------- Scanline Fill ----------
	\begin{figure}[h]
		\centering
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{images/scanline_before_filling}
			\caption{scanline\_before\_filling}
		\end{subfigure}
		\hfill
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{images/scanline_after_filling}
			\caption{scanline\_after\_filling}
		\end{subfigure}
		
		\caption{Scanline fill outputs.}
	\end{figure}
	
	
	
	\clearpage
    \subsubsection*{Output Explanation}

For this assignment I interactively drew simple test polygons and regions on the grid and then applied the three implemented filling strategies: flood fill, boundary fill, and scanline fill. The behaviour of each algorithm is clearly visible in the rendered outputs.

\paragraph{Flood fill (4- and 8-neighbour connectivity).}

For flood fill I first painted a closed blue polygon and then manually drew an interior \emph{yellow} barrier inside the polygon. I then chose a seed point in one of the blue interior regions and applied flood fill with red as the new region colour.

With \textbf{4-neighbour connectivity}, the fill spreads only through the 4-connected neighbours
\[
N_4(x,y) = \{(x\pm1,y), (x,y\pm1)\},
\]
and at every step the implementation checks that the current pixel belongs to the same region colour and is not yellow. As a result, the red region expands until it touches either the blue boundary or any yellow cell, and stops there. The yellow barrier therefore acts as a strict blocking curve, and the output shows the interior region subdivided into disjoint red components separated by yellow lines.

When I switch to \textbf{8-neighbour connectivity},
\[
N_8(x,y) = N_4(x,y) \cup \{(x\pm1,y\pm1)\},
\]
the fill is allowed to propagate diagonally as well. In regions where there are diagonal gaps of size one cell between the yellow barrier and the boundary, the 8-connected flood fill can leak through those diagonal connections, and those subregions are now filled. However, any cell that is actually yellow is still treated as an obstacle, so the fill never overwrites the yellow colour. The final output clearly demonstrates that flood fill respects the interior barrier colour and cannot ``cross'' yellow, regardless of the chosen connectivity.

\paragraph{Boundary fill (4- and 8-neighbour connectivity).}

For boundary fill I used the same polygons but with a designated boundary colour (for example blue), and a seed point strictly inside the polygon. In this case the region predicate is different: the algorithm expands from the seed until it meets the boundary colour, and it does not treat yellow as an obstacle.

With \textbf{4-neighbour boundary fill}, the interior is filled with green by visiting all pixels whose colour is not the boundary colour and not already the fill colour. The yellow barrier is therefore overwritten just like any other interior colour, because the decision test only compares against the blue boundary. The resulting output shows a completely green interior with the blue outline intact and the original yellow barrier no longer visible.

With \textbf{8-neighbour boundary fill}, diagonal neighbours are also considered. As with flood fill, this allows the algorithm to reach diagonally connected interior cells more quickly, but again there is no special treatment of yellow: the fill propagates through, only stopping at the boundary pixels themselves. The two outputs together make it clear that, unlike flood fill, boundary fill can ``cross'' interior colours such as yellow and will fill the entire connected interior region up to the polygon boundary.

\paragraph{Scanline fill on a concave polygon.}

The algorithm computes, for each integer scanline \(y\) between the polygon’s minimum and maximum \(y\)-coordinates, all intersections of that horizontal line with polygon edges, sorts the intersection \(x\)-coordinates, and fills alternating intervals between successive pairs according to the even–odd rule.

In the output this produces horizontal magenta bands that correctly cover the entire interior of the concave polygon, including the indented regions, without spilling outside or leaving gaps. The scanline method correctly handles the non-convex shape because the alternating pairing of intersection points ensures that only the intended interior segments along each scanline are filled.
\clearpage
	
	% -------- ASSIGNMENT 5 --------
	\subsection*{Assignment 5: 2D Transformations}
	\addcontentsline{toc}{subsection}{Assignment 5: 2D Transformations}
	
	\subsubsection*{Problem Statement}
	Draw a closed polygon and implement different transformation functions (with respect to the origin) on it:
	\begin{itemize}
		\item Translation
		\item Rotation
		\item Scaling
		\item Shear
		\item Reflection with respect to the \(x\)- and \(y\)-axes
	\end{itemize}
	
	Extend the algorithm to apply the transformations successively on the same object using homogeneous coordinates and matrix multiplication, including:
	\begin{itemize}
		\item Reflection with respect to an arbitrary line
		\item Rotation with respect to an arbitrary point
	\end{itemize}
	
	\subsubsection*{Code and Theoretical Explanation}
% :contentReference[oaicite:0]{index=0}

In this assignment I first draw a polygon on a discrete Cartesian grid and then apply a sequence of 2D affine transformations to its vertices. Each vertex
\[
\mathbf{p} = (x,y)
\]
is internally represented in homogeneous coordinates as the column vector
\[
\tilde{\mathbf{p}} =
\begin{bmatrix}
x\\[2pt] y\\[2pt] 1
\end{bmatrix},
\]
so that every transformation can be written as a \(3\times 3\) matrix \(\mathbf{T}\) and applied by a single matrix--vector multiplication
\[
\tilde{\mathbf{p}}' = \mathbf{T}\,\tilde{\mathbf{p}}.
\]
This matches the way \texttt{QTransform} stores transformations and the way I use it in \texttt{applyTransform(const QTransform\& T)}, where each vertex is mapped via
\begin{lstlisting}[style=cgstyle,language=C++]
QPointF r = T.map(QPointF(v.x(), v.y()));
out.push_back(QPoint(qRound(r.x()), qRound(r.y())));
\end{lstlisting}
corresponding exactly to multiplying \(\tilde{\mathbf{p}}\) by the composed matrix \(\mathbf{T}\).

\paragraph*{Homogeneous matrices for basic 2D transformations.}
Using homogeneous coordinates, all basic 2D transformations are expressed as affine matrices of the form
\[
\mathbf{T} =
\begin{bmatrix}
a & b & t_x\\[2pt]
c & d & t_y\\[2pt]
0 & 0 & 1
\end{bmatrix},
\qquad
\tilde{\mathbf{p}}' = \mathbf{T}\,\tilde{\mathbf{p}} =
\begin{bmatrix}
a x + b y + t_x\\[2pt]
c x + d y + t_y\\[2pt]
1
\end{bmatrix}.
\]

\subparagraph*{Translation.}
A translation by \((t_x,t_y)\) adds a constant offset to every vertex:
\[
x' = x + t_x,\qquad y' = y + t_y.
\]
In homogeneous form,
\[
\mathbf{T}_{\text{trans}}(t_x,t_y)=
\begin{bmatrix}
1 & 0 & t_x\\[2pt]
0 & 1 & t_y\\[2pt]
0 & 0 & 1
\end{bmatrix},\qquad
\tilde{\mathbf{p}}'=\mathbf{T}_{\text{trans}}\tilde{\mathbf{p}}.
\]
In code, this is implemented in \texttt{on\_btnTranslate\_clicked()}:
\begin{lstlisting}[style=cgstyle,language=C++]
QTransform T;
T.translate(ui->spinTx->value(), ui->spinTy->value());
applyTransform(T);
\end{lstlisting}
which internally constructs the same matrix \(\mathbf{T}_{\text{trans}}\).

\subparagraph*{Rotation about the origin.}
For a rotation by angle \(\theta\) about the origin, the analytic equations are
\[
\begin{aligned}
x' &= x\cos\theta - y\sin\theta,\\
y' &= x\sin\theta + y\cos\theta.
\end{aligned}
\]
The corresponding homogeneous matrix is
\[
\mathbf{R}(\theta) =
\begin{bmatrix}
\cos\theta & -\sin\theta & 0\\[2pt]
\sin\theta &  \cos\theta & 0\\[2pt]
0          &  0          & 1
\end{bmatrix}.
\]
Because the screen \(y\)-axis grows downwards, I supply a negative angle in
\texttt{on\_btnRotate\_clicked()}:
\begin{lstlisting}[style=cgstyle,language=C++]
QTransform T;
T.rotate(-ui->spinAngle->value());
applyTransform(T);
\end{lstlisting}
so that a positive angle in the UI still corresponds to a counterclockwise
rotation in the mathematical \(xy\)-plane.

\subparagraph*{Scaling.}
Scaling by factors \(s_x\) and \(s_y\) along the \(x\) and \(y\) axes is given by
\[
x' = s_x x,\qquad y' = s_y y,
\]
and the matrix form is
\[
\mathbf{S}(s_x,s_y) =
\begin{bmatrix}
s_x & 0   & 0\\[2pt]
0   & s_y & 0\\[2pt]
0   & 0   & 1
\end{bmatrix}.
\]
To avoid degenerate behaviour when the user sets negative slider values, I
convert an input scale \(s\) into an effective factor
\[
s_{\text{eff}} =
\begin{cases}
\displaystyle \frac{1}{1+(-s)}, & s < 0,\\[4pt]
s, & s \ge 0,
\end{cases}
\]
in \texttt{effectiveScale(double s)}, and then apply scaling about the current
pivot (polygon centroid) in \texttt{on\_btnScale\_clicked()}:
\begin{lstlisting}[style=cgstyle,language=C++]
QPointF c  = currentPivot();
double sx  = effectiveScale(ui->spinSx->value());
double sy  = effectiveScale(ui->spinSy->value());

QTransform T;
T.translate(c.x(), c.y());
T.scale(sx, sy);
T.translate(-c.x(), -c.y());
applyTransform(T);
\end{lstlisting}
Mathematically, scaling about the centroid \(\mathbf{c}=(c_x,c_y)\) is the
composition
\[
\mathbf{T}_{\text{scale,centroid}}
= \mathbf{T}(c_x,c_y)\,\mathbf{S}(s_x,s_y)\,\mathbf{T}(-c_x,-c_y).
\]

\subparagraph*{Shear.}
A shear transformation keeps one axis fixed while sliding points along the
other. With shear factors \(h_x\) (horizontal shear proportional to \(y\)) and
\(h_y\) (vertical shear proportional to \(x\)), the equations are
\[
x' = x + h_x y,\qquad y' = y + h_y x,
\]
which correspond to
\[
\mathbf{H}(h_x,h_y) =
\begin{bmatrix}
1   & h_x & 0\\[2pt]
h_y & 1   & 0\\[2pt]
0   & 0   & 1
\end{bmatrix}.
\]
In code I again shear about the polygon centroid:
\begin{lstlisting}[style=cgstyle,language=C++]
QPointF c  = currentPivot();
double shx = ui->spinShx->value();
double shy = ui->spinShy->value();

QTransform T;
T.translate(c.x(), c.y());
T.shear(shx, shy);
T.translate(-c.x(), -c.y());
applyTransform(T);
\end{lstlisting}
which implements \(\mathbf{T}(c)\,\mathbf{H}(h_x,h_y)\,\mathbf{T}(-c)\).

\subparagraph*{Reflection about coordinate axes.}
Reflection about the \(x\)-axis maps \((x,y)\mapsto(x,-y)\). Its matrix is
\[
\mathbf{R}_{x\text{-axis}} =
\begin{bmatrix}
1 & 0 & 0\\[2pt]
0 & -1& 0\\[2pt]
0 & 0 & 1
\end{bmatrix}.
\]
Similarly, reflection about the \(y\)-axis maps \((x,y)\mapsto(-x,y)\) with
\[
\mathbf{R}_{y\text{-axis}} =
\begin{bmatrix}
-1& 0 & 0\\[2pt]
0 & 1 & 0\\[2pt]
0 & 0 & 1
\end{bmatrix}.
\]
These are created directly in \texttt{on\_btnReflectX\_clicked()} and
\texttt{on\_btnReflectY\_clicked()}:
\begin{lstlisting}[style=cgstyle,language=C++]
QTransform T( 1, 0, 0,
              0,-1, 0, 0, 0, 1); // reflect about X
QTransform T(-1, 0, 0,
              0, 1, 0, 0, 0, 1); // reflect about Y
\end{lstlisting}

\paragraph*{Rotation about an arbitrary point.}
To rotate about an arbitrary pivot \(\mathbf{p}_0=(p_x,p_y)\), I first translate
the pivot to the origin, rotate, and then translate back:
\[
\tilde{\mathbf{p}}' =
\mathbf{T}(p_x,p_y)\,
\mathbf{R}(\theta)\,
\mathbf{T}(-p_x,-p_y)\,
\tilde{\mathbf{p}}.
\]
This composition is implemented in
\texttt{on\_btnRotateAboutPoint\_clicked()} using the last grid point picked by
the user as pivot:
\begin{lstlisting}[style=cgstyle,language=C++]
QTransform T;
T.translate(lastPick.x(), lastPick.y());
T.rotate(-ui->spinAngle->value());
T.translate(-lastPick.x(), -lastPick.y());
applyTransform(T);
\end{lstlisting}
so each vertex is rotated around the chosen point without changing the pivot
itself.

\paragraph*{Reflection about an arbitrary line.}
For reflection with respect to an arbitrary line, I allow the user to draw a
helper line through two points \(a=(a_x,a_y)\) and \(b=(b_x,b_y)\). For the
special cases where the line has slope \(\pm 1\), I use closed-form formulas in
grid coordinates. For example, for a line of slope \(+1\) of the form
\(y = x + k\), each vertex \((x,y)\) is reflected to
\[
x' = y - k,\qquad y' = x + k,
\]
as implemented in \texttt{reflectSpecialIfSlopePM1()} by constructing new
integer points.

For general lines, I work with unit direction vector
\[
\mathbf{u} =
\frac{1}{\|\mathbf{b}-\mathbf{a}\|}
\begin{bmatrix}
b_x-a_x\\[2pt] b_y-a_y
\end{bmatrix}
=
\begin{bmatrix}
u_x\\[2pt] u_y
\end{bmatrix}.
\]
The \(2\times 2\) reflection matrix about the line through the origin with
direction \(\mathbf{u}\) is
\[
\mathbf{M} =
\begin{bmatrix}
2u_x^2 - 1 & 2u_x u_y\\[2pt]
2u_x u_y   & 2u_y^2 - 1
\end{bmatrix},
\]
which comes from reflecting the vector after decomposing it into components
parallel and perpendicular to \(\mathbf{u}\). For a line that does not pass
through the origin, I first translate each vertex so that \(\mathbf{a}\) moves
to the origin, apply \(\mathbf{M}\), and then translate back:
\[
\mathbf{v}' = \mathbf{a} + \mathbf{M}(\mathbf{v}-\mathbf{a}).
\]
This is exactly what I implement in
\texttt{reflectPointAboutLine(const QPointF\& v,\dots)}:
\begin{lstlisting}[style=cgstyle,language=C++]
double ux = b.x() - a.x();
double uy = b.y() - a.y();
double invLen = 1.0 / std::sqrt(ux*ux + uy*uy);
ux *= invLen; uy *= invLen;

double r11 = 2.0*ux*ux - 1.0;
double r12 = 2.0*ux*uy;
double r21 = r12;
double r22 = 2.0*uy*uy - 1.0;

double wx = v.x() - a.x();
double wy = v.y() - a.y();

double rx = r11*wx + r12*wy;
double ry = r21*wx + r22*wy;

return QPointF(a.x() + rx, a.y() + ry);
\end{lstlisting}
and then apply it to each vertex in
\texttt{on\_btnReflectDrawnLine\_clicked()}.

\paragraph*{Matrix composition and reuse.}
All transformations above are composed as homogeneous matrices and then applied
in one pass to the vertex list. Algebraically, if I want to scale, then rotate,
then translate a polygon, the final transformation is
\[
\mathbf{T}_{\text{final}}
=
\mathbf{T}_{\text{trans}}\,
\mathbf{R}(\theta)\,
\mathbf{S}(s_x,s_y),
\]
and every vertex is updated as
\(\tilde{\mathbf{p}}'=\mathbf{T}_{\text{final}}\,\tilde{\mathbf{p}}\).
\texttt{QTransform} internally performs this matrix multiplication whenever I
chain operations using \texttt{translate}, \texttt{rotate}, \texttt{scale},
\texttt{shear}, etc., and then \texttt{applyTransform()} maps all vertices using
the single composed matrix.

	
	
	\subsubsection*{Code}
	transformation.pro
	\begin{lstlisting}[style=cgstyle,language=C++]
		TEMPLATE = app
		TARGET = transformation
		
		QT += widgets core gui
		CONFIG += c++17
		CONFIG += warn_on
		macx: CONFIG += app_bundle
		
		SOURCES += \
		main.cpp \
		mainwindow.cpp \
		my_label.cpp
		
		HEADERS += \
		mainwindow.h \
		my_label.h
		
		FORMS += \
		mainwindow.ui
		
		INCLUDEPATH += .
	\end{lstlisting}
	
	mainwindow.h
	\begin{lstlisting}[style=cgstyle, language=C++]
		#ifndef MAINWINDOW_H
		#define MAINWINDOW_H
		
		#include <QMainWindow>
		#include <QVector>
		#include <QPoint>
		#include <QColor>
		#include <QTransform>
		#include <QSet>
		#include <QTimer>
		#include <climits>
		
		QT_BEGIN_NAMESPACE
		namespace Ui { class MainWindow; }
		QT_END_NAMESPACE
		
		class MainWindow : public QMainWindow
		{
			Q_OBJECT
			public:
			explicit MainWindow(QWidget *parent = nullptr);
			~MainWindow();
			
			protected:
			bool eventFilter(QObject* obj, QEvent* event) override;
			
			private slots:
			void Mouse_Pressed();
			void showMousePosition(QPoint &pos);
			
			void on_btnDrawGrid_clicked();
			void on_spinGridSize_valueChanged(int value);
			void on_btnClear_clicked();
			
			void on_btnClosePolygon_clicked();
			
			void on_btnRevertOriginal_clicked();
			
			void on_btnTranslate_clicked();
			void on_btnRotate_clicked();
			void on_btnRotateAboutPoint_clicked();
			void on_btnScale_clicked();
			void on_btnShear_clicked();
			void on_btnReflectX_clicked();
			void on_btnReflectY_clicked();
			void on_btnDrawLine_clicked();
			void on_btnReflectDrawnLine_clicked();
			
			void nudgeUp();
			void nudgeLeft();
			void nudgeDown();
			void nudgeRight();
			
			private:
			Ui::MainWindow *ui = nullptr;
			
			int  cellSize  = 20;
			int  gridCols  = 0, gridRows = 0;
			int  centerX   = 0, centerY = 0;
			bool gridDrawn = false;
			
			QColor bgColor    = QColor(11,21,64);
			QColor gridColor  = QColor(240,240,240);
			QColor axisColor  = QColor(255,255,255);
			QColor polyColor  = QColor(255,208,96);
			QColor origColor  = QColor(140,255,200);
			QColor pickFill   = QColor(255,105,180);
			QColor lineColor  = QColor(80,220,255);
			
			int    scrX = 0, scrY = 0;
			QPoint lastPick = QPoint(INT_MIN, INT_MIN);
			QPoint prevPick = QPoint(INT_MIN, INT_MIN);
			
			QVector<QPoint> polygon;
			QVector<QPoint> originalPolygon;
			bool hasOriginal   = false;
			bool polygonClosed = false;
			
			bool   hasDrawnLine = false;
			QPoint lineP1, lineP2;
			
			void repaintFreshGrid();
			void drawAxes(class QPainter& p);
			void refreshScene();
			void fillPickedCellPx(int px, int py);
			
			QPoint screenPxToGridXY(int px, int py) const;
			QPoint gridXYToCellTL(int X, int Y) const;
			
			void drawPolygon(class QPainter& p);
			void drawPoly(const QVector<QPoint>& poly, class QPainter& p, const QColor& color);
			void drawHelperLine(class QPainter& p);
			void rasterBresenham(int X1, int Y1, int X2, int Y2, QVector<QPoint>& outCells);
			inline void fillCellGrid(int gx, int gy, class QPainter& p);
			
			void applyTransform(const QTransform& T);
			
			QTransform reflectAboutTwoPointLine(const QPointF& p1, const QPointF& p2);
			
			
			bool hasValid(const QPoint& p) const { return p.x()!=INT_MIN && p.y()!=INT_MIN; }
			QPointF firstVertexPivot() const;
			void updateOriginalUiState();
			
			QPointF polygonCentroid(const QVector<QPoint>& poly) const;
			QPointF currentPivot() const;
			
			
			QPointF reflectPointAboutLine(const QPointF& v,
			const QPointF& a,
			const QPointF& b) const;
			bool reflectSpecialIfSlopePM1(const QPoint& a, const QPoint& b,
			QVector<QPoint>& out) const;
			
			double effectiveScale(double s) const;
			
			void translateByCells(int dx, int dy);
			
			QSet<int> pressedKeys;
			QTimer*   nudgeTimer = nullptr;
			void scheduleNudge();
			void performNudge();
		};
		
		#endif
	\end{lstlisting}
	
	my\_label.h
	\begin{lstlisting}[style=cgstyle, language=C++]
		#ifndef MY_LABEL_H
		#define MY_LABEL_H
		
		#include <QLabel>
		#include <QMouseEvent>
		
		class my_label : public QLabel
		{
			Q_OBJECT
			public:
			explicit my_label(QWidget *parent = nullptr);
			
			protected:
			void mouseMoveEvent(QMouseEvent *ev) override;
			void mousePressEvent(QMouseEvent *ev) override;
			
			signals:
			void sendMousePosition(QPoint&);
			void Mouse_Pos();
			
			private:
			int lastX = -1, lastY = -1;
		};
		
		#endif 
	\end{lstlisting}
	
	main.cpp
	\begin{lstlisting}[style=cgstyle, language=C++]
		#include "mainwindow.h"
		#include <QApplication>
		
		int main(int argc, char *argv[])
		{
			QApplication a(argc, argv);
			MainWindow w;
			w.show();
			return a.exec();
		}
	\end{lstlisting}
	
	mainwindow.cpp
	\begin{lstlisting}[style=cgstyle, language=C++]
		#include "mainwindow.h"
		#include "ui_mainwindow.h"
		
		#include <QPixmap>
		#include <QPainter>
		#include <QPen>
		#include <QtMath>
		#include <QApplication>
		#include <QKeyEvent>
		#include <QTimer>
		#include <climits>
		#include <cmath>
		
		MainWindow::MainWindow(QWidget *parent)
		: QMainWindow(parent), ui(new Ui::MainWindow)
		{
			ui->setupUi(this);
			
			QPixmap pm(ui->frame->width(), ui->frame->height());
			pm.fill(bgColor);
			ui->frame->setPixmap(pm);
			
			connect(ui->frame, SIGNAL(Mouse_Pos()), this, SLOT(Mouse_Pressed()));
			connect(ui->frame, SIGNAL(sendMousePosition(QPoint&)), this, SLOT(showMousePosition(QPoint&)));
			
			cellSize = ui->spinGridSize->value();
			ui->lblHover->setText("Hover: X: 0, Y: 0");
			ui->lblInfo->setText("Click to add vertices. Close polygon to freeze 'original'.");
			updateOriginalUiState();
			
			qApp->installEventFilter(this);
			nudgeTimer = new QTimer(this);
			nudgeTimer->setSingleShot(false);
			nudgeTimer->setInterval(80);
			connect(nudgeTimer, &QTimer::timeout, this, &MainWindow::performNudge);
		}
		
		MainWindow::~MainWindow()
		{
			delete ui;
		}
		
		bool MainWindow::eventFilter(QObject* obj, QEvent* event)
		{
			Q_UNUSED(obj);
			if (event->type() == QEvent::KeyPress) {
				auto* e = static_cast<QKeyEvent*>(event);
				if (e->isAutoRepeat()) return true;
				const int k = e->key();
				if (k==Qt::Key_W || k==Qt::Key_A || k==Qt::Key_S || k==Qt::Key_D) {
					pressedKeys.insert(k);
					scheduleNudge();
					return true;
				}
			} else if (event->type() == QEvent::KeyRelease) {
				auto* e = static_cast<QKeyEvent*>(event);
				if (e->isAutoRepeat()) return true;
				const int k = e->key();
				if (k==Qt::Key_W || k==Qt::Key_A || k==Qt::Key_S || k==Qt::Key_D) {
					pressedKeys.remove(k);
					if (pressedKeys.isEmpty())
					nudgeTimer->stop();
					return true;
				}
			}
			return false;
		}
		
		void MainWindow::scheduleNudge()
		{
			performNudge();
			if (!nudgeTimer->isActive())
			nudgeTimer->start();
		}
		
		void MainWindow::performNudge()
		{
			const int dx = (pressedKeys.contains(Qt::Key_D) ? 1 : 0)
			- (pressedKeys.contains(Qt::Key_A) ? 1 : 0);
			const int dy = (pressedKeys.contains(Qt::Key_W) ? 1 : 0)
			- (pressedKeys.contains(Qt::Key_S) ? 1 : 0);
			
			if (dx == 0 && dy == 0) {
				return;
			}
			translateByCells(dx, dy);
		}
		
		void MainWindow::showMousePosition(QPoint &pos)
		{
			scrX = pos.x();
			scrY = pos.y();
			if (!gridDrawn || cellSize <= 0) {
				ui->lblHover->setText("Hover: X: --, Y: --");
				return;
			}
			QPoint g = screenPxToGridXY(scrX, scrY);
			ui->lblHover->setText(QString("Hover: X: %1, Y: %2").arg(g.x()).arg(g.y()));
		}
		
		void MainWindow::Mouse_Pressed()
		{
			if (!gridDrawn) repaintFreshGrid();
			
			QPoint g = screenPxToGridXY(scrX, scrY);
			
			if (hasValid(lastPick)) prevPick = lastPick;
			lastPick = g;
			
			if (!polygonClosed) {
				polygon.push_back(g);
				ui->lblInfo->setText(QString("Vertices: %1 | Last pick: (%2,%3)")
				.arg(polygon.size()).arg(g.x()).arg(g.y()));
			} else {
				ui->lblInfo->setText(QString("Last pick: (%1,%2)").arg(g.x()).arg(g.y()));
			}
			
			fillPickedCellPx(scrX, scrY);
		}
		
		void MainWindow::on_btnDrawGrid_clicked()
		{
			repaintFreshGrid();
			polygon.clear();
			originalPolygon.clear();
			hasOriginal   = false;
			polygonClosed = false;
			
			lastPick = prevPick = QPoint(INT_MIN, INT_MIN);
			hasDrawnLine = false;
			
			updateOriginalUiState();
			ui->lblInfo->setText("Grid ready. Click to add vertices.");
		}
		
		void MainWindow::on_spinGridSize_valueChanged(int value)
		{
			if (value < 5) return;
			cellSize = value;
			refreshScene();
		}
		
		void MainWindow::on_btnClear_clicked()
		{
			polygon.clear();
			originalPolygon.clear();
			hasOriginal   = false;
			polygonClosed = false;
			
			lastPick = prevPick = QPoint(INT_MIN, INT_MIN);
			hasDrawnLine = false;
			
			refreshScene();
			updateOriginalUiState();
			ui->lblInfo->setText("Cleared. Click to add vertices.");
		}
		
		void MainWindow::repaintFreshGrid()
		{
			QPixmap pm(ui->frame->width(), ui->frame->height());
			pm.fill(bgColor);
			
			gridCols = qMax(1, pm.width()  / cellSize);
			gridRows = qMax(1, pm.height() / cellSize);
			centerX  = gridCols / 2;
			centerY  = gridRows / 2;
			
			QPainter p(&pm);
			p.setRenderHint(QPainter::Antialiasing, false);
			
			QPen gridPen(gridColor);
			gridPen.setWidth(1);
			p.setPen(gridPen);
			for (int c = 0; c <= gridCols; ++c)
			p.drawLine(c * cellSize, 0, c * cellSize, gridRows * cellSize);
			for (int r = 0; r <= gridRows; ++r)
			p.drawLine(0, r * cellSize, gridCols * cellSize, r * cellSize);
			
			drawAxes(p);
			
			p.end();
			ui->frame->setPixmap(pm);
			gridDrawn = true;
		}
		
		void MainWindow::drawAxes(QPainter& p)
		{
			p.setPen(Qt::NoPen);
			p.setBrush(axisColor);
			for (int r = 0; r < gridRows; ++r)
			p.fillRect(QRect(centerX * cellSize, r * cellSize, cellSize, cellSize), axisColor);
			for (int c = 0; c < gridCols; ++c)
			p.fillRect(QRect(c * cellSize, centerY * cellSize, cellSize, cellSize), axisColor);
		}
		
		void MainWindow::refreshScene()
		{
			repaintFreshGrid();
			
			QPixmap pm = ui->frame->pixmap();
			if (pm.isNull()) return;
			
			QPainter p(&pm);
			p.setRenderHint(QPainter::Antialiasing, false);
			
			drawHelperLine(p);
			drawPolygon(p);
			
			p.end();
			ui->frame->setPixmap(pm);
		}
		
		void MainWindow::fillPickedCellPx(int px, int py)
		{
			QPixmap pm = ui->frame->pixmap();
			if (pm.isNull() || cellSize <= 0) return;
			QPainter painter(&pm);
			painter.setRenderHint(QPainter::Antialiasing, false);
			painter.setPen(Qt::NoPen);
			
			const int cx = (px / cellSize) * cellSize;
			const int cy = (py / cellSize) * cellSize;
			painter.fillRect(QRect(cx, cy, cellSize, cellSize), pickFill);
			painter.end();
			ui->frame->setPixmap(pm);
		}
		
		QPoint MainWindow::screenPxToGridXY(int px, int py) const
		{
			const int gx = px / cellSize;
			const int gy = py / cellSize;
			const int X  = gx - centerX;
			const int Y  = -(gy - centerY);
			return QPoint(X, Y);
		}
		
		QPoint MainWindow::gridXYToCellTL(int X, int Y) const
		{
			const int gx = X + centerX;
			const int gy = centerY - Y;
			return QPoint(gx * cellSize, gy * cellSize);
		}
		
		inline void MainWindow::fillCellGrid(int gx, int gy, QPainter& p)
		{
			if (gx >= 0 && gx < gridCols && gy >= 0 && gy < gridRows)
			p.fillRect(QRect(gx * cellSize, gy * cellSize, cellSize, cellSize), p.brush());
		}
		
		void MainWindow::rasterBresenham(int X1, int Y1, int X2, int Y2, QVector<QPoint>& out)
		{
			out.clear();
			int gx1 = X1 + centerX;
			int gy1 = centerY - Y1;
			int gx2 = X2 + centerX;
			int gy2 = centerY - Y2;
			
			int dx = std::abs(gx2 - gx1);
			int dy = std::abs(gy2 - gy1);
			int sx = (gx1 < gx2) ? 1 : -1;
			int sy = (gy1 < gy2) ? 1 : -1;
			int err = dx - dy;
			
			while (true) {
				out.push_back(QPoint(gx1, gy1));
				if (gx1 == gx2 && gy1 == gy2) break;
				int e2 = 2 * err;
				if (e2 > -dy) { err -= dy; gx1 += sx; }
				if (e2 <  dx) { err += dx; gy1 += sy; }
			}
		}
		
		void MainWindow::drawPoly(const QVector<QPoint>& poly, QPainter& p, const QColor& color)
		{
			if (poly.isEmpty()) return;
			p.setPen(Qt::NoPen);
			p.setBrush(color);
			
			for (const QPoint& v : poly) {
				const int gx = v.x() + centerX;
				const int gy = centerY - v.y();
				fillCellGrid(gx, gy, p);
			}
			
			QVector<QPoint> cells;
			for (int i = 0; i + 1 < poly.size(); ++i) {
				rasterBresenham(poly[i].x(), poly[i].y(),
				poly[i+1].x(), poly[i+1].y(), cells);
				for (const QPoint& c : cells)
				fillCellGrid(c.x(), c.y(), p);
			}
		}
		
		void MainWindow::drawHelperLine(QPainter& p)
		{
			if (!hasDrawnLine) return;
			p.setPen(Qt::NoPen);
			p.setBrush(lineColor);
			
			QVector<QPoint> cells;
			rasterBresenham(lineP1.x(), lineP1.y(), lineP2.x(), lineP2.y(), cells);
			for (const QPoint& c : cells)
			fillCellGrid(c.x(), c.y(), p);
		}
		
		void MainWindow::drawPolygon(QPainter& p)
		{
			if (hasOriginal)
			drawPoly(originalPolygon, p, origColor);
			drawPoly(polygon, p, polyColor);
		}
		
		void MainWindow::on_btnClosePolygon_clicked()
		{
			if (polygon.size() >= 3 && polygon.front() != polygon.back())
			polygon.push_back(polygon.front());
			
			if (!hasOriginal && polygon.size() >= 4) {
				originalPolygon = polygon;
				hasOriginal     = true;
				polygonClosed   = true;
				ui->lblInfo->setText("Original frozen. You can transform the working polygon.");
				updateOriginalUiState();
			} else {
				polygonClosed = true;
			}
			refreshScene();
		}
		
		void MainWindow::on_btnRevertOriginal_clicked()
		{
			if (!hasOriginal) return;
			polygon       = originalPolygon;
			polygonClosed = true;
			
			hasDrawnLine = false;
			
			refreshScene();
			ui->lblInfo->setText("Reverted to original polygon.");
		}
		
		void MainWindow::updateOriginalUiState()
		{
			ui->btnRevertOriginal->setEnabled(hasOriginal);
		}
		
		QPointF MainWindow::firstVertexPivot() const
		{
			if (!originalPolygon.isEmpty())
			return QPointF(originalPolygon.front());
			if (!polygon.isEmpty())
			return QPointF(polygon.front());
			return QPointF(0,0);
		}
		
		QPointF MainWindow::polygonCentroid(const QVector<QPoint>& poly) const
		{
			const int m = poly.size();
			if (m == 0) return QPointF(0,0);
			
			int n = m;
			if (n > 1 && poly.front() == poly.back()) --n;
			
			double A = 0.0, Cx = 0.0, Cy = 0.0;
			for (int i = 0; i < n; ++i) {
				const QPoint& p0 = poly[i];
				const QPoint& p1 = poly[(i + 1) % n];
				const double cross = double(p0.x()) * p1.y() - double(p1.x()) * p0.y();
				A  += cross;
				Cx += (p0.x() + p1.x()) * cross;
				Cy += (p0.y() + p1.y()) * cross;
			}
			
			if (qAbs(A) > 1e-9) {
				A *= 0.5;
				Cx /= (6.0 * A);
				Cy /= (6.0 * A);
				return QPointF(Cx, Cy);
			}
			
			int minx = poly[0].x(), maxx = poly[0].x();
			int miny = poly[0].y(), maxy = poly[0].y();
			for (int i = 1; i < n; ++i) {
				minx = qMin(minx, poly[i].x());
				maxx = qMax(maxx, poly[i].x());
				miny = qMin(miny, poly[i].y());
				maxy = qMax(maxy, poly[i].y());
			}
			return QPointF(0.5 * (minx + maxx), 0.5 * (miny + maxy));
		}
		
		QPointF MainWindow::currentPivot() const
		{
			if (!polygon.isEmpty())         return polygonCentroid(polygon);
			if (!originalPolygon.isEmpty()) return polygonCentroid(originalPolygon);
			return QPointF(0,0);
		}
		
		double MainWindow::effectiveScale(double s) const
		{
			if (s < 0.0) return 1.0 / (1.0 + (-s));
			return s;
		}
		
		void MainWindow::applyTransform(const QTransform& T)
		{
			if (polygon.isEmpty()) return;
			
			QVector<QPoint> out;
			out.reserve(polygon.size());
			
			for (const QPoint& v : polygon) {
				QPointF r = T.map(QPointF(v.x(), v.y()));
				out.push_back(QPoint(qRound(r.x()), qRound(r.y())));
			}
			polygon = out;
			refreshScene();
		}
		
		void MainWindow::on_btnTranslate_clicked()
		{
			QTransform T;
			T.translate(ui->spinTx->value(), ui->spinTy->value());
			applyTransform(T);
		}
		
		void MainWindow::on_btnRotate_clicked()
		{
			QTransform T;
			T.rotate(-ui->spinAngle->value());
			applyTransform(T);
		}
		
		void MainWindow::on_btnRotateAboutPoint_clicked()
		{
			if (!hasValid(lastPick)) {
				ui->lblInfo->setText("Pick a pivot on the grid (click) and try again.");
				return;
			}
			const double deg = -ui->spinAngle->value();
			
			QTransform T;
			T.translate(lastPick.x(), lastPick.y());
			T.rotate(deg);
			T.translate(-lastPick.x(), -lastPick.y());
			applyTransform(T);
			
			ui->lblInfo->setText(QString("Rotated about (%1,%2)").arg(lastPick.x()).arg(lastPick.y()));
		}
		
		void MainWindow::on_btnScale_clicked()
		{
			const QPointF c  = currentPivot();
			const double sxI = ui->spinSx->value();
			const double syI = ui->spinSy->value();
			const double sx  = effectiveScale(sxI);
			const double sy  = effectiveScale(syI);
			
			QTransform T;
			T.translate(c.x(), c.y());
			T.scale(sx, sy);
			T.translate(-c.x(), -c.y());
			applyTransform(T);
			
			ui->lblInfo->setText(
			QString("Scaled about centroid (%1,%2) | input(Sx,Sy)=(%3,%4) -> effective=(%5,%6)")
			.arg(c.x()).arg(c.y())
			.arg(sxI,0,'g',4).arg(syI,0,'g',4)
			.arg(sx,0,'g',4).arg(sy,0,'g',4));
		}
		
		void MainWindow::on_btnShear_clicked()
		{
			const QPointF c  = currentPivot();
			const double shx = ui->spinShx->value();
			const double shy = ui->spinShy->value();
			
			QTransform T;
			T.translate(c.x(), c.y());
			T.shear(shx, shy);
			T.translate(-c.x(), -c.y());
			applyTransform(T);
			
			ui->lblInfo->setText(QString("Sheared about centroid (%1,%2)").arg(c.x()).arg(c.y()));
		}
		
		void MainWindow::on_btnReflectX_clicked()
		{
			QTransform T(1, 0, 0, -1, 0, 0);
			applyTransform(T);
		}
		
		void MainWindow::on_btnReflectY_clicked()
		{
			QTransform T(-1, 0, 0, 1, 0, 0);
			applyTransform(T);
		}
		
		QPointF MainWindow::reflectPointAboutLine(const QPointF& v,
		const QPointF& a,
		const QPointF& b) const
		{
			double ux = b.x() - a.x();
			double uy = b.y() - a.y();
			const double len2 = ux*ux + uy*uy;
			if (len2 < 1e-12) return v;
			
			const double invLen = 1.0 / std::sqrt(len2);
			ux *= invLen;  uy *= invLen;
			
			const double r11 = 2.0*ux*ux - 1.0;
			const double r12 = 2.0*ux*uy;
			const double r21 = r12;
			const double r22 = 2.0*uy*uy - 1.0;
			
			const double wx = v.x() - a.x();
			const double wy = v.y() - a.y();
			
			const double rx = r11*wx + r12*wy;
			const double ry = r21*wx + r22*wy;
			
			return QPointF(a.x() + rx, a.y() + ry);
		}
		
		bool MainWindow::reflectSpecialIfSlopePM1(const QPoint& a, const QPoint& b,
		QVector<QPoint>& out) const
		{
			const int dx = b.x() - a.x();
			const int dy = b.y() - a.y();
			if (dx == 0 && dy == 0) return false;
			
			if (dy == dx) {
				const int k = a.y() - a.x();
				out.clear(); out.reserve(polygon.size());
				for (const QPoint& v : polygon) {
					const int xp = v.y() - k;
					const int yp = v.x() + k;
					out.push_back(QPoint(xp, yp));
				}
				return true;
			}
			
			if (dy == -dx) {
				const int k = a.y() + a.x();
				out.clear(); out.reserve(polygon.size());
				for (const QPoint& v : polygon) {
					const int xp = -v.y() + k;
					const int yp = -v.x() + k;
					out.push_back(QPoint(xp, yp));
				}
				return true;
			}
			
			return false;
		}
		
		void MainWindow::on_btnDrawLine_clicked()
		{
			if (!hasValid(prevPick) || !hasValid(lastPick)) {
				ui->lblInfo->setText("Select two points (click twice) to define the line.");
				return;
			}
			lineP1 = prevPick;
			lineP2 = lastPick;
			hasDrawnLine = true;
			refreshScene();
			ui->lblInfo->setText(QString("Helper line set: (%1,%2) -> (%3,%4)")
			.arg(lineP1.x()).arg(lineP1.y())
			.arg(lineP2.x()).arg(lineP2.y()));
		}
		
		void MainWindow::on_btnReflectDrawnLine_clicked()
		{
			if (!hasDrawnLine) {
				ui->lblInfo->setText("No helper line. Click two points and press 'Draw Line' first.");
				return;
			}
			
			const QPoint a = lineP1;
			const QPoint b = lineP2;
			
			QVector<QPoint> out;
			
			if (reflectSpecialIfSlopePM1(a, b, out)) {
				polygon = out;
				refreshScene();
				ui->lblInfo->setText("Reflected about line with slope +/-1 (exact swap).");
				return;
			}
			
			out.clear(); out.reserve(polygon.size());
			for (const QPoint& v : polygon) {
				const QPointF r = reflectPointAboutLine(QPointF(v), QPointF(a), QPointF(b));
				out.push_back(QPoint(qRound(r.x()), qRound(r.y())));
			}
			polygon = out;
			refreshScene();
		}
		
		QTransform MainWindow::reflectAboutTwoPointLine(const QPointF& p1, const QPointF& p2)
		{
			const double dx = p2.x() - p1.x();
			const double dy = p2.y() - p1.y();
			const double len2 = dx*dx + dy*dy;
			if (len2 < 1e-9) return QTransform();
			
			const double thetaRad = std::atan2(dy, dx);
			
			QTransform A; A.translate(-p1.x(), -p1.y());
			QTransform B; B.rotateRadians(-thetaRad);
			QTransform C(1, 0, 0, -1, 0, 0);
			QTransform D; D.rotateRadians(thetaRad);
			QTransform E; E.translate(p1.x(), p1.y());
			return E * D * C * B * A;
		}
		
		void MainWindow::translateByCells(int dx, int dy)
		{
			if (polygon.isEmpty()) return;
			QTransform T;
			T.translate(dx, dy);
			applyTransform(T);
			ui->lblInfo->setText(QString("Nudged by (%1, %2)").arg(dx).arg(dy));
		}
		
		void MainWindow::nudgeUp()    { translateByCells(0, +1); }
		void MainWindow::nudgeLeft()  { translateByCells(-1, 0); }
		void MainWindow::nudgeDown()  { translateByCells(0, -1); }
		void MainWindow::nudgeRight() { translateByCells(+1, 0); }
	\end{lstlisting}
	
	my\_label.cpp
	\begin{lstlisting}[style=cgstyle, language=C++]
		#include "my_label.h"
		
		my_label::my_label(QWidget *parent) : QLabel(parent)
		{
			setMouseTracking(true);
		}
		
		void my_label::mouseMoveEvent(QMouseEvent *ev)
		{
			#if QT_VERSION >= QT_VERSION_CHECK(6,0,0)
			QPointF pf = ev->position();
			QPoint p = pf.toPoint();
			#else
			QPoint p = ev->pos();
			#endif
			if (p.x() >= 0 && p.y() >= 0 && p.x() < width() && p.y() < height()) {
				emit sendMousePosition(p);
			}
		}
		
		void my_label::mousePressEvent(QMouseEvent *ev)
		{
			if (ev->button() == Qt::LeftButton) {
				#if QT_VERSION >= QT_VERSION_CHECK(6,0,0)
				QPoint p = ev->position().toPoint();
				#else
				QPoint p = ev->pos();
				#endif
				lastX = p.x();
				lastY = p.y();
				emit Mouse_Pos();
			}
		}
	\end{lstlisting}
	
	\clearpage
	\subsubsection*{Outputs}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_original_polygon}
		\caption{transformation\_original\_polygon}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_translation}
		\caption{transformation\_translation}
	\end{figure}
	
	\vspace{-20pt}
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_rotate_about_origin}
		\caption{transformation\_rotate\_about\_origin}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_rotate_about_a_point_before_rotation}
		\caption{transformation\_rotate\_about\_a\_point\_before\_rotation}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_rotate_about_a_point_after_rotation}
		\caption{transformation\_rotate\_about\_a\_point\_after\_rotation}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_scaling_increased}
		\caption{transformation\_scaling\_increased}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_scaling_decreased}
		\caption{transformation\_scaling\_decreased}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_shearing}
		\caption{transformation\_shearing}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_reflect_about_x_axis}
		\caption{transformation\_reflect\_about\_x\_axis}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_reflect_about_y_axis}
		\caption{transformation\_reflect\_about\_y\_axis}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\textwidth]{images/transformation_reflect_about_a_line}
		\caption{transformation\_reflect\_about\_a\_line}
	\end{figure}
	
	\clearpage
    \subsubsection*{Output Explanation}

For demonstrating the transformation functions, I used a simple rectangle as the base polygon.  
First I drew the original rectangle and then applied translation, rotation, scaling, shear, and reflections about the \(x\)- and \(y\)-axes, as well as rotation about an arbitrary picked point and reflection about a user–defined line. In each case, the transformed rectangle appeared exactly where predicted by the corresponding homogeneous transformation matrix (shifts for translation, correct angle and orientation for rotations, proportional changes for scaling, slanting for shear, and mirroring for reflections).  
Overall, the visual outputs closely matched the theoretical behaviour expected from the 2D transformation equations derived in this assignment.

	\clearpage
    
	% -------- ASSIGNMENT 6 --------
	\subsection*{Assignment 6: Line and Polygon Clipping}
	\addcontentsline{toc}{subsection}{Assignment 6: Line and Polygon Clipping}
	
	\subsubsection*{Problem Statement}
	\begin{enumerate}
		\item Implement line clipping with respect to a rectangular clip window using:
		\begin{itemize}
			\item Cohen--Sutherland algorithm
			\item Liang--Barsky algorithm (optional)
		\end{itemize}
		\item Implement polygon clipping with respect to a rectangular clip window using:
		\begin{itemize}
			\item Sutherland--Hodgeman algorithm
			\item Weiler--Atherton algorithm (optional)
		\end{itemize}
	\end{enumerate}
	
	
	\subsubsection*{Code and Theoretical Explanation: Line Clipping}

In this assignment I implemented interactive line clipping against an axis-aligned rectangular window using both Cohen--Sutherland and Liang--Barsky algorithms on a discrete grid.

\paragraph*{Interactive grid and data structures}
The common infrastructure is provided by \texttt{GridScene} and \texttt{GridView}. The scene maintains a hash from integer grid coordinates to filled cells:
\begin{itemize}
  \item \texttt{GridScene::paintCell(const QPoint\& cell, const QBrush\& brush)} draws a filled square of side \texttt{cellSize} at integer coordinates \((x,y)\). This visually represents pixels on the conceptual Cartesian grid.
  \item \texttt{GridScene::drawBackground} draws the infinite grid and the coordinate axes, so that all clipping is done in integer grid space.
\end{itemize}
In the main window, the user selects two grid cells as endpoints of the line segment, which are stored in \texttt{linePoints}. The clipping window is defined by two opposite grid cells and stored as a \texttt{QRect clippingWindow}. The original line is rasterised using integer Bresenham:
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::bresenhamLine(const QPoint& p1, const QPoint& p2,
                               const QBrush& brush)
{
    int x1 = p1.x(), y1 = p1.y(), x2 = p2.x(), y2 = p2.y();
    int dx = abs(x2 - x1), dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy;
    while (true) {
        scene->paintCell(QPoint(x1, y1), brush);
        if (x1 == x2 && y1 == y2) break;
        int e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x1 += sx; }
        if (e2 <  dx) { err += dx; y1 += sy; }
    }
}
\end{lstlisting}
After clipping, \texttt{drawPartialLine} recolours each pixel of the line as ``inside'' or ``outside'' the window, so that the clipped segment appears in green and the discarded part in gray:
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::drawPartialLine(const QPoint& p1, const QPoint& p2,
                                 const QRect& window,
                                 const QBrush& insideBrush,
                                 const QBrush& outsideBrush,
                                 bool /*useCohenSutherland*/)
{
    int x1 = p1.x(), y1 = p1.y(), x2 = p2.x(), y2 = p2.y();
    int dx = abs(x2 - x1), dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy;
    while (true) {
        QPoint cell(x1, y1);
        if (isPointInsideWindow(cell, window))
            scene->paintCell(cell, insideBrush);
        else
            scene->paintCell(cell, outsideBrush);
        if (x1 == x2 && y1 == y2) break;
        int e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x1 += sx; }
        if (e2 <  dx) { err += dx; y1 += sy; }
    }
}
\end{lstlisting}
The actual clipping is performed in floating-point using the analytic algorithms below; the Bresenham loop is only for visualisation.

\paragraph*{Cohen--Sutherland line clipping}
I consider an axis-aligned clipping window with boundaries
\[
x_{\min},\; x_{\max},\; y_{\min},\; y_{\max}.
\]
Each endpoint \((x,y)\) is assigned a 4-bit region code based on its position relative to the window:
\[
\text{code} =
\begin{cases}
\text{bit LEFT}   = 1, & x < x_{\min},\\
\text{bit RIGHT}  = 1, & x > x_{\max},\\
\text{bit BOTTOM} = 1, & y < y_{\min},\\
\text{bit TOP}    = 1, & y > y_{\max}.
\end{cases}
\]
Points inside the window have code \(0000\). This logic is implemented in
\begin{lstlisting}[style=cgstyle,language=C++]
int MainWindow::computeOutCode(double x, double y, const QRect& rect)
{
    int code = INSIDE;
    if (x < rect.left())      code |= LEFT;
    else if (x > rect.right()) code |= RIGHT;
    if (y < rect.top())       code |= BOTTOM;
    else if (y > rect.bottom()) code |= TOP;
    return code;
}
\end{lstlisting}

Given a line segment from \(P_1(x_1,y_1)\) to \(P_2(x_2,y_2)\) with outcodes
\(\text{code}_1, \text{code}_2\), the algorithm iteratively applies three tests:
\begin{enumerate}
  \item \emph{Trivial acceptance:} if \(\text{code}_1 \,\vert\, \text{code}_2 = 0\), both endpoints are inside and the line is fully visible.
  \item \emph{Trivial rejection:} if \(\text{code}_1 \,\&\, \text{code}_2 \neq 0\), the line lies entirely in a common outside region and is fully invisible.
  \item \emph{Subdivision:} otherwise, exactly one endpoint is outside. I choose that endpoint and compute the intersection of the infinite line with the appropriate window boundary. I replace the outside endpoint with this intersection and recompute its outcode. The process repeats until case~(1) or~(2) holds.
\end{enumerate}
In parametric form,
\[
x(t) = x_1 + t(x_2 - x_1), \quad
y(t) = y_1 + t(y_2 - y_1), \quad t \in [0,1].
\]
For each boundary, the intersection parameter is obtained by solving a single linear equation:
\begin{align*}
\text{Top edge }(y = y_{\max})\;&\Rightarrow\;
  t = \dfrac{y_{\max} - y_1}{y_2 - y_1},\;
  x = x_1 + t(x_2 - x_1),\\[3pt]
\text{Bottom edge }(y = y_{\min})\;&\Rightarrow\;
  t = \dfrac{y_{\min} - y_1}{y_2 - y_1},\;
  x = x_1 + t(x_2 - x_1),\\[3pt]
\text{Right edge }(x = x_{\max})\;&\Rightarrow\;
  t = \dfrac{x_{\max} - x_1}{x_2 - x_1},\;
  y = y_1 + t(y_2 - y_1),\\[3pt]
\text{Left edge }(x = x_{\min})\;&\Rightarrow\;
  t = \dfrac{x_{\min} - x_1}{x_2 - x_1},\;
  y = y_1 + t(y_2 - y_1).
\end{align*}
The implementation follows this decision logic:
\begin{lstlisting}[style=cgstyle,language=C++]
bool MainWindow::cohenSutherlandClip(double& x1, double& y1,
                                     double& x2, double& y2,
                                     const QRect& rect)
{
    int outcode1 = computeOutCode(x1, y1, rect);
    int outcode2 = computeOutCode(x2, y2, rect);
    bool accept = false;
    while (true) {
        if (!(outcode1 | outcode2)) { accept = true; break; }
        else if (outcode1 & outcode2) break;
        else {
            int outcodeOut = outcode1 ? outcode1 : outcode2;
            double x, y;
            if (outcodeOut & TOP) {
                x = x1 + (x2 - x1) *
                        (rect.bottom() - y1) / (y2 - y1);
                y = rect.bottom();
            }
            else if (outcodeOut & BOTTOM) {
                x = x1 + (x2 - x1) *
                        (rect.top() - y1) / (y2 - y1);
                y = rect.top();
            }
            else if (outcodeOut & RIGHT) {
                y = y1 + (y2 - y1) *
                        (rect.right() - x1) / (x2 - x1);
                x = rect.right();
            }
            else if (outcodeOut & LEFT) {
                y = y1 + (y2 - y1) *
                        (rect.left() - x1) / (x2 - x1);
                x = rect.left();
            }
            if (outcodeOut == outcode1) {
                x1 = x; y1 = y;
                outcode1 = computeOutCode(x1, y1, rect);
            } else {
                x2 = x; y2 = y;
                outcode2 = computeOutCode(x2, y2, rect);
            }
        }
    }
    return accept;
}
\end{lstlisting}
The GUI slot \texttt{onClipLineCohenSutherland()} checks that both the line and window exist, repaints the window and then calls \texttt{drawPartialLine} so the user can see which portion of the Bresenham raster falls inside the accepted segment.

\paragraph*{Liang--Barsky line clipping}
Liang--Barsky uses the same parametric line representation, but instead of region codes it maintains a range of valid parameters \(t \in [t_0, t_1]\) that satisfy all four window inequalities simultaneously.

The clipping window is described by
\[
x_{\min} \le x(t) \le x_{\max}, \qquad
y_{\min} \le y(t) \le y_{\max}.
\]
Substituting \(x(t) = x_1 + t\Delta x\) and \(y(t) = y_1 + t\Delta y\), where
\(\Delta x = x_2 - x_1\), \(\Delta y = y_2 - y_1\), we get four linear inequalities:
\begin{align*}
x_{\min} &\le x_1 + t\Delta x \quad\Rightarrow\quad
  (\,-\Delta x\,) t \le x_1 - x_{\min},\\[2pt]
x_1 + t\Delta x &\le x_{\max} \quad\Rightarrow\quad
  (\;\;\Delta x\,) t \le x_{\max} - x_1,\\[2pt]
y_{\min} &\le y_1 + t\Delta y \quad\Rightarrow\quad
  (\,-\Delta y\,) t \le y_1 - y_{\min},\\[2pt]
y_1 + t\Delta y &\le y_{\max} \quad\Rightarrow\quad
  (\;\;\Delta y\,) t \le y_{\max} - y_1.
\end{align*}
In the compact form
\[
p_i t \le q_i,\quad i=0,\dots,3,
\]
where the implementation uses
\begin{lstlisting}[style=cgstyle,language=C++]
double dx = x2 - x1, dy = y2 - y1;
double p[4] = { -dx,  dx, -dy,  dy };
double q[4] = { x1 - xmin,  xmax - x1,
                y1 - ymin,  ymax - y1 };
\end{lstlisting}
For each constraint:
\begin{itemize}
  \item If \(p_i = 0\) and \(q_i < 0\), the line is parallel to the corresponding boundary and entirely outside; the segment is rejected.
  \item If \(p_i < 0\), the inequality tightens the lower bound:
  \[
    t_{\text{enter}} = \max\bigl(t_{\text{enter}},\, q_i / p_i\bigr).
  \]
  \item If \(p_i > 0\), the inequality tightens the upper bound:
  \[
    t_{\text{leave}} = \min\bigl(t_{\text{leave}},\, q_i / p_i\bigr).
  \]
\end{itemize}
Initially \(t_0 = 0\) and \(t_1 = 1\). If at any time \(t_0 > t_1\), the feasible interval is empty and the line is rejected. Otherwise, after all four constraints are processed, the clipped segment is simply
\[
P'(t_0) = (x_1 + t_0\Delta x,\; y_1 + t_0\Delta y), \quad
P'(t_1) = (x_1 + t_1\Delta x,\; y_1 + t_1\Delta y).
\]
This logic is exactly reflected in the code:
\begin{lstlisting}[style=cgstyle,language=C++]
bool MainWindow::liangBarskyClip(double& x1, double& y1,
                                 double& x2, double& y2,
                                 const QRect& rect)
{
    double xmin = rect.left(),  xmax = rect.right();
    double ymin = rect.top(),   ymax = rect.bottom();
    double dx = x2 - x1, dy = y2 - y1;
    double t0 = 0.0, t1 = 1.0;
    double p[4] = { -dx, dx, -dy, dy };
    double q[4] = { x1 - xmin, xmax - x1,
                    y1 - ymin, ymax - y1 };

    for (int i = 0; i < 4; i++) {
        if (p[i] == 0 && q[i] < 0) return false;
        double t = q[i] / p[i];
        if (p[i] < 0)      t0 = std::max(t0, t);
        else if (p[i] > 0) t1 = std::min(t1, t);
        if (t0 > t1) return false;
    }

    if (t0 > 0) { x1 += t0 * dx; y1 += t0 * dy; }
    if (t1 < 1) { x2 -= (1 - t1) * dx; y2 -= (1 - t1) * dy; }
    return true;
}
\end{lstlisting}
The slot \texttt{onClipLineLiangBarsky()} reuses the same GUI flow as Cohen--Sutherland, but the underlying slope-based clipping is now done using this parametric interval computation.


%------------------------------------------------------------

\subsubsection*{Code and Theoretical Explanation: Polygon Clipping}

For polygon clipping I implemented both Sutherland--Hodgeman and Weiler--Atherton algorithms against the same axis-aligned rectangular window, again on the integer grid.

\paragraph*{Polygon representation and drawing}
The interactive polygon is defined by a sequence of grid vertices \texttt{polygonVertices} (a \texttt{QList<QPoint>}). When the user finishes vertex selection and presses ``Draw Polygon'', the outline is rasterised by joining each pair of consecutive vertices (and finally the last to the first) using the same Bresenham routine:
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::drawPolygonOutline(const QList<QPoint>& vertices,
                                    const QBrush& brush, bool collect)
{
    if (vertices.size() < 2) return;
    for (const QPoint& v : vertices) {
        scene->paintCell(v, brush);
        if (collect) polygonPixels.insert(v);
    }
    for (int i = 0; i < vertices.size(); i++) {
        int nextIndex = (i + 1) % vertices.size();
        bresenhamLine(vertices[i], vertices[nextIndex], brush, collect);
    }
}
\end{lstlisting}
The optional \texttt{collect} flag stores all edge pixels in a set \texttt{polygonPixels}, which lets me later recolour only those pixels that fall inside the clipping window. The window itself is again defined as a \texttt{QRect clippingWindow}.

\paragraph*{Sutherland--Hodgeman polygon clipping}
Sutherland--Hodgeman clips a polygon by successively clipping it against each boundary of the window. The input polygon is described by a cyclic list of vertices \(V = \{v_0, v_1, \dots, v_{n-1}\}\). For each window edge, the algorithm walks along the polygon edges and constructs a new list according to inside/outside transitions.

For each edge of the clip window, I define a half-plane test:
\[
\text{inside}(P) =
\begin{cases}
x \ge x_{\min}, & \text{for left boundary},\\
x \le x_{\max}, & \text{for right boundary},\\
y \ge y_{\min}, & \text{for bottom boundary},\\
y \le y_{\max}, & \text{for top boundary}.
\end{cases}
\]
The code uses an enum \texttt{EdgePosition} and a single \texttt{isInside} routine:
\begin{lstlisting}[style=cgstyle,language=C++]
bool MainWindow::isInside(const QPointF& point,
                          EdgePosition edge,
                          const QRect& clipRect)
{
    switch (edge) {
    case LEFT_EDGE:   return point.x() >= clipRect.left();
    case RIGHT_EDGE:  return point.x() <= clipRect.right();
    case BOTTOM_EDGE: return point.y() >= clipRect.top();
    case TOP_EDGE:    return point.y() <= clipRect.bottom();
    }
    return false;
}
\end{lstlisting}
Given an input vertex list \(V\) and a single clip edge, the \emph{clip-against-edge} step considers each pair \((S,P)\) of consecutive vertices (previous and current) and applies four cases:
\begin{itemize}
  \item \(S\) inside, \(P\) inside: append \(P\).
  \item \(S\) inside, \(P\) outside: append the intersection point \(I\) of segment \(SP\) with the boundary.
  \item \(S\) outside, \(P\) inside: append the intersection point \(I\), then append \(P\).
  \item \(S\) outside, \(P\) outside: append nothing.
\end{itemize}
This logic is implemented in \texttt{clipAgainstEdge}:
\begin{lstlisting}[style=cgstyle,language=C++]
QList<QPointF> MainWindow::clipAgainstEdge(
        const QList<QPointF>& inputVertices,
        EdgePosition edge, const QRect& clipRect)
{
    QList<QPointF> outputVertices;
    if (inputVertices.isEmpty()) return outputVertices;

    QPointF previousVertex = inputVertices.last();
    for (const QPointF& currentVertex : inputVertices) {
        bool currentInside  = isInside(currentVertex, edge, clipRect);
        bool previousInside = isInside(previousVertex, edge, clipRect);
        if (currentInside) {
            if (!previousInside) {
                QPointF inter = getIntersection(previousVertex,
                                                currentVertex,
                                                edge, clipRect);
                outputVertices.append(inter);
            }
            outputVertices.append(currentVertex);
        }
        else if (previousInside) {
            QPointF inter = getIntersection(previousVertex,
                                            currentVertex,
                                            edge, clipRect);
            outputVertices.append(inter);
        }
        previousVertex = currentVertex;
    }
    return outputVertices;
}
\end{lstlisting}
The intersection point with a given edge is obtained by solving the parametric line equation, exactly as in the line clipping case. For example, for the left boundary \(x = x_{\min}\),
\[
x_1 + t(x_2 - x_1) = x_{\min}
\;\Rightarrow\;
t = \dfrac{x_{\min} - x_1}{x_2 - x_1},\quad
y = y_1 + t(y_2 - y_1).
\]
The code handles all four boundaries:
\begin{lstlisting}[style=cgstyle,language=C++]
QPointF MainWindow::getIntersection(const QPointF& p1,
                                    const QPointF& p2,
                                    EdgePosition edge,
                                    const QRect& clipRect)
{
    double x1 = p1.x(), y1 = p1.y();
    double x2 = p2.x(), y2 = p2.y();
    double x = 0, y = 0;

    switch (edge) {
    case LEFT_EDGE:
        x = clipRect.left();
        y = (x2 != x1) ? y1 + (y2 - y1) * (x - x1) / (x2 - x1) : y1;
        y = std::max<double>(clipRect.top(),
                             std::min<double>(clipRect.bottom(),
                                              std::round(y)));
        return QPointF(x, y);
    case RIGHT_EDGE:
        x = clipRect.right();
        y = (x2 != x1) ? y1 + (y2 - y1) * (x - x1) / (x2 - x1) : y1;
        y = std::max<double>(clipRect.top(),
                             std::min<double>(clipRect.bottom(),
                                              std::round(y)));
        return QPointF(x, y);
    case BOTTOM_EDGE:
        y = clipRect.top();
        x = (y2 != y1) ? x1 + (x2 - x1) * (y - y1) / (y2 - y1) : x1;
        x = std::max<double>(clipRect.left(),
                             std::min<double>(clipRect.right(),
                                              std::round(x)));
        return QPointF(x, y);
    case TOP_EDGE:
        y = clipRect.bottom();
        x = (y2 != y1) ? x1 + (x2 - x1) * (y - y1) / (y2 - y1) : x1;
        x = std::max<double>(clipRect.left(),
                             std::min<double>(clipRect.right(),
                                              std::round(x)));
        return QPointF(x, y);
    }
    return QPointF();
}
\end{lstlisting}

The full Sutherland--Hodgeman pipeline applies this step sequentially for the four window edges:
\begin{lstlisting}[style=cgstyle,language=C++]
QList<QPointF> MainWindow::sutherlandHodgemanClip(
        const QList<QPointF>& polygon,
        const QRect& clipRect)
{
    QList<QPointF> output = polygon;
    output = clipAgainstEdge(output, LEFT_EDGE,   clipRect);
    if (output.isEmpty()) return output;
    output = clipAgainstEdge(output, RIGHT_EDGE,  clipRect);
    if (output.isEmpty()) return output;
    output = clipAgainstEdge(output, BOTTOM_EDGE, clipRect);
    if (output.isEmpty()) return output;
    output = clipAgainstEdge(output, TOP_EDGE,    clipRect);
    if (output.isEmpty()) return output;

    QList<QPointF> snapped;
    for (const QPointF& p : output) {
        QPointF q(qRound(p.x()), qRound(p.y()));
        if (snapped.isEmpty() || q != snapped.last())
            snapped.append(q);
    }
    if (snapped.size() >= 2 && snapped.first() == snapped.last())
        snapped.removeLast();
    return snapped;
}
\end{lstlisting}
The slot \texttt{onClipPolygonSutherHodge()} converts integer vertices to \texttt{QPointF}, calls \texttt{sutherlandHodgemanClip}, draws the original polygon in gray, the window in red with a semi-transparent fill, and finally rasterises the clipped polygon in green.

\paragraph*{Weiler--Atherton polygon clipping}
Sutherland--Hodgeman works well when clipping a subject polygon by a convex window, but it is not ideal when the subject is concave or when multiple disjoint output regions or holes appear. To handle such general cases, I implemented Weiler--Atherton.

Weiler--Atherton operates on two closed polygonal loops:
\begin{itemize}
  \item the \emph{subject polygon} (the user-drawn polygon),
  \item the \emph{clip polygon} (here, the rectangular window).
\end{itemize}
Both are represented as vertex lists that may be augmented with intersection vertices. I use the \texttt{VertexData} structure:
\begin{lstlisting}[style=cgstyle,language=C++]
struct VertexData {
    QPointF pos;
    bool isIntersection = false;
    bool isStartNode    = false;
    int  link           = -1;
    bool visited        = false;
};
\end{lstlisting}
The algorithm proceeds in several stages:
\begin{enumerate}
  \item \textbf{Initial lists.} I copy the subject polygon vertices into \texttt{subjectList} and the rectangular window vertices into \texttt{clipList}, both in cyclic order.
  \item \textbf{Inside test.} I check whether all subject vertices lie inside the window (\texttt{isInsideClipWindow}). If so, the entire subject polygon is visible; if there are no intersections but the window lies inside the subject, the rectangular window itself becomes the clipped region.
  \item \textbf{Intersection computation and insertion.} For every subject edge \([P_i,P_{i+1}]\) and every clip edge \([W_j,W_{j+1}]\), I compute their intersection (if any) using the analytic line intersection formula:
  \[
  P(t) = P_1 + t(P_2 - P_1),\quad
  Q(u) = Q_1 + u(Q_2 - Q_1),
  \]
  and solve for \(t,u\) such that \(P(t)=Q(u)\). This is implemented in \texttt{getIntersectionWA}, which returns the intersection point only if it lies on both segments. For each valid intersection \(I\), I record a \texttt{VertexData} node in both \texttt{subjectInserts} and \texttt{clipInserts}, marking whether it is a \emph{start node} (transition from inside to outside):
\begin{lstlisting}[style=cgstyle,language=C++]
QPointF I = getIntersectionWA(p1, p2, w1, w2);
if (!I.isNull()) {
    bool isStartNode = isInsideClipWindow(p1) &&
                       !isInsideClipWindow(p2);
    subjectInserts.append({ i + 1, { I, true,
                                     isStartNode, -1, false } });
    clipInserts.append   ({ j + 1, { I, true,
                                     isStartNode, -1, false } });
}
\end{lstlisting}
  After computing all intersections, I insert these new vertices into \texttt{subjectList} and \texttt{clipList} at the correct positions along each edge. Sorting the insertion positions in descending order ensures that indices remain valid during insertion.
  \item \textbf{Linking corresponding intersections.} Each geometric intersection appears once in the subject loop and once in the clip loop. I link the corresponding \texttt{VertexData} entries by setting their \texttt{link} fields so that traversals can jump between loops at intersection points:
\begin{lstlisting}[style=cgstyle,language=C++]
for (int i = 0; i < subjectList.size(); ++i) {
    if (!subjectList[i].isIntersection) continue;
    for (int j = 0; j < clipList.size(); ++j) {
        if (clipList[j].isIntersection &&
            subjectList[i].pos == clipList[j].pos) {
            subjectList[i].link = j;
            clipList[j].link    = i;
            break;
        }
    }
}
\end{lstlisting}
  \item \textbf{Tracing output polygons.} For each unvisited intersection in the subject list that is marked as a start node, I trace a complete output polygon by walking around the loops:
  \begin{itemize}
    \item start from the chosen subject intersection,
    \item follow vertices forward along the current loop (subject or clip), appending each \(\texttt{pos}\) to the output list and marking it visited,
    \item whenever an intersection vertex with a valid \texttt{link} is encountered, jump across to the other loop and continue,
    \item stop when I return to the starting vertex.
  \end{itemize}
  This is implemented by alternating between \texttt{subjectList} and \texttt{clipList} inside a do--while loop:
\begin{lstlisting}[style=cgstyle,language=C++]
QList<QVector<QPointF>> resultPolygons;
for (int i = 0; i < subjectList.size(); ++i) {
    if (subjectList[i].isIntersection &&
        subjectList[i].isStartNode &&
        !subjectList[i].visited) {
        QVector<QPointF> cur;
        int idx = i;
        bool onSubject = true;
        do {
            VertexData* v = onSubject ?
                            &subjectList[idx] :
                            &clipList[idx];
            v->visited = true;
            cur.append(v->pos);
            if (v->isIntersection && v->link != -1) {
                onSubject = !onSubject;
                idx = v->link;
            }
            idx = (idx + 1) %
                  (onSubject ? subjectList.size()
                             : clipList.size());
        } while (cur.first() != cur.back() ||
                 cur.size() < 2);
        cur.pop_back();
        if (cur.size() >= 3)
            resultPolygons.append(cur);
    }
}
\end{lstlisting}
  Each resulting list of points represents one clipped polygon component (there may be multiple for complex overlaps).
\end{enumerate}

Finally, I rasterise all output polygons in green:
\begin{lstlisting}[style=cgstyle,language=C++]
if (!resultPolygons.isEmpty()) {
    for (const auto& poly : resultPolygons) {
        QList<QPoint> edge;
        edge.reserve(poly.size());
        for (const QPointF& p : poly)
            edge.append(QPoint(qRound(p.x()),
                               qRound(p.y())));
        drawPolygonOutline(edge, QBrush(Qt::green));
    }
}
\end{lstlisting}
Before this, I draw the original polygon in light gray and the clip window in red with a translucent fill, so that the effect of Weiler--Atherton is visually clear.

\includegraphics[width=0.5\textwidth]{images/clip1}
\includegraphics[width=0.5\textwidth]{images/clip2}
\includegraphics[width=0.5\textwidth]{images/clip3}

	
	
	\subsubsection*{Line Clipping Code}
	line\_clipping.pro
	\begin{lstlisting}[style=cgstyle,language=C++]
		QT       += core gui
		
		greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
		
		CONFIG += c++17
		
		# You can make your code fail to compile if it uses deprecated APIs.
		# In order to do so, uncomment the following line.
		#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0
		
		SOURCES += \
		gridscene.cpp \
		gridview.cpp \
		main.cpp \
		mainwindow.cpp
		
		HEADERS += \
		gridscene.h \
		gridview.h \
		mainwindow.h
		
		FORMS += \
		mainwindow.ui
		
		# Default rules for deployment.
		qnx: target.path = /tmp/$${TARGET}/bin
		else: unix:!android: target.path = /opt/$${TARGET}/bin
		!isEmpty(target.path): INSTALLS += target
	\end{lstlisting}
	
	gridscene.h
	\begin{lstlisting}[style=cgstyle,language=C++]
		#ifndef GRIDSCENE_H
		#define GRIDSCENE_H
		
		#include <QGraphicsScene>
		#include <QMap>
		#include <QPoint>
		#include <QBrush>
		#include <QGraphicsRectItem>
		
		class GridScene : public QGraphicsScene {
			Q_OBJECT
			
			public:
			explicit GridScene(QObject *parent = nullptr);
			
			void paintCell(const QPoint& cell, const QBrush& brush);
			void clearCells();
			void setCellSize(int size) { cellSize = size; }
			int getCellSize() const { return cellSize; }
			bool isCellFilled(const QPoint& cell) const;
			
			signals:
			void cellClicked(const QPoint& cell);
			void leftClick(const QPoint& cell);
			void rightClick(const QPoint& cell);
			
			protected:
			void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
			void drawBackground(QPainter* painter, const QRectF& rect) override;
			
			private:
			int cellSize = 10;
			QHash<QPoint, QGraphicsRectItem*> cellItems;
		};
		
		#endif // GRIDSCENE_H
		
	\end{lstlisting}
	
	gridview.h
	\begin{lstlisting}[style=cgstyle,language=C++]
		#ifndef GRIDVIEW_H
		#define GRIDVIEW_H
		
		#include <QGraphicsView>
		
		class GridScene;
		
		class GridView : public QGraphicsView {
			Q_OBJECT
			
			public:
			explicit GridView(QWidget *parent = nullptr);
			explicit GridView(GridScene *scene, QWidget *parent = nullptr);
			
			void zoomIn();
			void zoomOut();
			void resetZoom();
			double getZoomFactor() const;
			
			protected:
			void wheelEvent(QWheelEvent *event) override;
			
			private:
			void setZoom(double factor);
			
			double zoomFactor = 1.0;
			const double zoomIncrement = 0.1;
			const double minZoom = 0.2;
			const double maxZoom = 5.0;
		};
		
		#endif // GRIDVIEW_H
	\end{lstlisting}
	
	mainwindow.h
	\begin{lstlisting}[style=cgstyle,language=C++]
		#ifndef MAINWINDOW_H
		#define MAINWINDOW_H
		
		#include <QMainWindow>
		#include <QList>
		#include <QPoint>
		#include <QPointF>
		#include <QRect>
		#include "gridscene.h"
		
		QT_BEGIN_NAMESPACE
		namespace Ui {
			class MainWindow;
		}
		QT_END_NAMESPACE
		
		class MainWindow : public QMainWindow
		{
			Q_OBJECT
			
			public:
			MainWindow(QWidget *parent = nullptr);
			~MainWindow();
			
			private slots:
			void onDrawLine();
			void onRestoreLine();
			void onEraseLine();
			void onDrawClippingWindow();
			void onEraseClippingWindow();
			void onClipLineCohenSutherland();
			void onClipLineLiangBarsky();
			void onClearAll();
			void onCellClicked(const QPoint& cell);
			
			private:
			Ui::MainWindow *ui;
			GridScene *scene;
			
			QList<QPoint> linePoints;
			QList<QPoint> originalLinePoints;
			bool isDrawingLine;
			int lineClickCount;
			
			QRect clippingWindow;
			bool hasClippingWindow;
			bool isDrawingWindow;
			int windowClickCount;
			QPoint windowStart;
			
			void bresenhamLine(const QPoint& p1, const QPoint& p2, const QBrush& brush);
			void drawRectangle(const QRect& rect, const QBrush& brush, int thickness = 1);
			void fillWindow(const QRect& rect, const QColor& color, int alpha);
			void clearLine();
			void clearWindow();
			void drawLineWithClipping(const QPoint& p1, const QPoint& p2, const QBrush& originalBrush, const QBrush& clippedBrush, bool useCohenSutherland);
			
			enum OutCode { INSIDE = 0, LEFT = 1, RIGHT = 2, BOTTOM = 4, TOP = 8 };
			
			int computeOutCode(double x, double y, const QRect& rect);
			bool cohenSutherlandClip(double& x1, double& y1, double& x2, double& y2, const QRect& rect);
			bool liangBarskyClip(double& x1, double& y1, double& x2, double& y2, const QRect& rect);
			
			void drawPartialLine(const QPoint& p1, const QPoint& p2, const QRect& window, const QBrush& insideBrush, const QBrush& outsideBrush, bool useCohenSutherland);
			bool isPointInsideWindow(const QPoint& p, const QRect& window);
		};
		
		#endif // MAINWINDOW_H
	\end{lstlisting}
	
	gridscene.cpp
	\begin{lstlisting}[style=cgstyle,language=C++]
		#include "gridscene.h"
		#include <QGraphicsSceneMouseEvent>
		#include <QPainter>
		#include <cmath>
		#include <QDebug>
		
		GridScene::GridScene(QObject *parent)
		: QGraphicsScene(parent) {
			setSceneRect(-5000, -5000, 10000, 10000);
		}
		
		void GridScene::paintCell(const QPoint& cell, const QBrush& brush) {
			if (!cellItems.contains(cell)) {
				auto *rect = addRect(cell.x() * cellSize, cell.y() * cellSize, cellSize, cellSize, Qt::NoPen, brush);
				cellItems[cell] = rect;
			} else {
				cellItems[cell]->setBrush(brush);
			}
		}
		
		void GridScene::clearCells() {
			for (auto *item : cellItems) removeItem(item);
			qDeleteAll(cellItems);
			cellItems.clear();
		}
		
		void GridScene::mousePressEvent(QGraphicsSceneMouseEvent *event) {
			QPoint cell(qFloor(event->scenePos().x() / cellSize),
			qFloor(event->scenePos().y() / cellSize));
			if (event->button() == Qt::LeftButton) {
				emit cellClicked(cell);
				emit leftClick(cell);
			}
		}
		
		bool GridScene::isCellFilled(const QPoint& cell) const
		{
			if (!cellItems.contains(cell))
			return false;
			QColor color = cellItems[cell]->brush().color();
			return color.alpha() > 0;
		}
		
		void GridScene::drawBackground(QPainter* painter, const QRectF& rect) {
			painter->setRenderHint(QPainter::Antialiasing, false);
			
			int left = std::floor(rect.left() / cellSize);
			int right = std::ceil(rect.right() / cellSize);
			int top = std::floor(rect.top() / cellSize);
			int bottom = std::ceil(rect.bottom() / cellSize);
			
			// grid lines
			QPen gridPen(Qt::lightGray);
			gridPen.setWidth(0);
			gridPen.setCosmetic(true);
			painter->setPen(gridPen);
			for (int x = left; x <= right; ++x)
			painter->drawLine(x * cellSize, rect.top(), x * cellSize, rect.bottom());
			for (int y = top; y <= bottom; ++y)
			painter->drawLine(rect.left(), y * cellSize, rect.right(), y * cellSize);
			
			// axes (filled cell-wise, like drawline app)
			painter->setPen(Qt::NoPen);
			painter->setBrush(Qt::black);
			
			// X-axis row (y = 0)
			for (int x = left; x <= right; ++x) {
				QRectF r(x * cellSize, 0, cellSize, cellSize);
				if (rect.intersects(r))
				painter->drawRect(r);
			}
			
			// Y-axis column (x = 0)
			for (int y = top; y <= bottom; ++y) {
				QRectF r(0, y * cellSize, cellSize, cellSize);
				if (rect.intersects(r))
				painter->drawRect(r);
			}
			
			// painted cells
			painter->setPen(Qt::NoPen);
			for (auto it = cellItems.constBegin(); it != cellItems.constEnd(); ++it) {
				QRectF r(it.key().x() * cellSize, it.key().y() * cellSize, cellSize, cellSize);
				painter->setBrush(it.value()->brush());
				if (rect.intersects(r))
				painter->drawRect(r);
			}
		}
	\end{lstlisting}
	
	gridview.cpp
	\begin{lstlisting}[style=cgstyle,language=C++]
		#include "gridview.h"
		#include "gridscene.h"
		#include <QPainter>
		#include <QWheelEvent>
		#include <QApplication>
		#include <QDebug>
		
		GridView::GridView(QWidget *parent)
		: QGraphicsView(parent) {
			setRenderHint(QPainter::Antialiasing, false);
			setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
			setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
			setDragMode(QGraphicsView::NoDrag);
			setMouseTracking(true);
		}
		
		GridView::GridView(GridScene *scene, QWidget *parent)
		: QGraphicsView(scene, parent) {
			setRenderHint(QPainter::Antialiasing, false);
			setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
			setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
			setDragMode(QGraphicsView::NoDrag);
			setMouseTracking(true);
		}
		
		void GridView::wheelEvent(QWheelEvent *event) {
			if (QApplication::keyboardModifiers() & Qt::ControlModifier) {
				if (event->angleDelta().y() > 0) zoomIn();
				else zoomOut();
				event->accept();
			} else {
				QGraphicsView::wheelEvent(event);
			}
		}
		
		void GridView::zoomIn() {
			if (zoomFactor < maxZoom) {
				double newZoom = qMin(zoomFactor + zoomIncrement, maxZoom);
				setZoom(newZoom);
			}
		}
		
		void GridView::zoomOut() {
			if (zoomFactor > minZoom) {
				double newZoom = qMax(zoomFactor - zoomIncrement, minZoom);
				setZoom(newZoom);
			}
		}
		
		void GridView::resetZoom() {
			setZoom(1.0);
		}
		
		double GridView::getZoomFactor() const {
			return zoomFactor;
		}
		
		void GridView::setZoom(double factor) {
			if (factor >= minZoom && factor <= maxZoom && factor != zoomFactor) {
				QPointF oldPos = mapToScene(viewport()->rect().center());
				resetTransform();
				scale(factor, factor);
				zoomFactor = factor;
				centerOn(oldPos);
				qDebug() << "Zoom level:" << zoomFactor * 100 << "%";
			}
		}
	\end{lstlisting}
	
	mainwindow.cpp
	\begin{lstlisting}[style=cgstyle,language=C++]
		#include "mainwindow.h"
		#include "ui_mainwindow.h"
		#include "gridscene.h"
		#include "gridview.h"
		#include <QMessageBox>
		#include <cmath>
		#include <algorithm>
		
		MainWindow::MainWindow(QWidget *parent)
		: QMainWindow(parent)
		, ui(new Ui::MainWindow)
		, scene(new GridScene(this))
		, isDrawingLine(false)
		, lineClickCount(0)
		, hasClippingWindow(false)
		, isDrawingWindow(false)
		, windowClickCount(0)
		{
			ui->setupUi(this);
			ui->grid->setScene(scene);
			ui->grid->setFixedSize(ui->grid->width(), ui->grid->height());
			ui->grid->centerOn(0, 0);
			scene->setCellSize(10);
			
			connect(ui->drawLine, &QPushButton::clicked, this, &MainWindow::onDrawLine);
			connect(ui->restoreLine, &QPushButton::clicked, this, &MainWindow::onRestoreLine);
			connect(ui->eraseLine, &QPushButton::clicked, this, &MainWindow::onEraseLine);
			connect(ui->drawWindow, &QPushButton::clicked, this, &MainWindow::onDrawClippingWindow);
			connect(ui->eraseWindow, &QPushButton::clicked, this, &MainWindow::onEraseClippingWindow);
			connect(ui->clipLineCohenSuther, &QPushButton::clicked, this, &MainWindow::onClipLineCohenSutherland);
			connect(ui->clipLineLiangBarsky, &QPushButton::clicked, this, &MainWindow::onClipLineLiangBarsky);
			connect(ui->clearAll, &QPushButton::clicked, this, &MainWindow::onClearAll);
			connect(scene, &GridScene::leftClick, this, &MainWindow::onCellClicked);
		}
		
		MainWindow::~MainWindow()
		{
			delete scene;
			delete ui;
		}
		
		void MainWindow::onCellClicked(const QPoint& cell)
		{
			if (isDrawingLine) {
				linePoints.append(cell);
				lineClickCount++;
				scene->paintCell(cell, QBrush(Qt::blue));
				
				if (lineClickCount == 2) {
					bresenhamLine(linePoints[0], linePoints[1], QBrush(Qt::blue));
					originalLinePoints = linePoints;
					isDrawingLine = false;
					lineClickCount = 0;
					scene->update();
				}
			}
			else if (isDrawingWindow) {
				if (windowClickCount == 0) {
					windowStart = cell;
					scene->paintCell(cell, QBrush(Qt::red));
					windowClickCount++;
				}
				else if (windowClickCount == 1) {
					int xMin = std::min(windowStart.x(), cell.x());
					int yMin = std::min(windowStart.y(), cell.y());
					int xMax = std::max(windowStart.x(), cell.x());
					int yMax = std::max(windowStart.y(), cell.y());
					
					clippingWindow = QRect(QPoint(xMin, yMin), QPoint(xMax, yMax));
					
					fillWindow(clippingWindow, QColor(173, 216, 230), 120);
					drawRectangle(clippingWindow, QBrush(Qt::red), 1);
					
					hasClippingWindow = true;
					isDrawingWindow = false;
					windowClickCount = 0;
					scene->update();
				}
			}
		}
		
		void MainWindow::fillWindow(const QRect& rect, const QColor& color, int alpha)
		{
			QColor translucent = color;
			translucent.setAlpha(alpha);
			for (int x = rect.left(); x <= rect.right(); ++x)
			for (int y = rect.top(); y <= rect.bottom(); ++y) {
				if (!scene->isCellFilled(QPoint(x, y)))  // skip if already painted
				scene->paintCell(QPoint(x, y), QBrush(translucent));
			}
		}
		
		void MainWindow::onDrawLine()
		{
			if (isDrawingWindow) {
				QMessageBox::warning(this, "Warning", "Please finish drawing the clipping window first!");
				return;
			}
			
			clearLine();
			linePoints.clear();
			originalLinePoints.clear();
			isDrawingLine = true;
			lineClickCount = 0;
			QMessageBox::information(this, "Draw Line", "Click two points to draw a line.");
		}
		
		void MainWindow::onRestoreLine()
		{
			if (originalLinePoints.size() != 2) {
				QMessageBox::warning(this, "Warning", "No original line to restore!");
				return;
			}
			
			clearLine();
			linePoints = originalLinePoints;
			
			if (hasClippingWindow) {
				fillWindow(clippingWindow, QColor(173, 216, 230), 120);
				drawRectangle(clippingWindow, QBrush(Qt::red), 1);
			}
			
			bresenhamLine(linePoints[0], linePoints[1], QBrush(Qt::blue));
			scene->update();
		}
		
		void MainWindow::onEraseLine()
		{
			clearLine();
			linePoints.clear();
			originalLinePoints.clear();
			scene->update();
		}
		
		void MainWindow::onDrawClippingWindow()
		{
			if (isDrawingLine) {
				QMessageBox::warning(this, "Warning", "Please finish drawing the line first!");
				return;
			}
			
			clearWindow();
			isDrawingWindow = true;
			windowClickCount = 0;
			hasClippingWindow = false;
			QMessageBox::information(this, "Draw Clipping Window", "Click two diagonal corners to define the clipping window.");
		}
		
		void MainWindow::onEraseClippingWindow()
		{
			clearWindow();
			hasClippingWindow = false;
			scene->update();
		}
		
		void MainWindow::onClipLineCohenSutherland()
		{
			if (linePoints.size() != 2) {
				QMessageBox::warning(this, "Warning", "Please draw a line first!");
				return;
			}
			
			if (!hasClippingWindow) {
				QMessageBox::warning(this, "Warning", "Please draw a clipping window first!");
				return;
			}
			
			clearLine();
			fillWindow(clippingWindow, QColor(173, 216, 230), 120);
			drawRectangle(clippingWindow, QBrush(Qt::red), 1);
			
			drawPartialLine(linePoints[0], linePoints[1], clippingWindow, QBrush(Qt::green), QBrush(Qt::gray), true);
			
			scene->update();
		}
		
		void MainWindow::onClipLineLiangBarsky()
		{
			if (linePoints.size() != 2) {
				QMessageBox::warning(this, "Warning", "Please draw a line first!");
				return;
			}
			
			if (!hasClippingWindow) {
				QMessageBox::warning(this, "Warning", "Please draw a clipping window first!");
				return;
			}
			
			clearLine();
			fillWindow(clippingWindow, QColor(173, 216, 230), 120);
			drawRectangle(clippingWindow, QBrush(Qt::red), 1);
			
			drawPartialLine(linePoints[0], linePoints[1], clippingWindow, QBrush(Qt::green), QBrush(Qt::gray), false);
			
			scene->update();
		}
		
		void MainWindow::onClearAll()
		{
			scene->clearCells();
			linePoints.clear();
			originalLinePoints.clear();
			isDrawingLine = false;
			lineClickCount = 0;
			hasClippingWindow = false;
			isDrawingWindow = false;
			windowClickCount = 0;
			scene->update();
		}
		
		void MainWindow::bresenhamLine(const QPoint& p1, const QPoint& p2, const QBrush& brush)
		{
			int x1 = p1.x(), y1 = p1.y(), x2 = p2.x(), y2 = p2.y();
			int dx = abs(x2 - x1), dy = abs(y2 - y1);
			int sx = (x1 < x2) ? 1 : -1;
			int sy = (y1 < y2) ? 1 : -1;
			int err = dx - dy;
			
			while (true) {
				scene->paintCell(QPoint(x1, y1), brush);
				if (x1 == x2 && y1 == y2) break;
				int e2 = 2 * err;
				if (e2 > -dy) { err -= dy; x1 += sx; }
				if (e2 < dx) { err += dx; y1 += sy; }
			}
		}
		
		void MainWindow::drawRectangle(const QRect& rect, const QBrush& brush, int thickness)
		{
			for (int i = 0; i < thickness; ++i) {
				bresenhamLine(QPoint(rect.left() + i, rect.top() + i), QPoint(rect.right() - i, rect.top() + i), brush);
				bresenhamLine(QPoint(rect.left() + i, rect.bottom() - i), QPoint(rect.right() - i, rect.bottom() - i), brush);
				bresenhamLine(QPoint(rect.left() + i, rect.top() + i), QPoint(rect.left() + i, rect.bottom() - i), brush);
				bresenhamLine(QPoint(rect.right() - i, rect.top() + i), QPoint(rect.right() - i, rect.bottom() - i), brush);
			}
		}
		
		bool MainWindow::isPointInsideWindow(const QPoint& p, const QRect& window)
		{
			return p.x() >= window.left() && p.x() <= window.right() && p.y() >= window.top() && p.y() <= window.bottom();
		}
		
		void MainWindow::drawPartialLine(const QPoint& p1, const QPoint& p2, const QRect& window, const QBrush& insideBrush, const QBrush& outsideBrush, bool useCohenSutherland)
		{
			int x1 = p1.x(), y1 = p1.y(), x2 = p2.x(), y2 = p2.y();
			int dx = abs(x2 - x1), dy = abs(y2 - y1);
			int sx = (x1 < x2) ? 1 : -1;
			int sy = (y1 < y2) ? 1 : -1;
			int err = dx - dy;
			
			while (true) {
				QPoint cell(x1, y1);
				if (isPointInsideWindow(cell, window))
				scene->paintCell(cell, insideBrush);
				else
				scene->paintCell(cell, outsideBrush);
				
				if (x1 == x2 && y1 == y2) break;
				int e2 = 2 * err;
				if (e2 > -dy) { err -= dy; x1 += sx; }
				if (e2 < dx)  { err += dx; y1 += sy; }
			}
		}
		
		
		void MainWindow::clearLine()
		{
			if (linePoints.size() != 2) return;
			
			int x1 = linePoints[0].x(), y1 = linePoints[0].y();
			int x2 = linePoints[1].x(), y2 = linePoints[1].y();
			int dx = abs(x2 - x1), dy = abs(y2 - y1);
			int sx = (x1 < x2) ? 1 : -1;
			int sy = (y1 < y2) ? 1 : -1;
			int err = dx - dy;
			
			while (true) {
				QPoint cell(x1, y1);
				bool isOnWindow = hasClippingWindow && isPointInsideWindow(cell, clippingWindow);
				if (!isOnWindow)
				scene->paintCell(cell, QBrush(Qt::transparent));
				
				if (x1 == x2 && y1 == y2) break;
				int e2 = 2 * err;
				if (e2 > -dy) { err -= dy; x1 += sx; }
				if (e2 < dx) { err += dx; y1 += sy; }
			}
		}
		
		void MainWindow::clearWindow()
		{
			if (hasClippingWindow) {
				for (int x = clippingWindow.left(); x <= clippingWindow.right(); ++x)
				for (int y = clippingWindow.top(); y <= clippingWindow.bottom(); ++y)
				scene->paintCell(QPoint(x, y), QBrush(Qt::transparent));
			}
		}
		
		int MainWindow::computeOutCode(double x, double y, const QRect& rect)
		{
			int code = INSIDE;
			if (x < rect.left()) code |= LEFT;
			else if (x > rect.right()) code |= RIGHT;
			if (y < rect.top()) code |= BOTTOM;
			else if (y > rect.bottom()) code |= TOP;
			return code;
		}
		
		bool MainWindow::cohenSutherlandClip(double& x1, double& y1, double& x2, double& y2, const QRect& rect)
		{
			int outcode1 = computeOutCode(x1, y1, rect);
			int outcode2 = computeOutCode(x2, y2, rect);
			bool accept = false;
			
			while (true) {
				if (!(outcode1 | outcode2)) { accept = true; break; }
				else if (outcode1 & outcode2) break;
				else {
					int outcodeOut = outcode1 ? outcode1 : outcode2;
					double x, y;
					
					if (outcodeOut & TOP) {
						x = x1 + (x2 - x1) * (rect.bottom() - y1) / (y2 - y1);
						y = rect.bottom();
					}
					else if (outcodeOut & BOTTOM) {
						x = x1 + (x2 - x1) * (rect.top() - y1) / (y2 - y1);
						y = rect.top();
					}
					else if (outcodeOut & RIGHT) {
						y = y1 + (y2 - y1) * (rect.right() - x1) / (x2 - x1);
						x = rect.right();
					}
					else if (outcodeOut & LEFT) {
						y = y1 + (y2 - y1) * (rect.left() - x1) / (x2 - x1);
						x = rect.left();
					}
					
					if (outcodeOut == outcode1) {
						x1 = x; y1 = y;
						outcode1 = computeOutCode(x1, y1, rect);
					}
					else {
						x2 = x; y2 = y;
						outcode2 = computeOutCode(x2, y2, rect);
					}
				}
			}
			return accept;
		}
		
		bool MainWindow::liangBarskyClip(double& x1, double& y1, double& x2, double& y2, const QRect& rect)
		{
			double xmin = rect.left(), xmax = rect.right(), ymin = rect.top(), ymax = rect.bottom();
			double dx = x2 - x1, dy = y2 - y1, t0 = 0.0, t1 = 1.0;
			double p[4] = {-dx, dx, -dy, dy};
			double q[4] = {x1 - xmin, xmax - x1, y1 - ymin, ymax - y1};
			
			for (int i = 0; i < 4; i++) {
				if (p[i] == 0 && q[i] < 0) return false;
				double t = q[i] / p[i];
				if (p[i] < 0) t0 = std::max(t0, t);
				else if (p[i] > 0) t1 = std::min(t1, t);
				if (t0 > t1) return false;
			}
			
			if (t0 > 0) { x1 += t0 * dx; y1 += t0 * dy; }
			if (t1 < 1) { x2 -= (1 - t1) * dx; y2 -= (1 - t1) * dy; }
			
			return true;
		}
	\end{lstlisting}
	
	mainwindow.cpp
	\begin{lstlisting}[style=cgstyle,language=C++]
	#include "mainwindow.h"
	
	#include <QApplication>
	
	int main(int argc, char *argv[])
	{
		QApplication a(argc, argv);
		MainWindow w;
		w.show();
		return a.exec();
	}
	\end{lstlisting}
	
	\subsubsection*{polygon\_clipping.pro}
	\begin{lstlisting}[style=cgstyle,language=C++]
		QT       += core gui
		
		greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
		
		CONFIG += c++17
		
		# You can make your code fail to compile if it uses deprecated APIs.
		# In order to do so, uncomment the following line.
		#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0
		
		SOURCES += \
		gridscene.cpp \
		gridview.cpp \
		main.cpp \
		mainwindow.cpp
		
		HEADERS += \
		gridscene.h \
		gridview.h \
		mainwindow.h
		
		FORMS += \
		mainwindow.ui
		
		# Default rules for deployment.
		qnx: target.path = /tmp/$${TARGET}/bin
		else: unix:!android: target.path = /opt/$${TARGET}/bin
		!isEmpty(target.path): INSTALLS += target
	\end{lstlisting}
	
	gridscene.h
	\begin{lstlisting}[style=cgstyle,language=C++]
		#ifndef GRIDSCENE_H
		#define GRIDSCENE_H
		
		#include <QGraphicsScene>
		#include <QMap>
		#include <QPoint>
		#include <QBrush>
		#include <QGraphicsRectItem>
		
		class GridScene : public QGraphicsScene {
			Q_OBJECT
			
			public:
			explicit GridScene(QObject *parent = nullptr);
			
			void paintCell(const QPoint& cell, const QBrush& brush);
			void clearCells();
			void setCellSize(int size) { cellSize = size; }
			int getCellSize() const { return cellSize; }
			
			signals:
			void cellClicked(const QPoint& cell);
			void leftClick(const QPoint& cell);
			void rightClick(const QPoint& cell);
			
			protected:
			void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
			void drawBackground(QPainter* painter, const QRectF& rect) override;
			
			private:
			int cellSize = 10;
			QHash<QPoint, QGraphicsRectItem*> cellItems;
		};
		
		#endif // GRIDSCENE_H
	\end{lstlisting}
	
	gridview.h
	\begin{lstlisting}[style=cgstyle,language=C++]
		#ifndef GRIDVIEW_H
		#define GRIDVIEW_H
		
		#include <QGraphicsView>
		
		class GridScene;
		
		class GridView : public QGraphicsView {
			Q_OBJECT
			
			public:
			explicit GridView(QWidget *parent = nullptr);
			explicit GridView(GridScene *scene, QWidget *parent = nullptr);
			
			void zoomIn();
			void zoomOut();
			void resetZoom();
			double getZoomFactor() const;
			
			protected:
			void wheelEvent(QWheelEvent *event) override;
			
			private:
			void setZoom(double factor);
			
			double zoomFactor = 1.0;
			const double zoomIncrement = 0.1;
			const double minZoom = 0.2;
			const double maxZoom = 5.0;
		};
		
		#endif // GRIDVIEW_H
	\end{lstlisting}
	
	mainwindow.h
	\begin{lstlisting}[style=cgstyle,language=C++]
		#ifndef MAINWINDOW_H
		#define MAINWINDOW_H
		
		#include <QMainWindow>
		#include <QList>
		#include <QPoint>
		#include <QPointF>
		#include <QRect>
		#include <QSet>
		#include <QMap>
		#include <cmath>
		#include "gridscene.h"
		
		QT_BEGIN_NAMESPACE
		namespace Ui {
			class MainWindow;
		}
		QT_END_NAMESPACE
		
		struct VertexData {
			QPointF pos;
			bool isIntersection = false;
			bool isStartNode = false;
			int link = -1;
			bool visited = false;
		};
		
		class MainWindow : public QMainWindow
		{
			Q_OBJECT
			
			public:
			MainWindow(QWidget *parent = nullptr);
			~MainWindow();
			
			private slots:
			void onDrawPolygon();
			void onRestorePolygon();
			void onErasePolygon();
			void onDrawClippingWindow();
			void onEraseClippingWindow();
			void onClipPolygonSutherHodge();
			void onClipPolygonWeilerAther();
			void onClearAll();
			void onCellClicked(const QPoint& cell);
			
			private:
			Ui::MainWindow *ui;
			GridScene *scene;
			
			QList<QPoint> polygonVertices;
			QList<QPoint> originalPolygonVertices;
			bool hasPolygon;
			bool isSelectingVertices;
			
			QRect clippingWindow;
			bool hasClippingWindow;
			bool isDrawingWindow;
			int windowClickCount;
			QPoint windowStart;
			
			void bresenhamLine(const QPoint& p1, const QPoint& p2, const QBrush& brush, bool collect = false);
			void drawPolygonOutline(const QList<QPoint>& vertices, const QBrush& brush, bool collect = false);
			void drawRectangle(const QRect& rect, const QBrush& brush);
			void drawRectangle(const QRect& rect, const QBrush& brush, int thickness);
			void clearPolygon();
			void clearWindow();
			void fillWindow(const QRect& rect, const QColor& color, int alpha);
			
			enum EdgePosition {
				LEFT_EDGE = 0,
				RIGHT_EDGE = 1,
				BOTTOM_EDGE = 2,
				TOP_EDGE = 3
			};
			
			QList<QPointF> clipAgainstEdge(const QList<QPointF>& inputVertices, EdgePosition edge, const QRect& clipRect);
			bool isInside(const QPointF& point, EdgePosition edge, const QRect& clipRect);
			QPointF getIntersection(const QPointF& p1, const QPointF& p2, EdgePosition edge, const QRect& clipRect);
			QList<QPointF> sutherlandHodgemanClip(const QList<QPointF>& polygon, const QRect& clipRect);
			QPointF computeLineIntersection(const QPointF& p1, const QPointF& p2, const QPointF& p3, const QPointF& p4);
			double distance(const QPointF& p1, const QPointF& p2);
			bool isPointInsidePolygon(const QPointF& point, const QList<QPointF>& polygon);
			void drawPolygonInsideRect(const QList<QPoint>& vertices, const QRect& rect, const QBrush& brush);
			
			
			QPointF getIntersectionWA(const QPointF& p1, const QPointF& p2, const QPointF& w1, const QPointF& w2);
			void weilerAthertonPolygonClip();
			bool isInsideClipWindow(const QPointF& p) const;
			bool pointInPolygon(const QVector<QPointF>& poly, const QPointF& test) const;
			QVector<QPoint> preClipPolygon;
			QVector<QPair<QPoint, QPoint>> preClipLines;
			bool hasPreClip = false;
		};
		
		#endif // MAINWINDOW_H
	\end{lstlisting}
	
	gridscene.cpp
	\begin{lstlisting}[style=cgstyle,language=C++]
		#include "gridscene.h"
		#include <QGraphicsSceneMouseEvent>
		#include <QPainter>
		#include <cmath>
		#include <QDebug>
		
		GridScene::GridScene(QObject *parent)
		: QGraphicsScene(parent) {
			setSceneRect(-5000, -5000, 10000, 10000);
		}
		
		void GridScene::paintCell(const QPoint& cell, const QBrush& brush) {
			if (!cellItems.contains(cell)) {
				auto *rect = addRect(cell.x() * cellSize, cell.y() * cellSize, cellSize, cellSize, Qt::NoPen, brush);
				cellItems[cell] = rect;
			} else {
				cellItems[cell]->setBrush(brush);
			}
		}
		
		void GridScene::clearCells() {
			for (auto *item : cellItems) removeItem(item);
			qDeleteAll(cellItems);
			cellItems.clear();
		}
		
		void GridScene::mousePressEvent(QGraphicsSceneMouseEvent *event) {
			QPoint cell(qFloor(event->scenePos().x() / cellSize),
			qFloor(event->scenePos().y() / cellSize));
			if (event->button() == Qt::LeftButton) {
				emit cellClicked(cell);
				emit leftClick(cell);
			}
		}
		
		void GridScene::drawBackground(QPainter* painter, const QRectF& rect) {
			painter->setRenderHint(QPainter::Antialiasing, false);
			
			int left = std::floor(rect.left() / cellSize);
			int right = std::ceil(rect.right() / cellSize);
			int top = std::floor(rect.top() / cellSize);
			int bottom = std::ceil(rect.bottom() / cellSize);
			
			// grid lines
			QPen gridPen(Qt::lightGray);
			gridPen.setWidth(0);
			gridPen.setCosmetic(true);
			painter->setPen(gridPen);
			for (int x = left; x <= right; ++x)
			painter->drawLine(x * cellSize, rect.top(), x * cellSize, rect.bottom());
			for (int y = top; y <= bottom; ++y)
			painter->drawLine(rect.left(), y * cellSize, rect.right(), y * cellSize);
			
			// axes (filled cell-wise, like drawline app)
			painter->setPen(Qt::NoPen);
			painter->setBrush(Qt::black);
			
			// X-axis row (y = 0)
			for (int x = left; x <= right; ++x) {
				QRectF r(x * cellSize, 0, cellSize, cellSize);
				if (rect.intersects(r))
				painter->drawRect(r);
			}
			
			// Y-axis column (x = 0)
			for (int y = top; y <= bottom; ++y) {
				QRectF r(0, y * cellSize, cellSize, cellSize);
				if (rect.intersects(r))
				painter->drawRect(r);
			}
			
			// painted cells
			painter->setPen(Qt::NoPen);
			for (auto it = cellItems.constBegin(); it != cellItems.constEnd(); ++it) {
				QRectF r(it.key().x() * cellSize, it.key().y() * cellSize, cellSize, cellSize);
				painter->setBrush(it.value()->brush());
				if (rect.intersects(r))
				painter->drawRect(r);
			}
		}
	\end{lstlisting}
	
	gridview.cpp
	\begin{lstlisting}[style=cgstyle,language=C++]
		#include "gridview.h"
		#include "gridscene.h"
		#include <QPainter>
		#include <QWheelEvent>
		#include <QApplication>
		#include <QDebug>
		
		GridView::GridView(QWidget *parent)
		: QGraphicsView(parent) {
			setRenderHint(QPainter::Antialiasing, false);
			setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
			setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
			setDragMode(QGraphicsView::NoDrag);
			setMouseTracking(true);
		}
		
		GridView::GridView(GridScene *scene, QWidget *parent)
		: QGraphicsView(scene, parent) {
			setRenderHint(QPainter::Antialiasing, false);
			setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
			setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
			setDragMode(QGraphicsView::NoDrag);
			setMouseTracking(true);
		}
		
		void GridView::wheelEvent(QWheelEvent *event) {
			if (QApplication::keyboardModifiers() & Qt::ControlModifier) {
				if (event->angleDelta().y() > 0) zoomIn();
				else zoomOut();
				event->accept();
			} else {
				QGraphicsView::wheelEvent(event);
			}
		}
		
		void GridView::zoomIn() {
			if (zoomFactor < maxZoom) {
				double newZoom = qMin(zoomFactor + zoomIncrement, maxZoom);
				setZoom(newZoom);
			}
		}
		
		void GridView::zoomOut() {
			if (zoomFactor > minZoom) {
				double newZoom = qMax(zoomFactor - zoomIncrement, minZoom);
				setZoom(newZoom);
			}
		}
		
		void GridView::resetZoom() {
			setZoom(1.0);
		}
		
		double GridView::getZoomFactor() const {
			return zoomFactor;
		}
		
		void GridView::setZoom(double factor) {
			if (factor >= minZoom && factor <= maxZoom && factor != zoomFactor) {
				QPointF oldPos = mapToScene(viewport()->rect().center());
				resetTransform();
				scale(factor, factor);
				zoomFactor = factor;
				centerOn(oldPos);
				qDebug() << "Zoom level:" << zoomFactor * 100 << "%";
			}
		}
	\end{lstlisting}
	
	mainwindow.cpp
	\begin{lstlisting}[style=cgstyle,language=C++]
		#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "gridscene.h"
#include "gridview.h"
#include <QMessageBox>
#include <cmath>
#include <algorithm>

QSet<QPoint> polygonPixels;
static inline bool feq(double a, double b, double eps=1e-6){
    return std::abs(a-b)<=eps; }

static inline bool peq(const QPointF& a, const QPointF& b){
    return feq(a.x(),b.x()) && feq(a.y(),b.y());
}


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
    , scene(new GridScene(this))
    , hasPolygon(false)
    , isSelectingVertices(false)
    , hasClippingWindow(false)
    , isDrawingWindow(false)
    , windowClickCount(0)
{
    ui->setupUi(this);

    ui->grid->setScene(scene);
    ui->grid->setFixedSize(ui->grid->width(), ui->grid->height());
    ui->grid->centerOn(0, 0);
    scene->setCellSize(10);

    connect(ui->drawPolygon, &QPushButton::clicked, this, &MainWindow::onDrawPolygon);
    connect(ui->restorePolygon, &QPushButton::clicked, this, &MainWindow::onRestorePolygon);
    connect(ui->erasePolygon, &QPushButton::clicked, this, &MainWindow::onErasePolygon);
    connect(ui->drawWindow, &QPushButton::clicked, this, &MainWindow::onDrawClippingWindow);
    connect(ui->eraseWindow, &QPushButton::clicked, this, &MainWindow::onEraseClippingWindow);
    connect(ui->clipPolygonSutherHodge, &QPushButton::clicked, this, &MainWindow::onClipPolygonSutherHodge);
    connect(ui->clipPolygonWeilerAther, &QPushButton::clicked, this, &MainWindow::onClipPolygonWeilerAther);
    connect(ui->clearAll, &QPushButton::clicked, this, &MainWindow::onClearAll);
    connect(scene, &GridScene::leftClick, this, &MainWindow::onCellClicked);

    polygonVertices.clear();
    originalPolygonVertices.clear();
}

MainWindow::~MainWindow()
{
    delete scene;
    delete ui;
}

void MainWindow::onCellClicked(const QPoint& cell)
{
    if (isSelectingVertices) {
        polygonVertices.append(cell);
        scene->paintCell(cell, QBrush(Qt::blue));
        scene->update();
    }
    else if (isDrawingWindow) {
        if (windowClickCount == 0) {
            windowStart = cell;
            scene->paintCell(cell, QBrush(Qt::red));
            windowClickCount++;
        }
        else if (windowClickCount == 1) {
            int xMin = std::min(windowStart.x(), cell.x());
            int yMin = std::min(windowStart.y(), cell.y());
            int xMax = std::max(windowStart.x(), cell.x());
            int yMax = std::max(windowStart.y(), cell.y());
            clippingWindow = QRect(QPoint(xMin, yMin), QPoint(xMax, yMax));
            fillWindow(clippingWindow, QColor(173, 216, 230), 120);
            drawRectangle(clippingWindow, QBrush(Qt::red), 1);
            if (hasPolygon) drawPolygonOutline(polygonVertices, QBrush(Qt::blue));
            hasClippingWindow = true;
            isDrawingWindow = false;
            windowClickCount = 0;
            scene->update();
        }
    }
}


void MainWindow::onDrawPolygon()
{
    if (isDrawingWindow) {
        QMessageBox::warning(this, "Warning", "Please finish drawing the clipping window first!");
        return;
    }

    if (isSelectingVertices) {
        if (polygonVertices.size() < 3) {
            QMessageBox::warning(this, "Warning", "Please select at least 3 vertices for a polygon!");
            return;
        }

        originalPolygonVertices = polygonVertices;
        drawPolygonOutline(polygonVertices, QBrush(Qt::blue), true);
        hasPolygon = true;
        isSelectingVertices = false;
        scene->update();
    }
    else {
        clearPolygon();
        polygonVertices.clear();
        originalPolygonVertices.clear();
        isSelectingVertices = true;
        hasPolygon = false;
        QMessageBox::information(this, "Draw Polygon", "Click on the grid to select vertices. Click 'Draw Polygon' again to finish.");
    }
}

void MainWindow::onRestorePolygon()
{
    if (originalPolygonVertices.size() < 3) {
        QMessageBox::warning(this, "Warning", "No original polygon to restore!");
        return;
    }

    clearPolygon();
    polygonVertices = originalPolygonVertices;
    drawPolygonOutline(polygonVertices, QBrush(Qt::blue), true);
    hasPolygon = true;
    scene->update();
}


void MainWindow::onErasePolygon()
{
    clearPolygon();
    polygonVertices.clear();
    originalPolygonVertices.clear();
    hasPolygon = false;
    isSelectingVertices = false;
    scene->update();
}


void MainWindow::onDrawClippingWindow()
{
    if (isSelectingVertices) {
        QMessageBox::warning(this, "Warning", "Please finish drawing the polygon first!");
        return;
    }

    clearWindow();
    isDrawingWindow = true;
    windowClickCount = 0;
    hasClippingWindow = false;
    QMessageBox::information(this, "Draw Clipping Window", "Click two diagonal corners to define the clipping window.");
}


void MainWindow::onEraseClippingWindow()
{
    clearWindow();
    hasClippingWindow = false;
    scene->update();
}


void MainWindow::drawPolygonInsideRect(const QList<QPoint>& /*unused*/, const QRect& rect, const QBrush& brush)
{
    for (const QPoint& p : polygonPixels) {
        if (rect.contains(p, true)) scene->paintCell(p, brush);
    }
}


void MainWindow::onClipPolygonSutherHodge()
{
    if (!hasPolygon) { QMessageBox::warning(this, "Warning", "Please draw a polygon first!"); return; }
    if (!hasClippingWindow) { QMessageBox::warning(this, "Warning", "Please draw a clipping window first!"); return; }
    if (polygonVertices.size() < 3) { QMessageBox::warning(this, "Warning", "Invalid polygon!"); return; }

    QList<QPointF> inputPolygon;
    for (const QPoint& p : polygonVertices) inputPolygon.append(QPointF(p));
    QList<QPointF> clippedPolygon = sutherlandHodgemanClip(inputPolygon, clippingWindow);

    QList<QPoint> original = polygonVertices;
    clearPolygon();
    drawPolygonOutline(original, QBrush(Qt::gray), true);
    fillWindow(clippingWindow, QColor(173, 216, 230), 120);
    drawRectangle(clippingWindow, QBrush(Qt::red), 1);

    if (clippedPolygon.size() >= 2) {
        QList<QPoint> clippedInt;
        clippedInt.reserve(clippedPolygon.size());
        for (const QPointF& p : clippedPolygon)
            clippedInt.append(QPoint(qRound(p.x()), qRound(p.y())));

        drawPolygonOutline(clippedInt, QBrush(Qt::green));

        polygonVertices = clippedInt;
        hasPolygon = true;
    } else {
        polygonVertices.clear();
        hasPolygon = false;
        QMessageBox::information(this, "Clipping Result", "Polygon is completely outside the clipping window or too small after clipping!");
    }

    scene->update();
}


void MainWindow::onClipPolygonWeilerAther()
{
    if (!hasPolygon) { QMessageBox::warning(this, "Warning", "Please draw a polygon first!"); return; }
    if (!hasClippingWindow) { QMessageBox::warning(this, "Warning", "Please draw a clipping window first!"); return; }
    if (polygonVertices.size() < 3) { QMessageBox::warning(this, "Warning", "Invalid polygon!"); return; }

    weilerAthertonPolygonClip();
}


QPointF MainWindow::getIntersectionWA(const QPointF& p1, const QPointF& p2, const QPointF& q1, const QPointF& q2)
{
    double A1 = p2.y() - p1.y();
    double B1 = p1.x() - p2.x();
    double C1 = A1 * p1.x() + B1 * p1.y();

    double A2 = q2.y() - q1.y();
    double B2 = q1.x() - q2.x();
    double C2 = A2 * q1.x() + B2 * q1.y();

    double det = A1 * B2 - A2 * B1;
    if (std::abs(det) < 1e-9) return QPointF();

    double x = (B2 * C1 - B1 * C2) / det;
    double y = (A1 * C2 - A2 * C1) / det;

    const double eps = 1e-6;
    if (x >= std::min(p1.x(), p2.x()) - eps && x <= std::max(p1.x(), p2.x()) + eps &&
        y >= std::min(p1.y(), p2.y()) - eps && y <= std::max(p1.y(), p2.y()) + eps &&
        x >= std::min(q1.x(), q2.x()) - eps && x <= std::max(q1.x(), q2.x()) + eps &&
        y >= std::min(q1.y(), q2.y()) - eps && y <= std::max(q1.y(), q2.y()) + eps)
    {
        return QPointF(x, y);
    }
    return QPointF();
}


bool MainWindow::isInsideClipWindow(const QPointF& p) const
{
    return p.x() >= clippingWindow.left()  && p.x() <= clippingWindow.right() && p.y() >= clippingWindow.top()   && p.y() <= clippingWindow.bottom();
}

bool MainWindow::pointInPolygon(const QVector<QPointF>& poly, const QPointF& test) const
{
    bool inside = false;
    int n = poly.size();
    for (int i = 0, j = n - 1; i < n; j = i++) {
        const QPointF& pi = poly[i];
        const QPointF& pj = poly[j];
        bool intersect = ((pi.y() > test.y()) != (pj.y() > test.y())) &&
                         (test.x() < (pj.x() - pi.x()) * (test.y() - pi.y()) /
                                             (pj.y() - pi.y() + 1e-12) + pi.x());
        if (intersect) inside = !inside;
    }
    return inside;
}

void MainWindow::weilerAthertonPolygonClip()
{
    QVector<QPoint> origPolyInt = QVector<QPoint>::fromList(polygonVertices);
    QVector<QPointF> origPoly; origPoly.reserve(origPolyInt.size());
    for (const auto& q : origPolyInt) origPoly.append(QPointF(q));


    QList<VertexData> subjectList;
    for (const auto& p : polygonVertices) subjectList.append({QPointF(p)});

    QList<VertexData> clipList;
    QVector<QPoint> windowVerts = {
        clippingWindow.topLeft(),
        QPoint(clippingWindow.right(),  clippingWindow.top()),
        clippingWindow.bottomRight(),
        QPoint(clippingWindow.left(),   clippingWindow.bottom())
    };
    for (const auto& p : windowVerts) clipList.append({QPointF(p)});

    bool allInside = true;
    for (const auto& v : subjectList) {
        if (!isInsideClipWindow(v.pos)) {
            allInside = false; break;
        }
    }

    QList<QPair<int, VertexData>> subjectInserts, clipInserts;
    for (int i = 0; i < subjectList.size(); ++i) {
        QPointF p1 = subjectList[i].pos;
        QPointF p2 = subjectList[(i + 1) % subjectList.size()].pos;

        for (int j = 0; j < clipList.size(); ++j) {
            QPointF w1 = clipList[j].pos;
            QPointF w2 = clipList[(j + 1) % clipList.size()].pos;

            QPointF I = getIntersectionWA(p1, p2, w1, w2);
            if (!I.isNull()) {
                bool isStartNode = isInsideClipWindow(p1) && !isInsideClipWindow(p2);
                subjectInserts.append({ i + 1, { I, true, isStartNode, -1, false } });
                clipInserts.append   ({ j + 1, { I, true, isStartNode, -1, false } });
            }
        }
    }

    QList<QPoint> original = polygonVertices;
    clearPolygon();
    if (!original.isEmpty()) drawPolygonOutline(original, QBrush(Qt::lightGray), /*collect=*/true);
    fillWindow(clippingWindow, QColor(173, 216, 230), 120);
    drawRectangle(clippingWindow, QBrush(Qt::red), 1);


    if (subjectInserts.isEmpty()) {
        if (allInside) {
            if (!original.isEmpty()) drawPolygonOutline(original, QBrush(Qt::green));
        } else {
            QPointF center((clippingWindow.left()+clippingWindow.right())/2.0,
                           (clippingWindow.top() +clippingWindow.bottom())/2.0);
            if (!origPoly.isEmpty() && pointInPolygon(origPoly, center)) {
                drawRectangle(clippingWindow, QBrush(Qt::green));
            }
        }
        scene->update();
        return;
    }

    std::sort(subjectInserts.begin(), subjectInserts.end(),
              [](auto& a, auto& b){ return a.first > b.first; });
    for (auto& ins : subjectInserts) subjectList.insert(ins.first, ins.second);

    std::sort(clipInserts.begin(), clipInserts.end(),
              [](auto& a, auto& b){ return a.first > b.first; });
    for (auto& ins : clipInserts) clipList.insert(ins.first, ins.second);


    for (int i = 0; i < subjectList.size(); ++i) {
        if (!subjectList[i].isIntersection) continue;
        for (int j = 0; j < clipList.size(); ++j) {
            if (clipList[j].isIntersection && subjectList[i].pos == clipList[j].pos) {
                subjectList[i].link = j;
                clipList[j].link = i;
                break;
            }
        }
    }

    QList<QVector<QPointF>> resultPolygons;
    for (int i = 0; i < subjectList.size(); ++i) {
        if (subjectList[i].isIntersection && subjectList[i].isStartNode && !subjectList[i].visited) {
            QVector<QPointF> cur;
            int idx = i;
            bool onSubject = true;
            do {
                VertexData* v = onSubject ? &subjectList[idx] : &clipList[idx];
                v->visited = true;
                cur.append(v->pos);
                if (v->isIntersection && v->link != -1) { onSubject = !onSubject; idx = v->link; }
                idx = (idx + 1) % (onSubject ? subjectList.size() : clipList.size());
            } while (cur.first() != cur.back() || cur.size() < 2);
            cur.pop_back();
            if (cur.size() >= 3) resultPolygons.append(cur);
        }
    }


    if (!resultPolygons.isEmpty()) {
        for (const auto& poly : resultPolygons) {
            QList<QPoint> edge;
            edge.reserve(poly.size());
            for (const QPointF& p : poly) edge.append(QPoint(qRound(p.x()), qRound(p.y())));
            drawPolygonOutline(edge, QBrush(Qt::green));
        }
    }
    scene->update();
}



void MainWindow::onClearAll()
{
    scene->clearCells();
    polygonVertices.clear();
    originalPolygonVertices.clear();
    hasPolygon = false;
    isSelectingVertices = false;
    hasClippingWindow = false;
    isDrawingWindow = false;
    windowClickCount = 0;
    scene->update();
}


void MainWindow::bresenhamLine(const QPoint& p1, const QPoint& p2, const QBrush& brush, bool collect)
{
    int x1 = p1.x(), y1 = p1.y(), x2 = p2.x(), y2 = p2.y();
    int dx = abs(x2 - x1), dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy;

    while (true) {
        QPoint q(x1, y1);
        scene->paintCell(q, brush);
        if (collect) polygonPixels.insert(q);

        if (x1 == x2 && y1 == y2) break;
        int e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x1 += sx; }
        if (e2 < dx) { err += dx; y1 += sy; }
    }
}


void MainWindow::drawPolygonOutline(const QList<QPoint>& vertices, const QBrush& brush, bool collect)
{
    if (vertices.size() < 2) return;

    for (const QPoint& v : vertices) {
        scene->paintCell(v, brush);
        if (collect) polygonPixels.insert(v);
    }

    for (int i = 0; i < vertices.size(); i++) {
        int nextIndex = (i + 1) % vertices.size();
        bresenhamLine(vertices[i], vertices[nextIndex], brush, collect);
    }
}


void MainWindow::drawRectangle(const QRect& rect, const QBrush& brush)
{
    bresenhamLine(rect.topLeft(), rect.topRight(), brush);
    bresenhamLine(rect.topRight(), rect.bottomRight(), brush);
    bresenhamLine(rect.bottomRight(), rect.bottomLeft(), brush);
    bresenhamLine(rect.bottomLeft(), rect.topLeft(), brush);
}

void MainWindow::drawRectangle(const QRect& rect, const QBrush& brush, int thickness)
{
    for (int i = 0; i < thickness; ++i) {
        bresenhamLine(QPoint(rect.left() + i, rect.top() + i), QPoint(rect.right() - i, rect.top() + i), brush);
        bresenhamLine(QPoint(rect.left() + i, rect.bottom() - i), QPoint(rect.right() - i, rect.bottom() - i), brush);
        bresenhamLine(QPoint(rect.left() + i, rect.top() + i), QPoint(rect.left() + i, rect.bottom() - i), brush);
        bresenhamLine(QPoint(rect.right() - i, rect.top() + i), QPoint(rect.right() - i, rect.bottom() - i), brush);
    }
}


void MainWindow::fillWindow(const QRect& rect, const QColor& color, int alpha)
{
    for (int x = rect.left(); x <= rect.right(); ++x)
        for (int y = rect.top(); y <= rect.bottom(); ++y)
            scene->paintCell(QPoint(x, y), QBrush(Qt::transparent));
    QColor translucent = color;
    translucent.setAlpha(alpha);
    for (int x = rect.left(); x <= rect.right(); ++x)
        for (int y = rect.top(); y <= rect.bottom(); ++y)
            scene->paintCell(QPoint(x, y), QBrush(translucent));
}


void MainWindow::clearPolygon()
{
    if (polygonVertices.size() < 2) return;
    polygonPixels.clear();

    for (const QPoint& v : polygonVertices) {
        bool skip = false;
        if (hasClippingWindow) {
            if (clippingWindow.contains(v)) skip = true;
            bool onLeft = (v.x() == clippingWindow.left() && v.y() >= clippingWindow.top() && v.y() <= clippingWindow.bottom());
            bool onRight = (v.x() == clippingWindow.right() && v.y() >= clippingWindow.top() && v.y() <= clippingWindow.bottom());
            bool onTop = (v.y() == clippingWindow.top() && v.x() >= clippingWindow.left() && v.x() <= clippingWindow.right());
            bool onBottom = (v.y() == clippingWindow.bottom() && v.x() >= clippingWindow.left() && v.x() <= clippingWindow.right());
            if (onLeft || onRight || onTop || onBottom) skip = true;
        }
        if (!skip) scene->paintCell(v, QBrush(Qt::transparent));
    }

    for (int i = 0; i < polygonVertices.size(); i++) {
        int nextIndex = (i + 1) % polygonVertices.size();
        QPoint p1 = polygonVertices[i];
        QPoint p2 = polygonVertices[nextIndex];
        int x1 = p1.x(), y1 = p1.y(), x2 = p2.x(), y2 = p2.y();
        int dx = std::abs(x2 - x1), dy = std::abs(y2 - y1);
        int sx = (x1 < x2) ? 1 : -1;
        int sy = (y1 < y2) ? 1 : -1;
        int err = dx - dy;
        while (true) {
            bool skip = false;
            if (hasClippingWindow) {
                if (x1 >= clippingWindow.left() && x1 <= clippingWindow.right() &&
                    y1 >= clippingWindow.top()  && y1 <= clippingWindow.bottom()) skip = true;
                bool onLeft = (x1 == clippingWindow.left() && y1 >= clippingWindow.top() && y1 <= clippingWindow.bottom());
                bool onRight = (x1 == clippingWindow.right() && y1 >= clippingWindow.top() && y1 <= clippingWindow.bottom());
                bool onTop = (y1 == clippingWindow.top() && x1 >= clippingWindow.left() && x1 <= clippingWindow.right());
                bool onBottom = (y1 == clippingWindow.bottom() && x1 >= clippingWindow.left() && x1 <= clippingWindow.right());
                if (onLeft || onRight || onTop || onBottom) skip = true;
            }
            if (!skip) scene->paintCell(QPoint(x1, y1), QBrush(Qt::transparent));
            if (x1 == x2 && y1 == y2) break;
            int e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x1 += sx; }
            if (e2 < dx) { err += dx; y1 += sy; }
        }
    }
}


void MainWindow::clearWindow()
{
    if (hasClippingWindow) {
        for (int x = clippingWindow.left(); x <= clippingWindow.right(); ++x)
            for (int y = clippingWindow.top(); y <= clippingWindow.bottom(); ++y)
                scene->paintCell(QPoint(x, y), QBrush(Qt::transparent));
        drawRectangle(clippingWindow, QBrush(Qt::transparent));
    }
}

bool MainWindow::isInside(const QPointF& point, EdgePosition edge, const QRect& clipRect)
{
    switch (edge) {
    case LEFT_EDGE:
        return point.x() >= clipRect.left();
    case RIGHT_EDGE:
        return point.x() <= clipRect.right();
    case BOTTOM_EDGE:
        return point.y() >= clipRect.top();
    case TOP_EDGE:
        return point.y() <= clipRect.bottom();
    }
    return false;
}

QPointF MainWindow::getIntersection(const QPointF& p1, const QPointF& p2, EdgePosition edge, const QRect& clipRect)
{
    double x1 = p1.x(), y1 = p1.y(), x2 = p2.x(), y2 = p2.y();
    double x = 0, y = 0;

    switch (edge) {

    case LEFT_EDGE:
        x = clipRect.left();
        if (x2 != x1) y = y1 + (y2 - y1) * (x - x1) / (x2 - x1); else y = y1;
        y = std::max<double>(clipRect.top(), std::min<double>(clipRect.bottom(), std::round(y)));
        return QPointF(x, y);

    case RIGHT_EDGE:
        x = clipRect.right();
        if (x2 != x1) y = y1 + (y2 - y1) * (x - x1) / (x2 - x1); else y = y1;
        y = std::max<double>(clipRect.top(), std::min<double>(clipRect.bottom(), std::round(y)));
        return QPointF(x, y);

    case BOTTOM_EDGE:
        y = clipRect.top();
        if (y2 != y1) x = x1 + (x2 - x1) * (y - y1) / (y2 - y1); else x = x1;
        x = std::max<double>(clipRect.left(), std::min<double>(clipRect.right(), std::round(x)));
        return QPointF(x, y);

    case TOP_EDGE:
        y = clipRect.bottom();
        if (y2 != y1) x = x1 + (x2 - x1) * (y - y1) / (y2 - y1); else x = x1;
        x = std::max<double>(clipRect.left(), std::min<double>(clipRect.right(), std::round(x)));
        return QPointF(x, y);
    }
    return QPointF();
}


QList<QPointF> MainWindow::clipAgainstEdge(const QList<QPointF>& inputVertices, EdgePosition edge, const QRect& clipRect)
{
    QList<QPointF> outputVertices;

    if (inputVertices.isEmpty()) {
        return outputVertices;
    }

    QPointF previousVertex = inputVertices.last();

    for (const QPointF& currentVertex : inputVertices) {
        bool currentInside = isInside(currentVertex, edge, clipRect);
        bool previousInside = isInside(previousVertex, edge, clipRect);

        if (currentInside) {
            if (!previousInside) {
                QPointF intersection = getIntersection(previousVertex, currentVertex, edge, clipRect);
                outputVertices.append(intersection);
            }
            outputVertices.append(currentVertex);
        }
        else if (previousInside) {
            QPointF intersection = getIntersection(previousVertex, currentVertex, edge, clipRect);
            outputVertices.append(intersection);
        }

        previousVertex = currentVertex;
    }

    return outputVertices;
}

QList<QPointF> MainWindow::sutherlandHodgemanClip(const QList<QPointF>& polygon, const QRect& clipRect)
{
    QList<QPointF> outputPolygon = polygon;
    outputPolygon = clipAgainstEdge(outputPolygon, LEFT_EDGE, clipRect);

    if (outputPolygon.isEmpty()) return outputPolygon;
    outputPolygon = clipAgainstEdge(outputPolygon, RIGHT_EDGE, clipRect);

    if (outputPolygon.isEmpty()) return outputPolygon;
    outputPolygon = clipAgainstEdge(outputPolygon, BOTTOM_EDGE, clipRect);

    if (outputPolygon.isEmpty()) return outputPolygon;
    outputPolygon = clipAgainstEdge(outputPolygon, TOP_EDGE, clipRect);

    if (outputPolygon.isEmpty()) return outputPolygon;

    QList<QPointF> snapped;
    snapped.reserve(outputPolygon.size());
    for (const QPointF& p : outputPolygon) {
        QPointF q(qRound(p.x()), qRound(p.y()));
        if (snapped.isEmpty() || q != snapped.last()) snapped.append(q);
    }
    if (snapped.size() >= 2 && snapped.first() == snapped.last()) snapped.removeLast();
    return snapped;
}


QPointF MainWindow::computeLineIntersection(const QPointF& p1, const QPointF& p2, const QPointF& p3, const QPointF& p4)
{
    double denom = (p1.x() - p2.x()) * (p3.y() - p4.y()) - (p1.y() - p2.y()) * (p3.x() - p4.x());

    if (qFuzzyIsNull(denom)) {
        return QPointF();
    }

    double t = ((p1.x() - p3.x()) * (p3.y() - p4.y()) - (p1.y() - p3.y()) * (p3.x() - p4.x())) / denom;
    double u = -((p1.x() - p2.x()) * (p1.y() - p3.y()) - (p1.y() - p2.y()) * (p1.x() - p3.x())) / denom;

    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
        return QPointF(p1.x() + t * (p2.x() - p1.x()), p1.y() + t * (p2.y() - p1.y()));
    }

    return QPointF();
}


double MainWindow::distance(const QPointF& p1, const QPointF& p2)
{
    return std::sqrt(std::pow(p2.x() - p1.x(), 2) + std::pow(p2.y() - p1.y(), 2));
}


bool MainWindow::isPointInsidePolygon(const QPointF& point, const QList<QPointF>& polygon)
{
    int crossings = 0;
    int n = polygon.size();

    for (int i = 0; i < n; i++) {
        const QPointF& p1 = polygon[i];
        const QPointF& p2 = polygon[(i + 1) % n];

        if (((p1.y() <= point.y() && point.y() < p2.y()) ||
             (p2.y() <= point.y() && point.y() < p1.y())) &&
            point.x() < (p2.x() - p1.x()) * (point.y() - p1.y()) / (p2.y() - p1.y()) + p1.x()) {
            crossings++;
        }
    }

    return (crossings % 2 == 1);
}
	\end{lstlisting}
	
	main.cpp
	\begin{lstlisting}[style=cgstyle,language=C++]
		#include "mainwindow.h"
		
		#include <QApplication>
		
		int main(int argc, char *argv[])
		{
			QApplication a(argc, argv);
			MainWindow w;
			w.show();
			return a.exec();
		}
		
	\end{lstlisting}
	
	% \clearpage
\subsubsection*{Outputs}

% --- Line clipping examples 1 & 2 ---
\begin{figure}[h]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/line_clipping1}
        \caption{line\_clipping1}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/line_clipping2}
        \caption{line\_clipping2}
    \end{subfigure}
\end{figure}

% --- Line clipping examples 3 & 4 ---
\begin{figure}[h]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/line_clipping3}
        \caption{line\_clipping3}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/line_clipping4}
        \caption{line\_clipping4}
    \end{subfigure}
\end{figure}

% --- Cohen–Sutherland fail & polygon clipping ---
\begin{figure}[h]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/cohen_sutherland_fail}
        \caption{cohen\_sutherland\_fail}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/polygon_clipping}
        \caption{polygon\_clipping}
    \end{subfigure}
\end{figure}
\clearpage

% --- Weiler–Atherton pass (single on its own line) ---
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{images/weiler_atherton_pass}
    \caption{weiler\_atherton\_pass}
\end{figure}

	
	% \clearpage
    \subsubsection*{Output Explanation}

For line clipping, both Cohen--Sutherland and Liang--Barsky correctly produce the visible portion of the segment inside the rectangular window. In my implementation, Cohen--Sutherland iteratively moves endpoints towards the window using region codes, while Liang--Barsky directly computes the entering and leaving parameters along the line. Since Liang--Barsky works purely with a single parametric interval \([t_0,t_1]\) and does not repeatedly subdivide the line into segments, it is computationally more efficient for the same clipping task.

For polygon clipping, Sutherland--Hodgeman works correctly for convex polygons, but for concave inputs it may generate artefacts such as an extra connecting strip that incorrectly links what should be two separate clipped polygons. In contrast, the Weiler--Atherton implementation explicitly tracks intersection nodes and alternates traversal between the subject and clip polygons, so it correctly produces multiple disjoint clipped regions for concave polygons without any spurious connecting edges.

	\clearpage
	% -------- ASSIGNMENT 7 --------
	\subsection*{Assignment 7: Cubic Bézier Curve}
	\addcontentsline{toc}{subsection}{Assignment 7: Cubic Bézier Curve}
	
	\subsubsection*{Problem Statement (Optional)}
	Implement a cubic Bézier curve drawing algorithm for a given set of control points.
	
	\subsubsection*{Code and Theoretical Explanation}

In this assignment, I implemented a cubic Bézier curve drawing routine starting from the general spline formulation. A Bézier curve of degree $n$ is defined for $n+1$ control points
\[
p_k = (x_k, y_k),\quad k = 0,1,\dots,n
\]
by the parametric position vector
\[
P(u) = \sum_{k=0}^{n} p_k\, BEZ_{k,n}(u), \qquad 0 \le u \le 1,
\]
where the blending (basis) functions $BEZ_{k,n}(u)$ are the Bernstein polynomials
\[
BEZ_{k,n}(u) = C(n,k)\, u^k (1-u)^{n-k}, \qquad
C(n,k) = \frac{n!}{k!(n-k)!}.
\]
Writing $p_k = (x_k, y_k)$, the curve components are
\[
x(u) = \sum_{k=0}^{n} x_k\, BEZ_{k,n}(u), \qquad
y(u) = \sum_{k=0}^{n} y_k\, BEZ_{k,n}(u).
\]

For a cubic Bézier curve we use $n=3$ and four control points $p_0, p_1, p_2, p_3$. The blending functions simplify to
\[
\begin{aligned}
BEZ_{0,3}(u) &= (1-u)^3,\\
BEZ_{1,3}(u) &= 3u(1-u)^2,\\
BEZ_{2,3}(u) &= 3u^2(1-u),\\
BEZ_{3,3}(u) &= u^3,
\end{aligned}
\]
so the curve becomes
\[
P(u) = (1-u)^3 p_0 + 3u(1-u)^2 p_1 + 3u^2(1-u)p_2 + u^3 p_3.
\]
This construction has several important properties: the curve starts and ends at the first and last control points ($P(0)=p_0$, $P(1)=p_3$); it is contained inside the convex hull of the control points (all $BEZ_{k,3}(u)\ge 0$ and $\sum_k BEZ_{k,3}(u)=1$); and its end tangents are aligned with the first and last edges of the control polygon:
\[
P'(0) = 3(p_1 - p_0), \qquad P'(1) = 3(p_3 - p_2).
\]

The implementation follows this mathematical formulation directly. The helper function
\begin{lstlisting}[style=cgstyle,language=C++]
long long choose(int n, int k) { ... }
\end{lstlisting}
computes the binomial coefficient $C(n,k)$, which appears in the Bernstein basis. In the drawing routine
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::drawBezierCurve(const QVector<QPoint>& control_points) {
    int n = control_points.size() - 1;
    double u = 0, step = 1.0 / 730.0;
    ...
    while (u <= 1) {
        double xf = 0, yf = 0;
        for (int k = 0; k <= n; k++) {
            xf += pow(u, k) * pow(1 - u, n - k)
                  * control_points[k].x() * choose(n, k);
            yf += pow(u, k) * pow(1 - u, n - k)
                  * control_points[k].y() * choose(n, k);
        }
        int x = static_cast<int>(0.5 + xf);
        int y = static_cast<int>(0.5 + yf);
        ...
        to_fill.append({x, y});
        u += step;
    }
    addPoints(to_fill, QColor(200, 150, 20));
}
\end{lstlisting}
I first set $n = \texttt{control\_points.size()} - 1$, so with four control points we obtain a cubic curve ($n=3$). For each parameter value $u \in [0,1]$ (sampled in small increments of \texttt{step}), I evaluate the Bézier equations
\[
x(u) = \sum_{k=0}^{n} C(n,k)\,u^k(1-u)^{n-k} x_k, \qquad
y(u) = \sum_{k=0}^{n} C(n,k)\,u^k(1-u)^{n-k} y_k
\]
by accumulating \texttt{xf} and \texttt{yf} in the inner loop. The term
\begin{lstlisting}[style=cgstyle,language=C++]
pow(u, k) * pow(1 - u, n - k) * choose(n, k)
\end{lstlisting}
is exactly $BEZ_{k,n}(u)$, and multiplying by the control point coordinates \texttt{control\_points[k].x()} and \texttt{control\_points[k].y()} implements the weighted sum that defines $P(u)$.

The floating-point positions $(x_f, y_f)$ are rounded to the nearest integer grid cells using
\begin{lstlisting}[style=cgstyle,language=C++]
int x = static_cast<int>(0.5 + xf);
int y = static_cast<int>(0.5 + yf);
\end{lstlisting}
to map the continuous curve to discrete pixels. To avoid redundant overplotting of the same grid cell when successive $u$ samples quantise to identical integer coordinates, the code skips appending points whose $(x,y)$ coincide with the previous sample. Finally, all sampled points are rendered at once via \texttt{addPoints}, producing a smooth visual approximation of the continuous cubic Bézier curve defined by the control polygon.

\includegraphics[width=0.45\textwidth]{images/bezier1}
	
	\subsubsection*{Code}
    Cubic Bezier Curve:
	\begin{lstlisting}[style=cgstyle,language=C++]
long long choose(int n, int k) {
    if (k < 0 || k > n) return 0;
    if (k == 0 || k == n) return 1;

    if (k > n / 2) k = n - k;

    long long res = 1;
    for (int i = 1; i <= k; ++i)
        res = res * (n - i + 1) / i;
    return res;
}
void MainWindow::drawBezierCurve(const QVector<QPoint>& control_points) {
    int n = control_points.size() - 1, prev_x, prev_y;
    bool first_it = true;
    double u = 0, step = 1.0 / 730.0;
    QVector<QPoint> to_fill;
    to_fill.reserve(static_cast<int>(0.5 + (1.0 / step)));
    while (u <= 1) {
        double xf = 0, yf = 0;
        for (int k = 0; k <= n; k++) {
            xf += pow(u, k) * pow(1-u, n-k) * control_points[k].x() * choose(n,k);
            yf += pow(u, k) * pow(1-u, n-k) * control_points[k].y() * choose(n,k);
        }
        int x = static_cast<int>(0.5 + xf), y = static_cast<int>(0.5 + yf);
        if ((!first_it) && (x == prev_x) && (y == prev_y)) {
            u += step;
            continue;
        }
        if (first_it) first_it = false;
        prev_x = x;
        prev_y = y;
        to_fill.append({x, y});
        u += step;
    }
    addPoints(to_fill, QColor(200, 150, 20));
}
	\end{lstlisting}
	% \clearpage
	\subsubsection*{Outputs}

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/7.1 - Bezier Curve with 4 control points.png}
        \caption{Bezier Curve with 4 control points}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/7.2 - Bezier Curve with 6 control points showing poor local contribution.png}
        \caption{Bezier Curve with 6 control points}
    \end{subfigure}
\end{figure}

	
    \subsubsection*{Output Explanation}

For a given set of control points, the implementation correctly evaluates the cubic Bézier formulation and plots a smooth curve that starts at the first control point, ends at the last control point, and follows the general shape of the control polygon. With four control points, the curve shows good visual smoothness and intuitive control: moving the inner control points changes the local shape while preserving endpoint interpolation and $C^1$ continuity at the ends.

When I increase the number of control points (e.g.\ to six, yielding a higher-degree Bézier), the curve is still drawn correctly, but each control point influences a comparatively large portion of the curve. As a result, the local contributions of individual control points are low: small changes to any one control point tend to disturb a wide region of the curve, illustrating the loss of strong local control for higher-degree Bézier representations.

    \clearpage

	
\end{document}
