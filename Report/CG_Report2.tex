\documentclass[11pt,a4paper]{article}

% ---------------------- BASIC PAGE SETUP ----------------------
\usepackage[a4paper,inner=2cm,outer=2cm,top=2.5cm,bottom=2.5cm]{geometry}

% ---------------------- FONTS ----------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[default]{lato}            % cleaner, rounder sans-serif
\usepackage[scaled=0.9]{inconsolata} % monospace for code
\renewcommand*\familydefault{\sfdefault}

\usepackage{setspace}
\usepackage{lmodern}
\usepackage{float}
\onehalfspacing

\usepackage{microtype} % nicer letterspacing

% ---------------------- COLORS / LINKS ----------------------
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{amsmath,amssymb}
\usepackage{amsthm}
\usepackage{subcaption}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=cyan!70!black,
  urlcolor=cyan!70!black,
  citecolor=cyan!70!black,
  pdfauthor={Group 1},
  pdftitle={Computer Graphics Report – Part 2: Project Report},
  pdfcreator={PDFLaTeX},
  pdfproducer={PDFLaTeX}
}

% ---------------------- HEADER / FOOTER ----------------------
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\headrule}{
  \hbox to\headwidth{
    \color{cyan!70!black}\leaders\hrule height 0.4pt\hfill
  }
}
\lhead{\textbf{Computer Graphics Report – Part 2}}
\rhead{\textbf{Page \thepage}}
\fancyfoot{} % no footer text

% ---------------------- CODE LISTINGS (LIGHT BOXES) ----------------------
\usepackage{listings}

\definecolor{codebg}{RGB}{235,235,235}
\definecolor{codeframe}{RGB}{0,180,200}
\definecolor{codekeyword}{RGB}{0,0,160}
\definecolor{codecomment}{RGB}{0,128,0}
\definecolor{codestring}{RGB}{160,80,0}
\definecolor{codelinenum}{RGB}{110,110,120}
\definecolor{codefg}{RGB}{0,0,0}

\lstdefinestyle{cgstyle}{
  backgroundcolor=\color{codebg},
  frame=single,
  rulecolor=\color{codeframe},
  frameround=tttt,
  basicstyle=\ttfamily\footnotesize\color{codefg},
  keywordstyle=\color{codekeyword}\bfseries,
  commentstyle=\color{codecomment}\itshape,
  stringstyle=\color{codestring},
  identifierstyle=\color{codefg},
  numberstyle=\tiny\color{codelinenum},
  numbers=left,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  tabsize=4,
  xleftmargin=1.8em,
  framexleftmargin=1.4em
}

% ---------------------- BASIC MACROS (OPTIONAL) ----------------------
\newcommand{\ra}[1]{\renewcommand{\arraystretch}{#1}}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{defn}[thm]{Definition}
\newtheorem{rem}[thm]{Remark}
\numberwithin{equation}{section}

% ============================================================
%                         DOCUMENT
% ============================================================
\begin{document}

% ---------------------- INDEX / TOC ----------------------
\pagenumbering{roman}
\setcounter{page}{1}

\tableofcontents
\clearpage

% ---------------------- CONTRIBUTIONS ----------------------
\section*{Contributions (Part 2: Group Project)}

\begin{itemize}
  \item \textbf{Shinjan Roy (002310501083):}
  \begin{itemize}
    \item Procedural Terrain Generation
    \item Car physics
    \item Spring model
    \item Collision Detection
    \item Stages and unlocking
  \end{itemize}
  \item \textbf{Souradeep De (002310501084):}
  \begin{itemize}
    \item Wheel physics
    \item Rotational Dynamics
  \end{itemize}
  \item \textbf{Arko Dasgupta (002310501085):}
  \begin{itemize}
    \item Game Introduction Screen.
    \item Game Over Screen
    \item Pausing, Resuming and Restarting Logics
    \item Persistent Coin System and Points scoring
  \end{itemize}
  \item \textbf{Arjeesh Palai (002310501086):}
  \begin{itemize}
    \item Camera Stabilization.
    \item Coin, Fuel, Nitro Feature Integration.
    \item Flip Tracker.
    \item Key Stroke Logging and HUD.
    \item Assets \& Media Integration.
    \item Scoreboard UI/UX Design and Management.
  \end{itemize}
\end{itemize}

\clearpage

% ---------------------- MAIN CONTENT (PART 2 ONLY) ----------------------
\pagenumbering{arabic}
\setcounter{page}{1}

% ============================================================
%                PART 2: GROUP GRAPHICS PROJECT
% ============================================================
\section*{Part 2: Braking-Bad}
\addcontentsline{toc}{section}{Part 2: Braking-Bad}

% ------------------------------------------------------------
% SECTION 1: ABSTRACT & INTRODUCTION
% ------------------------------------------------------------
\subsection*{1. Abstract \& Introduction}
\addcontentsline{toc}{subsection}{1. Abstract \& Introduction}

\subsubsection*{Abstract}
This project implements a physics-based driving simulation game inspired by "Hill Climb Racing." Utilizing the Qt framework and C++, the application demonstrates fundamental computer graphics concepts including rasterization, 2D geometric transformations, and viewport clipping. The primary objective is to render a dynamic terrain and a controllable vehicle on a custom raster grid, handling physics interactions in real-time.

\subsubsection*{Introduction}
\textbf{Project Overview:} The application features a 2D side-scrolling environment where the player controls a vehicle traversing procedurally generated terrain.
\begin{itemize}
  \item \textbf{Objectives:} To apply affine transformations (translation, rotation) for vehicle movement and use line-drawing algorithms (Bresenham/DDA) for terrain rendering.
  \item \textbf{Scope:} The system handles user input for acceleration/braking, calculates gravity and suspension physics, and performs collision detection between the vehicle polygon and the terrain polyline.
\end{itemize}

% ------------------------------------------------------------
% SECTION 2: THEORETICAL BACKGROUND
% ------------------------------------------------------------
\subsection*{2. Theoretical Background}
\addcontentsline{toc}{subsection}{2. Theoretical Background}

\subsubsection*{Coordinate Systems \& Transformations}
The game world uses a logical coordinate system which is mapped to the device viewport. The vehicle is defined by a set of local vertices $V_{local}$ which are transformed to world coordinates $V_{world}$ using an affine transformation matrix $M$.

\[
  M = T(dx, dy) \cdot R(\theta) \cdot S(sx, sy)
\]
\[
  \begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} = 
  \begin{bmatrix} \cos\theta & -\sin\theta & dx \\ \sin\theta & \cos\theta & dy \\ 0 & 0 & 1 \end{bmatrix}
  \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}
\]
Where $(dx, dy)$ represents the vehicle's position and $\theta$ represents its tilt relative to the terrain slope. 

\subsubsection*{Bresenham Line Drawing Algorithm}
Bresenham's algorithm is used to rasterize a straight line segment between two points $(x_1,y_1)$ and $(x_2,y_2)$ using only integer arithmetic. For a line with $0 \le m \le 1$, we define
\[
\Delta x = x_2 - x_1,\qquad \Delta y = y_2 - y_1,\qquad m = \frac{\Delta y}{\Delta x}.
\]
Starting from $(x_0,y_0) = (x_1,y_1)$, the decision parameter is initialized as
\[
p_0 = 2\Delta y - \Delta x.
\]
At step $k$, we always increment $x$ by one:
\[
x_{k+1} = x_k + 1,
\]
and choose between staying on the same scanline or moving up one pixel:
\[
\text{if } p_k < 0:\quad y_{k+1} = y_k,\quad p_{k+1} = p_k + 2\Delta y,
\]
\[
\text{else}:\quad y_{k+1} = y_k + 1,\quad p_{k+1} = p_k + 2\Delta y - 2\Delta x.
\]
Each $(x_{k+1},y_{k+1})$ is plotted, producing an efficient, integer-based approximation of the ideal line.


\subsubsection*{Midpoint Circle Algorithm}
	The wheels and circular HUD icons (coins, fuel etc.) are drawn using an integer midpoint circle algorithm. A circle of radius $r$ centred at the origin is described by
	\[
	f(x,y) = x^{2} + y^{2} - r^{2}.
	\]
	Starting from $(x_0,y_0) = (0,r)$ in the first octant, a decision parameter
	\[
	p_0 = 1 - r
	\]
	is used to choose between the next pixel to the East $(x_k+1, y_k)$ or South-East $(x_k+1, y_k-1)$. At step $k$:
	\[
	\text{if } p_k < 0 \Rightarrow (x_{k+1},y_{k+1}) = (x_k+1,y_k),\quad
	p_{k+1} = p_k + 2x_{k+1} + 1,
	\]
	\[
	\text{else } (x_{k+1},y_{k+1}) = (x_k+1,y_k-1),\quad
	p_{k+1} = p_k + 2x_{k+1} - 2y_{k+1} + 1.
	\]
	Using eight-way symmetry, all octants are generated from this octant. In the project, the boundary points from the midpoint algorithm are extended into short horizontal spans on each scan-line, effectively producing filled discs rather than just circle outlines.
	
	\subsubsection*{Scan-Line Polygon Filling}
	The car body and several HUD elements are rendered as filled polygons using a scan-line fill algorithm. For a simple polygon with vertices $(x_i,y_i)$, we consider each integer scan-line $y$ in the range $[y_{\min},y_{\max}]$. For every edge $E=(x_1,y_1)\rightarrow(x_2,y_2)$ that intersects this $y$ (i.e.\ $y \in [\min(y_1,y_2),\max(y_1,y_2))$ and $y_1 \neq y_2$), the $x$-intersection is
	\[
	x(y) = x_1 + (y - y_1)\,\frac{x_2 - x_1}{y_2 - y_1}.
	\]
	The implementation builds an edge table storing for each edge its upper $y_{\max}$, starting $x$ at $y_{\min}$ and inverse slope $1/m = \Delta x / \Delta y$. During filling, an active edge list is maintained per scan-line, sorted by current $x_{\text{curr}}$. Intersections are then taken in pairs $(x_1,x_2)$ and all integer pixels between them are filled using a simple loop. After each scan-line, $x_{\text{curr}}$ is incremented by $1/m$ for every active edge. This is the standard edge-table/active-edge realisation of scan-line polygon filling used in class.

% ------------------------------------------------------------
% SECTION 4: IMPLEMENTATION DETAILS
% ------------------------------------------------------------
\subsection*{3. Implementation Details}
\addcontentsline{toc}{subsection}{3. Implementation Details}

\subsubsection*{Feature: Procedural Terrain Generation and Rasterization}
\textbf{Relevant classes and functions:} \texttt{MainWindow::generateInitialTerrain()}, 
\newline \texttt{MainWindow::ensureAheadTerrain()}, \texttt{MainWindow::rasterizeSegmentToHeightMapWorld()},
\newline\texttt{MainWindow::drawFilledTerrain()}.

I designed the terrain system to function as an infinite, procedurally generated 2D height map. Rather than storing a massive array of world coordinates, the terrain is generated just-in-time as the player progresses. The core of my algorithm relies on a discrete stochastic process that updates the slope of the ground segments, ensuring a balance between randomness (to keep the track interesting) and stability (to keep the track drivable and to prevent the height from blowing up in either the positive or negative directions).

\paragraph{Stochastic Slope Evolution.}
I model the terrain as a sequence of connected line segments $L_0, L_1, \dots, L_k$. Let the endpoint of the $k$-th segment be denoted by the tuple $(x_k, y_k)$ in world space. The horizontal step size is fixed at a constant $\Delta x = \texttt{STEP}$. The vertical position $y_{k+1}$ is determined by a state variable $m_k$ representing the current slope intensity.

To calculate the next slope $m_{k+1}$, I utilize a recurrence relation that combines a random perturbation with a restoring force. Let $\xi \sim \mathcal{U}(0, 1)$ be a uniform random variable derived from the Mersenne Twister engine (`std::mt19937`). Let $D$ be the difficulty coefficient and $H$ be the height of the viewport. The update rule is as follows:
\[
  m_{\text{temp}} = m_k + D \cdot \left( \xi - \left(1 - \frac{\tau}{100}\right) \frac{y_k}{H} \right),
\]
where $\tau$ is a terrain height parameter. The term $-\frac{y_k}{H}$ acts as a negative feedback loop (a "spring" force) that pushes the terrain downward if it gets too high and upward if it gets too low, preventing the track from drifting off-screen.

I then clamp the slope to prevent vertical walls that would stop the vehicle:
\[
  m_{k+1} = \text{clamp}(m_{\text{temp}}, -m_{\max}, m_{\max}).
\]

\paragraph{Non-Linear Vertical Integration.}
To determine the vertical change $\Delta y$, I do not map the slope linearly. Instead, a non-linearity factor $\gamma$ (variable \texttt{m\_irregularity}) is applied to exaggerate steep climbs and flatten gentle slopes. The height of the next vertex is computed as:
\[
  y_{k+1} = y_k + \left\lfloor m_{k+1} \cdot |m_{k+1}|^\gamma \cdot \Delta x \right\rceil.
\]
This approach creates a "bouncy" terrain feel that becomes progressively more chaotic as the level difficulty ($D$ and $\gamma$) increases over time.

\paragraph{Discrete Height Map Rasterization.}
Once a segment from $(x_k, y_k)$ to $(x_{k+1}, y_{k+1})$ is generated, I rasterize it into a hash-based sparse height map. Since the game world is a pixel grid, I map the continuous line segment to discrete grid coordinates $(g_x, g_y)$.
For a segment defined by the horizontal range $[x_1, x_2]$, and for every grid column $g_x$ such that $x_1 \le g_x \cdot s_{\text{px}} \le x_2$ (where $s_{\text{px}}$ is the size of the pixels), I compute the interpolated height $w_y$:
\[
  t = \frac{(g_x \cdot s_{\text{px}}) - x_1}{x_2 - x_1}, \quad t \in [0, 1]
\]
\[
  w_y = y_1 + t (y_2 - y_1).
\]
The integer grid height is then stored in a hash map:
\[
  H[g_x] = \left\lfloor \frac{w_y}{s_{\text{px}}} + 0.5 \right\rfloor.
\]
This structure `QHash<int, int>` allows $O(1)$ lookups for collision detection and rendering while handling an effectively infinite X-axis. I also implemented a pruning mechanism (`pruneHeightMap`) to remove keys $g_x < x_{\text{camera}}$ to manage memory usage.

\paragraph{Procedural Rendering and Texturing.}
To render the terrain, I iterate through the visible grid columns on the screen. For a column $g_x$, I retrieve the ground height $g_y = H[g_x]$. If the ground is visible, I draw a vertical span of pixels from $g_y$ down to the bottom of the screen.

To avoid the repetitive look of standard tiling textures, I implemented a procedural shading function based on spatial hashing. For any block in the world grid $(B_x, B_y)$, I compute a deterministic hash:
\[
  h(B_x, B_y) = ( (k_1 \oplus B_x) \cdot k_2 ) \oplus B_y \dots
\]
This hash is used to index into a color palette (e.g., dirt or grass shades). This ensures that a specific block at world coordinate $(1000, 50)$ always renders with the same color pattern, even if the camera moves away and returns, without needing to store texture data in memory.

\bigskip
\noindent\textbf{Core code snippets.} The following excerpts from \texttt{mainwindow.cpp} demonstrate the generation loop, the slope mathematics, and the rasterization logic.

\begin{lstlisting}[style=cgstyle,language=C++]
// mainwindow.cpp - Terrain Generation Logic

void MainWindow::generateInitialTerrain() {
    int currentWorldX = m_lastX;
    m_lastY = height() / 2;

    // Iterate in steps to fill the initial screen width
    for (int i = Constants::STEP; i <= width() + Constants::STEP; i += Constants::STEP) {

        // Mathematical model for slope evolution with restoring force
        m_slope += (m_dist(m_rng) - (1 - m_terrain_height/100) * static_cast<float>(m_lastY) / height()) * m_difficulty;
        
        // Clamping to safe limits
        m_slope = std::clamp(m_slope, -(float)Constants::MAX_SLOPE[level_index], (float)Constants::MAX_SLOPE[level_index]);
        
        // Non-linear height integration
        const int newY = m_lastY + std::lround(m_slope * std::pow(std::abs(m_slope), m_irregularity) * Constants::STEP);

        // Create segment and rasterize
        Line seg(i - Constants::STEP, m_lastY, i, newY);
        m_lines.append(seg);
        rasterizeSegmentToHeightMapWorld(seg.getX1(), m_lastY, seg.getX2(), newY);

        // Prop spawning logic (omitted for brevity)...

        m_lastY = newY;
        m_lastX = i;

        // Dynamic difficulty adjustment
        m_difficulty += Constants::DIFFICULTY_INCREMENT[level_index];
        m_irregularity += Constants::IRREGULARITY_INCREMENT[level_index];
    }
}

void MainWindow::ensureAheadTerrain(int worldX) {
    // Infinite generation: Keep adding segments if the camera sees the edge
    while (m_lastX < worldX) {
        m_slope += (m_dist(m_rng) - (1 - m_terrain_height/100) * static_cast<float>(m_lastY) / height()) * m_difficulty;
        m_slope = std::clamp(m_slope, -1.0f, 1.0f);

        const int newY = m_lastY + std::lround(m_slope * std::pow(std::abs(m_slope), m_irregularity) * Constants::STEP);

        Line seg(m_lastX, m_lastY, m_lastX + Constants::STEP, newY);
        m_lines.append(seg);
        rasterizeSegmentToHeightMapWorld(seg.getX1(), m_lastY, seg.getX2(), newY);

        m_lastY = newY;
        m_lastX += Constants::STEP;
        
        // Memory management: Remove old segments
        if (m_lines.size() > (width() / Constants::STEP) * 3) { 
            m_lines.removeFirst(); 
            pruneHeightMap(); 
        }
        
        // ... (Difficulty increment logic)
    }
}

void MainWindow::rasterizeSegmentToHeightMapWorld(int x1, int y1, int x2, int y2) {
    if (x2 < x1) { std::swap(x1,x2); std::swap(y1,y2); }

    const int gx1 = x1 / Constants::PIXEL_SIZE;
    const int gx2 = x2 / Constants::PIXEL_SIZE;

    const double dx = double(x2 - x1);
    const double dy = double(y2 - y1);

    // Discrete sampling of the continuous segment
    for (int gx = gx1; gx <= gx2; ++gx) {
        const double wx = gx * double(Constants::PIXEL_SIZE);
        double t = (wx - x1) / dx;
        t = std::clamp(t, 0.0, 1.0);

        const double wy = y1 + t * dy;
        const int gy = static_cast<int>(std::floor(wy / double(Constants::PIXEL_SIZE) + 0.5));

        // Store in Hash Map
        m_heightAtGX.insert(gx, gy);
    }
}

void MainWindow::drawFilledTerrain(QPainter& p) {
    const int camGX = m_cameraX / Constants::PIXEL_SIZE;
    const int camGY = m_cameraY / Constants::PIXEL_SIZE;

    for (int sgx = 0; sgx <= gridW(); ++sgx) {
        const int worldGX = sgx + camGX;
        auto it = m_heightAtGX.constFind(worldGX);
        if (it == m_heightAtGX.constEnd()) continue;

        const int groundWorldGY = it.value();
        // ... (Calculation of screen coordinates)

        for (int sGY = startScreenGY; sGY <= gridH(); ++sGY) {
            // Procedural texture selection via hashing
            const QColor shade = grassShadeForBlock(worldGX, worldGY, topZone);
            plotGridPixel(p, sgx, sGY, shade);
        }
    }
}
\end{lstlisting}

\subsubsection*{Terrain Generation Results}
The implementation successfully creates an infinite, seamless terrain that adapts to the game's difficulty progression. The mathematical restoring force ensures that the track never spirals out of the playable area, while the non-linear integration creates "ramps" and "dips" that physically interact with the car's suspension. The `QHash` rasterization proved highly efficient, maintaining a steady 60 FPS even after the player has traveled tens of thousands of pixels, as old terrain data is aggressively pruned. Visually, the hash-based coloring provides a distinct "pixel-art" texture that is deterministic yet non-repetitive.

All levels have distinct terrain generation parameters which makes the experience unique.

\begin{figure}[h]
  \centering
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/meadows_terrain.png}
    \caption{Smoother curves on Meadows level}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/moon_terrain.png}
    \caption{Rougher curves on Lunar level}
  \end{subfigure}
  \caption{Terrain System: Infinite procedural generation with dynamic irregularity and deterministic texture hashing.}
\end{figure}

\paragraph{\texttt{GAME LOOP :}}
The \texttt{gameLoop()} function advances the entire simulation at a fixed time-step. It updates elapsed time, evaluates wheel positions, accumulates forward distance and recomputes the score from distance, coins and nitro uses. It smoothly follows the car with a damped camera, drives terrain extension and prop/coin/fuel spawning, and updates nitro state and fuel consumption. It also processes coin and fuel pickups, detects crashes or fuel exhaustion, arms game over when needed, and finally triggers a repaint via \texttt{update()}. 

\begin{lstlisting}[style=cgstyle, language=C++]
void MainWindow::gameLoop() {
    const qint64 now = m_clock.nsecsElapsed();
    static qint64 prev = now;
    const qint64 dtns = now - prev;
    prev = now;
    const double dt = std::clamp(dtns / 1e9, 0.001, 0.033);

    m_elapsedSeconds += dt;
    double fuelBefore = m_fuel;
    int coinsBefore = m_coinCount;
    double avgX = 0.0, avgY = 0.0;
    if (!m_wheels.isEmpty()) {
        for (const Wheel* w : m_wheels) { avgX += w->x; avgY += w->y; }
        avgX /= m_wheels.size();
        avgY /= m_wheels.size();
    }

    double dx = std::max(0.0, avgX - m_lastScoreX);
    m_totalDistanceCells += dx / double(Constants::PIXEL_SIZE);
    m_lastScoreX = avgX;

    m_score = int(std::llround(Constants::SCORE_DIST_PER_CELL * m_totalDistanceCells +
                               Constants::SCORE_PER_COIN * m_coinCount +
                               Constants::SCORE_PER_NITRO * m_nitroUses));

    double bodyX = (!m_bodies.isEmpty()) ? m_bodies.first()->getX() : avgX;
    double bodyY = (!m_bodies.isEmpty()) ? m_bodies.first()->getY() : avgY;
    const double targetX = bodyX - 200.0;
    const double targetY = -bodyY + height() / 2.0;
    updateCamera(targetX, targetY, dt);
    m_cameraX = int(std::lround(m_camX));
    m_cameraY = int(std::lround(m_camY));
    double angleRad = 0.0;
    if (m_wheels.size() >= 2) {
        const double dx = (m_wheels[1]->x - m_wheels[0]->x);
        const double dy = (m_wheels[1]->y - m_wheels[0]->y);
        angleRad = std::atan2(dy, dx);
    }
    double carX = (!m_bodies.isEmpty()) ? m_bodies.first()->getX() : avgX;
    double carY = (!m_bodies.isEmpty()) ? m_bodies.first()->getY() : avgY;

    m_flip.update(angleRad, carX, carY, m_elapsedSeconds, [this](int bonus){ m_coinCount += bonus; });  

    const int viewRightX = m_cameraX + width();
    const int marginPx   = Constants::COIN_SPAWN_MARGIN_CELLS * Constants::PIXEL_SIZE;
    const int offRightX  = viewRightX + marginPx;
    const int maxStreamWidthPx = (Constants::COIN_GROUP_MAX - 1) * Constants::COIN_GROUP_STEP_MAX * Constants::PIXEL_SIZE;
    ensureAheadTerrain(offRightX + maxStreamWidthPx + Constants::PIXEL_SIZE * 20);

    m_coinSys.maybePlaceCoinStreamAtEdge(m_elapsedSeconds, m_cameraX, width(), m_heightAtGX, m_lastX, m_rng, m_dist);

    m_nitroSys.update(
        m_nitroKey, m_fuel, m_elapsedSeconds, avgX,
        [this](int gx){ return this->groundGyNearestGX(gx); },
        [this](double wx){ return this->terrainTangentAngleAtX(wx); }
        );

    if (m_nitroSys.active && !m_prevNitroActive) ++m_nitroUses;
    m_prevNitroActive = m_nitroSys.active;

    const bool allowInput = (m_fuel > 0.0);
    bool accelDrive = false, brakeDrive = false, nitroDrive = false;

    if (m_nitroSys.active && allowInput) {
        accelDrive = false; brakeDrive = false; nitroDrive = true;
    } else {
        nitroDrive = false;
        bool bothKeys = m_accelerating && m_braking;
        if (allowInput) {
            if (bothKeys) { accelDrive = true; brakeDrive = true; }
            else { accelDrive = m_accelerating; brakeDrive = m_braking; }
        } else { accelDrive = false; brakeDrive = false; }
    }

    for (Wheel* w : m_wheels) w->simulate(level_index, m_lines, accelDrive, brakeDrive, nitroDrive);
    for (CarBody* b : m_bodies) b->simulate(level_index, m_lines, accelDrive, brakeDrive);

    m_nitroSys.applyThrust(m_wheels);

    if (m_fuel > 0.0) {
        double baseBurn = Constants::FUEL_BASE_BURN_PER_SEC * dt;
        double extra = 0.0;
        if (m_accelerating) extra = std::max(0.0, averageSpeed()) * Constants::FUEL_EXTRA_PER_SPEED * dt;
        double burnMult = m_nitroSys.active ? 3.0 : 1.0;
        m_fuel = std::max(0.0, m_fuel - burnMult * (baseBurn + extra));
    }

    const int minX = leftmostTerrainX();
    for (Wheel* w : m_wheels) {
        if (w->x < minX) { w->x = minX; w->m_vx = 0; }
    }

    if (!isFullyUpsideDown()) {
        m_fuelSys.handlePickups(m_wheels, m_fuel);
        m_coinSys.handlePickups(m_wheels, m_coinCount);
    }
    if (m_coinCount > coinsBefore) m_media->coinPickup();
    if ((m_fuel - fuelBefore) > 1e-3 && !m_suppressFuelSfx) m_media->fuelPickup();
    {
        auto ptSegDist2 = [](double px, double py, const Line& ln)->double {
            double x1 = ln.getX1(), y1 = ln.getY1();
            double x2 = ln.getX2(), y2 = ln.getY2();
            double vx = x2 - x1,   vy = y2 - y1;
            double wx = px - x1,   wy = py - y1;
            double len2 = vx*vx + vy*vy;
            double t = (len2 > 0.0) ? (wx*vx + wy*vy) / len2 : 0.0;
            if (t < 0.0) t = 0.0; else if (t > 1.0) t = 1.0;
            double cx = x1 + t*vx, cy = y1 + t*vy;
            double dx = px - cx,   dy = py - cy;
            return dx*dx + dy*dy;
        };

        const double R2 = double(Constants::COIN_PICKUP_RADIUS) * double(Constants::COIN_PICKUP_RADIUS);

        for (auto& coin : m_coinSys.coins) {
            if (coin.taken) continue;
            bool hit = false;

            for (CarBody* body : m_bodies) {
                const auto edges = body->getLines();
                for (const Line& ln : edges) {
                    if (ptSegDist2(coin.cx, coin.cy, ln) <= R2) {
                        hit = true;
                        break;
                    }
                }

                if (!hit) {
                    const auto bodyPoints = body->get(0, 0);
                    QPolygon polygon;
                    for (const QPoint& p : bodyPoints)
                        polygon << QPoint(p.x(), p.y());
                    if (polygon.containsPoint(QPoint(coin.cx, coin.cy), Qt::OddEvenFill))
                        hit = true;
                }

                if (hit) break;
            }

            if (hit) {
                coin.taken = true;
                ++m_coinCount;
            }
        }
    }

    const bool fuelEmpty = (m_fuel <= 0.0);
    const bool roofHit   = !m_bodies[0]->isAlive();

    if (roofHit && !m_roofCrashLatched) {
        m_roofCrashLatched = true;
        if (!m_bodies.isEmpty() && m_bodies[0]->isAlive()) {
            m_bodies[0]->kill();
        }
    }

    if (fuelEmpty || m_roofCrashLatched) {
        armGameOver();
    } else {
        disarmGameOver();
    }

    update();
}
\end{lstlisting}

\paragraph{\texttt{PAINT EVENT :}} 
\newline
The \texttt{paintEvent()} function renders the entire frame in world and HUD space. After establishing a camera-aligned translation, it optionally draws the grid, starfield, clouds and filled terrain, then renders props, fuel pickups, world coins and nitro flame. Wheels are drawn as filled circles, and the car body plus attachments are filled using a scan-line polygon routine. Finally, it restores the painter and overlays HUD elements: fuel bar, coin counter, nitro HUD, flip HUD, distance, score and key log.

\begin{lstlisting}[style=cgstyle, language=C++]
void MainWindow::paintEvent(QPaintEvent *event) {
    Q_UNUSED(event);
    QPainter p(this);
    p.setRenderHint(QPainter::Antialiasing, true);
    p.setPen(Qt::NoPen);

    const int camGX = m_cameraX / Constants::PIXEL_SIZE;
    const int camGY = m_cameraY / Constants::PIXEL_SIZE;
    const int offX  = -(m_cameraX - camGX * Constants::PIXEL_SIZE);
    const int offY  =  (m_cameraY - camGY * Constants::PIXEL_SIZE);

    p.save();
    p.translate(offX, offY);

    if (m_showGrid) { drawGridOverlay(p); }
    drawStars(p);
    drawClouds(p);
    drawFilledTerrain(p);
    m_propSys.draw(p, m_cameraX, m_cameraY, width(), height(), m_heightAtGX);
    m_fuelSys.drawWorldFuel(p, m_cameraX, m_cameraY);
    m_coinSys.drawWorldCoins(p, m_cameraX, m_cameraY, gridW(), gridH());
    m_nitroSys.drawFlame(p, m_wheels, m_cameraX, m_cameraY, width(), height());

    for (const Wheel* wheel : m_wheels) {
        if (auto info = wheel->get(0, 0, width(), height(), -m_cameraX, m_cameraY)) {
            const int cx = (*info)[0];
            const int cy = (*info)[1];
            const int r  = (*info)[2];
            if(r == 0) continue;
            const int gcx = cx / Constants::PIXEL_SIZE;
            const int gcy = cy / Constants::PIXEL_SIZE;
            const int gr  = r  / Constants::PIXEL_SIZE;
            drawCircleFilledMidpointGrid(p, gcx, gcy, gr, Constants::WHEEL_COLOR_OUTER);
            const int tyreCells = std::max(1, Constants::TYRE_THICKNESS / Constants::PIXEL_SIZE);
            const int innerR = std::max(1, gr - tyreCells);
            drawCircleFilledMidpointGrid(p, gcx, gcy, innerR, Constants::WHEEL_COLOR_INNER);
        }
    }

    for(CarBody* body : m_bodies){
        auto pts = body->get(-m_cameraX, m_cameraY);
        QVector<QPoint> normalisedPoints;
        normalisedPoints.reserve(pts.size());
        for(auto p2 : pts){
            normalisedPoints.append(QPoint(p2.x() / Constants::PIXEL_SIZE, p2.y() / Constants::PIXEL_SIZE));
        }
        fillPolygon(p, normalisedPoints, Constants::CAR_COLOR);

        auto attach = body->getAttachments(-m_cameraX, m_cameraY);
        for (const auto& ap : attach) {
            QVector<QPoint> norm;
            norm.reserve(ap.first.size());
            for (const QPoint& q : ap.first) {
                norm.append(QPoint(q.x() / Constants::PIXEL_SIZE, q.y() / Constants::PIXEL_SIZE));
            }
            fillPolygon(p, norm, ap.second);
        }
    }
    m_flip.drawWorldPopups(p, m_cameraX, m_cameraY, level_index);

    p.restore();

    drawHUDFuel(p);
    drawHUDCoins(p);
    m_nitroSys.drawHUD(p, m_elapsedSeconds, level_index);
    m_flip.drawHUD(p, level_index);
    drawHUDDistance(p);
    drawHUDScore(p);
    m_keylog.draw(p, width(), height(), Constants::PIXEL_SIZE);
}
\end{lstlisting}



\subsubsection*{Feature: Physics-Based Spring-Damper Suspension}
\textbf{Relevant classes and functions:} \texttt{Wheel::simulate()}, \texttt{CarBody::simulate()}, \texttt{CarBody::addWheel()}.

To simulate realistic vehicle suspension and structural integrity , I implemented a dynamic mass-spring-damper model. This system governs the interaction between the main \texttt{CarBody} and its attached \texttt{Wheel} objects, as well as the constraints between the wheels themselves. Rather than using rigid body kinematics, I treat the connections as dynamic springs that obey Hooke's Law and utilize viscous damping to stabilize the system.

\paragraph{Mathematical Formulation.}
Consider the chassis center of mass at position $\mathbf{p}_C$ and a wheel at position $\mathbf{p}_W$. The vector connecting them is $\vec{r} = \mathbf{p}_W - \mathbf{p}_C$. I calculate the Euclidean distance $d$ and the normalized unit vector $\hat{u}$ as:
\[
  d = \|\vec{r}\| = \sqrt{(x_W - x_C)^2 + (y_W - y_C)^2}, \quad \hat{u} = \frac{\vec{r}}{d}.
\]
Let $L_0$ be the rest length (stored as \texttt{desiredDistance}). The scalar displacement $x$ from equilibrium is:
\[
  x = d - L_0.
\]
According to Hooke's Law, the magnitude of the restoring spring force $F_s$ is proportional to this displacement using a spring constant $k$:
\[
  F_s = k \cdot x.
\]
This force acts along the spring axis. The force vector acting on the wheel (pulling/pushing it relative to the body) is:
\[
  \mathbf{F}_{\text{spring}} = -F_s \cdot \hat{u}.
\]

\paragraph{Projected Viscous Damping.}
A pure spring system oscillates indefinitely. To simulate the energy dissipation of a real shock absorber , I implemented a damping force that resists motion \textit{only along the axis of the spring}. This prevents the "jelly" effect where tangential motion is incorrectly dampened.

First, I calculate the relative velocity vector between the wheel and the body:
\[
  \mathbf{v}_{\text{rel}} = \mathbf{v}_W - \mathbf{v}_C.
\]
I then project this relative velocity onto the spring's unit vector $\hat{u}$ using the dot product to find the closing speed $v_{\text{proj}}$:
\[
  v_{\text{proj}} = \mathbf{v}_{\text{rel}} \cdot \hat{u} = (v_{x,\text{rel}} \cdot u_x + v_{y,\text{rel}} \cdot u_y).
\]
The damping force magnitude is proportional to this projected velocity by a damping coefficient $c$ (\texttt{Constants::DAMPING}). The resulting damping force vector is:
\[
  \mathbf{F}_{\text{damping}} = c \cdot v_{\text{proj}} \cdot \hat{u}.
\]

\paragraph{Integration and Action-Reaction.}
The total force applied to the components is the sum of the spring and damping forces. By Newton's Third Law, the forces applied to the wheel and the car body are equal and opposite:
\begin{align*}
  \mathbf{F}_{\text{wheel}} &= \mathbf{F}_{\text{spring}} - \mathbf{F}_{\text{damping}}, \\
  \mathbf{F}_{\text{body}} &= -\mathbf{F}_{\text{wheel}}.
\end{align*}
I integrate these forces into the velocity of the objects using a semi-implicit Euler approach. For the car body, the velocity update is:
\[
  \mathbf{v}_C^{t+1} = \mathbf{v}_C^t + \mathbf{F}_{\text{body}}.
\]

\bigskip
\noindent\textbf{Core code snippets.} The following excerpts demonstrate the spring logic. Note specifically the dot-product projection used in `CarBody` for accurate suspension damping.

carBody.cpp (Suspension Logic)
\begin{lstlisting}[style=cgstyle,language=C++]
// Inside CarBody::simulate(...)
for (int i = 0; m_isAlive && i < m_wheels.size(); i++) {
    Wheel* wheel = m_wheels.at(i);
    double desiredDistance = m_attachDistances.at(i);

    // 1. Geometry (Vector and Unit Vector)
    double deltaX = wheel->getX() - m_cx;
    double deltaY = wheel->getY() - m_cy;
    double actualDistance = std::sqrt(deltaX * deltaX + deltaY * deltaY);

    if (actualDistance == 0) continue;
    double unitX = -deltaX / actualDistance;
    double unitY =  deltaY / actualDistance;

    // 2. Hooke's Law (Spring Force)
    double displacement = actualDistance - desiredDistance;
    double springForceMagnitude = displacement * Constants::SPRING_CONSTANT;
    double forceX = unitX * springForceMagnitude;
    double forceY = unitY * springForceMagnitude;

    // 3. Projected Damping
    // Calculate relative velocity
    double relativeVx = wheel->getVx() - m_vx;
    double relativeVy = wheel->getVy() - m_vy;

    // Project relative velocity onto the spring axis (Dot Product)
    // This isolates the component of velocity that is stretching/compressing the spring
    double velocityAlongSpring = relativeVx * unitX + relativeVy * unitY;

    // Calculate damping force components based ONLY on that projection
    double dampingForceX = velocityAlongSpring * unitX * Constants::DAMPING;
    double dampingForceY = velocityAlongSpring * unitY * Constants::DAMPING;

    // 4. Integration (Action-Reaction)
    m_vx -= (forceX - dampingForceX);
    m_vy -= (forceY - dampingForceY);
    wheel->updateV(forceX - dampingForceX, forceY - dampingForceY);
}
\end{lstlisting}

wheel.cpp (Inter-wheel constraints)
\begin{lstlisting}[style=cgstyle,language=C++]
// Inside Wheel::simulate(...)
for (int i = 0; i < m_others.size(); ++i) {
    Wheel* other = m_others.at(i);
    double desiredDistance = m_distances.at(i);

    // Calculate displacement and unit vectors
    double deltaX = other->x - x;
    double deltaY = other->y - y;
    double actualDistance = std::sqrt(deltaX * deltaX + deltaY * deltaY);
    double unitX = -deltaX / actualDistance;
    double unitY =  deltaY / actualDistance;

    // Hooke's Law
    double displacement = actualDistance - desiredDistance;
    double springForceMagnitude = displacement * Constants::SPRING_CONSTANT;
    double forceX = unitX * springForceMagnitude;
    double forceY = unitY * springForceMagnitude;

    // Simplified Damping for wheel-to-wheel struts
    double relativeVx = other->m_vx - m_vx;
    double relativeVy = other->m_vy - m_vy;
    double dampingForceX = relativeVx * Constants::DAMPING;
    double dampingForceY = relativeVy * Constants::DAMPING;

    // Apply forces
    m_vx -= (forceX - dampingForceX);
    m_vy -= (forceY - dampingForceY);
    other->m_vx += (forceX - dampingForceX);
    other->m_vy += (forceY - dampingForceY);
}
\end{lstlisting}

\subsubsection*{Spring Model Results}
The implementation resulted in a "soft-body" feel for the vehicle. The projection-based damping in the `CarBody` was particularly effective; it allowed the suspension to absorb vertical impacts from jumps (where $\vec{v}_{\text{rel}}$ aligns with $\hat{u}$) without artificially slowing down the car's rotational or horizontal motion, which would occur with naive global damping. The car settles back to its resting height naturally after hitting a bump, simulating a working suspension system.

\begin{figure}[h]
  \centering
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/suspension_free.png}
    \caption{Wheels are suspended freely when in air}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/suspension_active.png}
    \caption{Springs absorb impact on terrain collision}
  \end{subfigure}
  \caption{Spring model: Simulation of a working suspension system using dampened distance-locked springs.}
\end{figure}


\subsubsection*{Feature: Terrain Collision and Impulse Resolution}
\textbf{Relevant classes and functions:} \texttt{Wheel::simulate()}, \texttt{CarBody::simulate()}, \texttt{Line::getSlope()}.

To ensure the vehicle interacts physically with the procedural terrain, I implemented a discrete collision detection system based on analytical geometry. Rather than using axis-aligned bounding boxes (AABB), which are unsuitable for the steep, irregular slopes of my terrain, I perform precise point-to-line distance checks for every wheel and every defining vertex of the car's hitbox.

[Image of vector projection physics diagram]


\paragraph{Distance and Intersection Testing.}
The terrain is stored as a list of line segments. For a given segment defined by slope $m$ and intercept $b$ (equation $y = mx + b$), and a collision point $(p_x, p_y)$, I formulate the line equation as $mx - y + b = 0$. The perpendicular distance $d$ from the point to the infinite line is derived as:
\[
  d = \frac{|m \cdot p_x - p_y + b|}{\sqrt{m^2 + 1}}.
\]
To confirm the collision is valid, I calculate the projected $x$-coordinate of the intersection, $x_{\text{int}}$, to ensure it lies within the segment's bounds $[x_1, x_2]$:
\[
  x_{\text{int}} = \frac{m(p_y - b) + p_x}{m^2 + 1}.
\]
A collision is detected if $x_1 \le x_{\text{int}} \le x_2$ and $d < r$, where $r$ is the collision radius (the wheel radius or the hitbox tolerance).

\paragraph{Coordinate Frame Transformation.}
Applying friction and restitution directly in global coordinates is difficult on slanted terrain. Therefore, upon collision, I rotate the velocity vector $\mathbf{v} = (v_x, v_y)$ into the surface's local reference frame defined by the tangent angle $\theta = -\arctan(m)$. The components parallel ($v_{\parallel}$) and perpendicular ($v_{\perp}$) to the surface are:
\[
  \begin{bmatrix} v_{\parallel} \\ v_{\perp} \end{bmatrix} = 
  \begin{bmatrix} \cos\theta & \sin\theta \\ -\sin\theta & \cos\theta \end{bmatrix}
  \begin{bmatrix} v_x \\ v_y \end{bmatrix}.
\]

\paragraph{Impulse Response and Integration.}
Once in the local frame, I apply physical forces naturally.
1.  **Position Correction:** To prevent tunneling, I project the object out of the terrain along the surface normal by the penetration depth $(r - d)$.
2.  **Restitution (Bouncing):** I apply an impulse to the normal velocity. For the car body, I implemented a non-linear restitution function using a sigmoid scaling factor to prevent explosive energy gain at high impact speeds:
    \[
      v'_{\perp} = v_{\perp} \cdot \epsilon \cdot \frac{1}{1 + e^{-v_{\perp}}},
    \]
    where $\epsilon$ is the restitution coefficient.
3.  **Friction and Traction:** I apply kinetic friction to the tangential velocity. If the object is a driving wheel, I also inject acceleration or braking forces directly into $v_{\parallel}$:
    \[
      v'_{\parallel} = v_{\parallel} \cdot (1 - \mu) + F_{\text{drive}}.
    \]

Finally, I rotate the modified components $v'_{\parallel}$ and $v'_{\perp}$ back to the global Cartesian frame to update the object's state for the next integration step.

\bigskip
\noindent\textbf{Core code snippets.} The following excerpts demonstrate the collision mathematics, specifically the projection logic and frame rotation.

wheel.cpp (Collision Logic)
\begin{lstlisting}[style=cgstyle,language=C++]
// Inside Wheel::simulate(...)
for (const Line& line : lines) {
    double m = line.getSlope();
    double b = line.getIntercept();

    // 1. Analytical Distance Check
    double dist = std::abs(m * x - y + b) / std::sqrt(m * m + 1);
    double intersection_x = (m * (y - b) + x) / (m * m + 1);

    int minX = std::min(line.getX1(), line.getX2());
    int maxX = std::max(line.getX1(), line.getX2());

    if (dist < std::max(1, m_radius) && intersection_x >= minX && intersection_x <= maxX) {
        double overlap = m_radius - dist;
        double normal_angle = std::atan2(-m, 1.0);

        // 2. Position Correction (Anti-Tunneling)
        y -= overlap * std::cos(normal_angle);
        x -= overlap * std::sin(normal_angle);

        // 3. Frame Rotation (World -> Slope)
        double theta = -std::atan(m);
        double vAlongLine    = m_vx * std::cos(theta) + m_vy * std::sin(theta);
        double vNormalToLine = m_vy * std::cos(theta) - m_vx * std::sin(theta);

        // 4. Physical Response
        // Bounce
        vNormalToLine *= (vNormalToLine < 0.2) ? Constants::RESTITUTION[level_index] : 1;
        
        // Friction
        if ((vAlongLine > Constants::MAX_VELOCITY/1000) || (vAlongLine < -Constants::MAX_VELOCITY/1000)) {
            vAlongLine *= 1 - Constants::FRICTION[level_index];
        }

        // Traction (Acceleration/Braking applied to tangent)
        if (accelerating && isAlive && vAlongLine < Constants::MAX_VELOCITY) {
             vAlongLine += (Constants::ACCELERATION * ... * cos(theta));
        }

        // 5. Frame Rotation (Slope -> World)
        m_vx = vAlongLine * std::cos(theta) - vNormalToLine * std::sin(theta);
        m_vy = vAlongLine * std::sin(theta) + vNormalToLine * std::cos(theta);
    }
}
\end{lstlisting}

carBody.cpp (Hitbox Collision)
\begin{lstlisting}[style=cgstyle,language=C++]
// Inside CarBody::simulate(...)
for (const Point& point : hitbox) {
    // ... (Distance calculation similar to Wheel) ...

    if (dist <= 4 && intersectionx >= line.getX1() - 1 && intersectionx <= line.getX2() + 1) {
        double theta = -std::atan(m);

        // Position Correction Loop
        while (dist < 4) {
            m_cy -= std::cos(theta);
            m_cx -= std::sin(theta);
            // ... recalculate dist ...
        }

        // Frame Rotation
        double vAlongLine = m_vx * std::cos(theta) + m_vy * std::sin(theta);
        double vNormalToLine = m_vy * std::cos(theta) - m_vx * std::sin(theta);

        // Sigmoid-damped Restitution
        vNormalToLine = vNormalToLine * Constants::RESTITUTION[level_index] / (1 + std::exp(-vNormalToLine));
        vAlongLine *= 1 - Constants::FRICTION[level_index];

        // Rotate back
        m_vx = vAlongLine * std::cos(theta) - vNormalToLine * std::sin(theta);
        m_vy = vAlongLine * std::sin(theta) + vNormalToLine * std::cos(theta);
    }
}
\end{lstlisting}

\subsubsection*{Collision Model Results}
The analytical collision model proved robust against high-speed impacts and irregular terrain geometry. By rotating velocity vectors into the slope's reference frame, the simulation correctly distinguishes between normal forces (bouncing) and tangential forces (friction/traction). This allows the car to climb steep hills where a simple global-axis friction model would fail. The non-linear restitution in the car body successfully prevents numerical instability when the chassis drags along the ground, ensuring that the vehicle slides rather than vibrating uncontrollably.

\begin{figure}[h]
  \centering
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/collision_no_clipping.png}
    \caption{No clipping into terrain - no collision}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/collision_clipping.png}
    \caption{Clipping into terrain - collision code activated}
  \end{subfigure}
  \newline
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/hitbox.jpg}
    \caption{Separation of display hull and collision hitbox}
  \end{subfigure}
  \caption{Collision detection system: Check point-line distances of wheel centre and car chassis from terrain to ensure car always stays above terrain and responds to collisions naturally.}
\end{figure}
\clearpage

\subsubsection*{Feature: Centralized Physics and Procedural Configuration}
\textbf{Relevant file:} \texttt{constants.h}

To ensure the game engine remains data-driven and easily tunable, I consolidated all physical coefficients, procedural generation parameters, and game balance variables into a single static structure, \texttt{Constants}. This design pattern allows for the definition of distinct "biomes" (Levels) by simply altering vectors of values, without modifying the core simulation logic.

\paragraph{Level-Dependent Physics Vectors.}
The game features multiple environments (e.g., Meadow, Lunar, Martian). To model these distinct physical realities, I utilized \texttt{QVector<double>} containers where the index $i$ corresponds to the active level.
\begin{itemize}
    \item \textbf{Gravity ($\mathbf{g}$):} Defined in \texttt{GRAVITY}. On the "Lunar" level (index 3), gravity is reduced to $0.04$ (half the standard $0.08$), directly affecting the vertical velocity integration:
    \[ v_{y, t+1} = v_{y, t} - \mathbf{g}[i]. \]
    \item \textbf{Atmospheric Drag ($C_d$):} Defined in \texttt{AIR\_RESISTANCE}. This simulates the density of the atmosphere. For space levels, this approaches zero ($10^{-5}$), minimizing velocity decay:
    \[ \mathbf{v}_{t+1} = \mathbf{v}_t \cdot (1 - C_d[i]). \]
    \item \textbf{Surface Interaction ($\mu, \epsilon$):} Ground interaction is governed by \texttt{FRICTION} ($\mu$) and \texttt{RESTITUTION} ($\epsilon$). These determine the loss of tangential velocity and the elasticity of normal collisions respectively.
\end{itemize}

\paragraph{Procedural Terrain Parametrization.}
The infinite terrain generation relies on stochastic recurrence relations. I defined initial values and incremental scalers to make the terrain progressively more difficult as the player travels further.
\begin{itemize}
    \item \textbf{Slope Volatility ($D$):} Controlled by \texttt{DIFFICULTY\_INCREMENT}. As the game progresses, the range of the random variable $\xi$ used to perturb the slope expands:
    \[ D_{t+1} = D_t + \texttt{DIFFICULTY\_INCREMENT}[i]. \]
    \item \textbf{Non-Linearity ($\gamma$):} Controlled by \texttt{IRREGULARITY}. This constant powers the slope function, creating sharper peaks and valleys. The height step $\Delta y$ is calculated as:
    \[ \Delta y \propto m \cdot |m|^\gamma, \quad \gamma = \texttt{m\_irregularity}. \]
\end{itemize}

\paragraph{Vehicle Geometry and Suspension Constants.}
The vehicle chassis is not a sprite but a polygon defined physically by vertices relative to a center of mass.
\begin{itemize}
    \item \textbf{Suspension Dynamics:} The mass-spring-damper system is tuned via \texttt{SPRING\_CONSTANT} ($k=0.6$) and \texttt{DAMPING} ($c=0.06$). These global constants ensure consistent suspension behavior across all levels, isolating the handling changes to external factors (gravity/traction).
    \item \textbf{Chassis Definition:} I defined the car body using \texttt{CAR\_BODY\_POINTS} for rendering and \texttt{CAR\_HITBOX\_POINTS} for collision. This separation allows for a detailed visual mesh while maintaining a slightly smaller, optimized convex hull for physics calculations to prevent snagging on terrain micro-geometry.
\end{itemize}

\bigskip
\noindent\textbf{Core code snippets.} The following excerpts from \texttt{constants.h} illustrate the vector-based level configuration and the hard-coded physics parameters.

\begin{lstlisting}[style=cgstyle,language=C++]
struct Constants {
    static constexpr int PIXEL_SIZE = 6;

    // LEVEL MECHANICS (Index-based configuration)
    // Index: 0=Meadow, 1=Desert, 2=Tundra, 3=Lunar, 4=Martian, 5=Nightlife
    inline static QVector<double> GRAVITY           = {0.08, 0.08, 0.08, 0.04, 0.06, 0.08};
    inline static QVector<double> AIR_RESISTANCE    = {0.0005, 0.0003, 0.0007, 0.00001, 0.00005, 0.0007};
    inline static QVector<double> RESTITUTION       = {0.8, 0.5, 0.8, 0.7, 0.07, 0.5}; // Bounciness
    inline static QVector<double> FRICTION          = {0.003, 0.03, 0.0001, 0.001, 0.03, 0.03};
    inline static QVector<double> TRACTION          = {1, 1.25, 0.5, 0.5, 0.75, 1.5}; // Grip multiplier

    // TERRAIN GENERATION CONSTANTS
    static constexpr int STEP = 20; // Horizontal distance between vertices
    // Maximum slope clamping per level
    inline static QVector<double> MAX_SLOPE = {1.0, 1.5, 0.8, 2, 1.5, 0.5};
    
    // Difficulty Evolution parameters
    inline static QVector<double> INITIAL_DIFFICULTY = {0.005, 0.005, 0.008, 0.01, 0.008, 0.001};
    inline static QVector<double> DIFFICULTY_INCREMENT = {0.0001, 0.0002, 0.0001, 0.0003, 0.0002, 0.0001};
    
    // Irregularity (Power law exponent) parameters
    inline static QVector<double> INITIAL_IRREGULARITY = {0.01, 0.001, 0.01, 0.05, 0.02, 0.05};
    inline static QVector<double> IRREGULARITY_INCREMENT = {0.00001, 0.000001, 0.00003, 0.0001, 0.00005, 0.0001};

    // CAR MECHANICS (Physics Model)
    static constexpr double MAX_VELOCITY    = 30.0;
    static constexpr double ACCELERATION    = 0.8;
    static constexpr double DECELERATION    = 0.8;
    
    // Suspension (Hooke's Law & Damping)
    static constexpr double SPRING_CONSTANT = 0.6;
    static constexpr double DAMPING         = 0.06;
    
    // Angular Dynamics (Rotation control)
    static constexpr double ANGULAR_ACCELERATION = 0.0010;
    static constexpr double ANGULAR_DECELERATION = 0.0010;
    static constexpr double ANGULAR_DAMPING      = 0.05;

    // CHASSIS GEOMETRY
    // Points relative to Center of Mass (0,0)
    inline static const QVector<QPoint> CAR_BODY_POINTS = {
        QPoint(0,0), QPoint(0,31), QPoint(9,37), QPoint(15,19), /* ... */
    };

    inline static const QVector<QPoint> CAR_HITBOX_POINTS = {
        QPoint(15,6), QPoint(173, 1),  QPoint(137,0), QPoint(112,-25), /* ... */
    };
};
\end{lstlisting}

\subsubsection*{Configuration Results}
By separating these constants, I achieved a highly flexible simulation. For instance, creating the "Lunar" level required no changes to the physics engine code; I simply adjusted the \texttt{GRAVITY} vector at index 3 to $0.04$ and \texttt{AIR\_RESISTANCE} to near-zero. Similarly, the \texttt{DIFFICULTY\_INCREMENT} ensures that the procedural terrain remains drivable at the start but inevitably becomes impassable, creating a natural difficulty curve for an endless-runner style game.
\clearpage

\subsubsection*{Car Creation}
\begin{lstlisting}[style=cgstyle, language=C++]
void MainWindow::createCar() {
    Wheel* w1 = new Wheel(Constants::WHEEL_REAR_X,  Constants::WHEEL_REAR_Y,  Constants::WHEEL_REAR_R);
    Wheel* w2 = new Wheel(Constants::WHEEL_FRONT_X, Constants::WHEEL_FRONT_Y, Constants::WHEEL_FRONT_R);
    Wheel* w3 = new Wheel(Constants::WHEEL_MID_X,   Constants::WHEEL_MID_Y,   Constants::WHEEL_MID_R);

    w1->attach(w2); w1->attach(w3); w2->attach(w3);
    m_wheels.append(w1); m_wheels.append(w2); m_wheels.append(w3);

    CarBody* body = new CarBody();
    body->addPoints(Constants::CAR_BODY_POINTS);
    body->addHitbox(Constants::CAR_HITBOX_POINTS);
    body->addKillSwitches(Constants::CAR_KILL_POINTS);

    body->addWheel(w1); body->addWheel(w2); body->addWheel(w3);

    body->addAttachment(Constants::CAR_GLASS_POINTS, Constants::CAR_GLASS_COLOR);
    body->addAttachment(Constants::CAR_HANDLE_POINTS, Constants::CAR_HANDLE_COLOR);

    body->finish();
    m_bodies.append(body);
}
\end{lstlisting}

\subsubsection*{Wheel Physics and Rotational Dynamics}
\textbf{Relevant classes and functions:} \texttt{Wheel}, \texttt{Wheel::simulate()}, \texttt{Wheel::attach()}, \texttt{Wheel::updateV()}.

The vehicle dynamics in this simulation are built upon a composite rigid-body system. While the suspension constraints are handled via a spring-damper model (detailed in the Spring Physics section), kinematics and rotation are managed by the \texttt{Wheel} class. The physics engine integrates linear and angular velocities, resolves constraints against terrain segments, and applies user control inputs (acceleration, braking, and nitro).

\subsubsection*{Integration and Environmental Forces}
\textbf{Relevant code:} \texttt{Wheel::simulate()}

The physical state of each wheel is advanced using a semi-implicit Euler integration scheme. This method was chosen for its computational efficiency and stability in games where frame-to-frame velocity changes can be discontinuous (e.g., instant collisions).

\paragraph{Position Integration.}
For a wheel with position $\mathbf{p} = (x, y)$ and velocity $\mathbf{v} = (v_x, v_y)$, the position update per frame $t$ occurs after all forces and impulses have modified the velocity:
\begin{align*}
    x_{t+1} &= x_t + v_{x,t} \\
    y_{t+1} &= y_t - v_{y,t} \quad (\text{Note: } y \text{ decreases as } v_y \text{ increases due to screen-space coordinates})
\end{align*}

\paragraph{Gravity and Active Downforce.}
Prior to integration, the vertical velocity $v_y$ is updated by the gravitational constant $g$. In a standard state, this is a simple subtraction:
\[
    v_{y,t} \leftarrow v_{y,t} - g \cdot \Delta t
\]
However, the simulation includes an "Active Aerodynamics" mechanic. When the player presses both \textbf{Accelerate} and \textbf{Brake} simultaneously while airborne, the car engages a virtual spoiler. This action applies a down-thrust effectively increasing the gravitational pull by 50\%. 
\[
    v_{y,t} \leftarrow v_{y,t} - (g \cdot 0.5) \cdot \Delta t \quad \text{if (Accel AND Brake)}
\]
This mechanic serves a tactical purpose: it allows players to force the car down from high jumps quickly ("fast falling"), ensuring they can land on specific terrain features or return to the ground to regain traction and speed sooner. This couples with the angular stabilization logic (described in the Angular Dynamics section) to provide a "stabilized landing" maneuver.

\paragraph{Air Resistance (Drag).}
To prevent infinite acceleration and simulate atmospheric density, a linear drag factor $k_{\text{drag}}$ is applied to both velocity components. This is implemented as a multiplicative damping factor, which provides a smooth terminal velocity curve:
\[
    \mathbf{v} \leftarrow \mathbf{v} \cdot (1 - k_{\text{drag}}).
\]

The following code snippet from \texttt{Wheel::simulate} illustrates the implementation of these environmental forces:

\begin{lstlisting}[style=cgstyle,language=C++]
// 1. Integration of position (Euler)
x += m_vx;
y -= m_vy; // Screen space: Up is negative Y

// 2. Gravity Application
m_vy -= Constants::GRAVITY[level_index];

// Active Downforce / "Spoiler" Mechanic
// If both inputs are active, apply extra down-thrust for fast landing
if(accelerating && braking){
    m_vy -= Constants::GRAVITY[level_index] * 0.5;
}

// 3. Air Drag Application
// Multiplicative damping simulates air resistance
m_vx *= 1 - Constants::AIR_RESISTANCE[level_index];
m_vy *= 1 - Constants::AIR_RESISTANCE[level_index];
\end{lstlisting}

\textbf{Angular Dynamics and the \texttt{isRoot} Hierarchy}
\textbf{Relevant code:} \texttt{Wheel::attach()}, \texttt{Wheel::simulate()}.

A fundamental challenge in simulating a 2D vehicle composed of discrete point-mass wheels is managing the rigid-body rotation of the chassis. Since the chassis itself is not physically simulated as a collision body (only the wheels interact with the terrain), the rotation must be derived from the relationship between the two wheels. To prevent numerical divergence where wheels might simulate conflicting rotations, I implemented a hierarchical ownership model using the \texttt{m\_isRoot} flag.

\paragraph{The \texttt{m\_isRoot} Hierarchy.}
When the vehicle is assembled via the \texttt{attach()} method, one wheel is designated as the ``Root'' (master) and the other as the slave.
\[
    \text{Let } W_{root} \text{ and } W_{slave} \text{ be the wheel pair.}
\]
The \texttt{m\_isRoot} boolean ensures that angular physics calculations occur exactly once per vehicle per frame. The Root wheel is responsible for:
\begin{enumerate}
    \item Storing the vehicle's angular velocity $\omega$ (\texttt{m\_omega}).
    \item Interpreting control inputs (throttle/brake) into torque.
    \item Applying the geometric rotation to both itself and the attached slave wheel.
\end{enumerate}
This centralization is crucial. Without it, floating-point errors would accumulate differently on each wheel, causing the fixed distance constraint to fight against the rotation, leading to jitter or explosion of the constraints.

\paragraph{Angular Velocity as Incremental Rotation ($d\theta$).}
In this simulation, the variable \texttt{m\_omega} represents the angular velocity scaled by the timestep $\Delta t$.
\[
    \texttt{m\_omega} \approx \omega \cdot \Delta t = d\theta
\]
Consequently, in the integration step, \texttt{m\_omega} is used directly as the angle of rotation for the current frame. This simplification avoids explicit storage of the vehicle's absolute angle for physics purposes, relying instead on incremental updates to the position vector $\mathbf{r}$.

\paragraph{Control Inputs and Torque Application.}
The simulation applies angular impulses based on the player's input state. The system models torque $\tau$ as a direct modification of $\omega$.

\begin{itemize}
    \item \textbf{Acceleration (Nose-Up / Wheelie):}
    When the player accelerates, a positive torque is applied. Physically, this reaction torque opposes the wheels' forward spin. In the code, this increments $\omega$:
    \[
        \omega_{t+1} = \omega_t + \alpha_{\text{accel}} \quad \text{(Counter-Clockwise rotation)}
    \]
    This causes the vehicle to tilt backwards (wheelie) when facing right, allowing the player to perform backflips.

    \item \textbf{Braking (Nose-Down):}
    Braking applies negative torque, mimicking the inertia of the chassis continuing forward while wheels slow down:
    \[
        \omega_{t+1} = \omega_t - \alpha_{\text{brake}} \quad \text{(Clockwise rotation)}
    \]
    This is used for front-flips or correcting a wheelie.

    \item \textbf{Nitro Stabilization:}
    When nitro is engaged, the gameplay requirement is high-speed stability. We apply a heavy damping factor $k_{\text{nitro}} \in (0, 1)$:
    \[
        \omega_{t+1} = \omega_t \cdot (1 - k_{\text{nitro}}).
    \]
    This rapidly decays any rotational velocity, ensuring the car ``darts'' straight forward rather than spinning out of control.
\end{itemize}

\paragraph{Mid-Air Stabilization.}
A special case arises when both \textbf{Accelerate} and \textbf{Brake} are pressed simultaneously while airborne. This triggers an automatic stabilization feature intended to help the player land safely.
The system calculates the current pitch angle $\theta_{curr}$ relative to the horizon using \texttt{atan2}:
\[
    \theta_{curr} = \operatorname{atan2}(y_{slave} - y_{root}, x_{slave} - x_{root}).
\]
The goal is to drive $\theta_{curr} \to 0$. The code implements a Proportional controller (P-controller) logic:
\[
    \Delta \omega = 
    \begin{cases} 
    +\alpha & \text{if } \theta_{curr} > \epsilon \text{ (Nose too low, rotate up)} \\
    -\alpha & \text{if } \theta_{curr} < -\epsilon \text{ (Nose too high, rotate down)}
    \end{cases}
\]
This active correction, combined with aggressive damping, aligns the chassis horizontally for a perfect landing.

\paragraph{Geometric Rotation Implementation.}
Once the frame's rotation angle $d\theta$ (stored as \texttt{m\_omega}) is determined, it is applied to the positions of both wheels.
First, the centroid (Center of Mass, $C$) of the system is computed:
\[
    C_x = \frac{x_{root} + x_{slave}}{2}, \quad C_y = \frac{y_{root} + y_{slave}}{2}.
\]
The position vector $\mathbf{r}$ of each wheel relative to $C$ is rotated using the 2D rotation matrix $R(d\theta)$. The code implementation for the updated relative coordinates $(nx, ny)$ is:
\begin{lstlisting}[style=cgstyle,language=C++]
// Code snippet representing the matrix multiplication:
// | nx |   |  cos(w)  sin(w) | | rx |
// | ny | = | -sin(w)  cos(w) | | ry |
double nx = rx * cosA + ry * sinA;
double ny = -rx * sinA + ry * cosA;
\end{lstlisting}
\textit{Note: The negative sign appears in the $y$ calculation because of the screen-space coordinate system ($y$ increases downwards).}

The following code snippet demonstrates the core rotational logic inside \texttt{Wheel::simulate()}:

\begin{lstlisting}[style=cgstyle,language=C++]
// shared body tilt / rotation between two wheels (nitro-aware)
if (m_isRoot && m_others.size() > 0) {
    Wheel* other = m_others.first();

    // Angular Control Logic
    if (nitro) {
        // 1. Nitro: Heavy damping for straight flight
        m_omega *= 1 - Constants::ANGULAR_DAMPING;
        if (std::abs(m_omega) < 1e-4) m_omega = 0.0;
    } 
    else if (accelerating && braking) {
        // 2. Stabilization: Revert to horizontal angle
        m_angle = std::atan2(other->getY() - this->getY(), other->getX() - this->getX());
        
        // Apply corrective torque based on current angle
        if (std::abs(m_angle) > 1e-2) {
            if (m_angle > 0) m_omega += Constants::ANGULAR_ACCELERATION;
            else m_omega -= Constants::ANGULAR_DECELERATION;
        }
        // Apply damping to prevent oscillation
        m_omega *= 1 - Constants::ANGULAR_DAMPING;
        if (std::abs(m_omega) < 1e-4) m_omega = 0.0;
    } 
    else if (accelerating) {
        // 3. Accel: Tilt Backward (Counter-Clockwise)
        m_omega += Constants::ANGULAR_ACCELERATION;
        if (m_omega > Constants::MAX_ANGULAR_VELOCITY) 
            m_omega = Constants::MAX_ANGULAR_VELOCITY;
    } 
    else if (braking) {
        // 4. Brake: Tilt Forward (Clockwise)
        m_omega -= Constants::ANGULAR_DECELERATION;
        if (m_omega < -Constants::MAX_ANGULAR_VELOCITY) 
            m_omega = -Constants::MAX_ANGULAR_VELOCITY;
    } 
    else {
        // 5. Passive Damping (Air resistance equivalent)
        m_omega *= 1 - Constants::ANGULAR_DAMPING;
        if (std::abs(m_omega) < 1e-4) m_omega = 0.0;
    }

    // Apply incremental rotation of the wheel pair about COM
    if (std::abs(m_omega) > 1e-6) {
        double cx = (x + other->x) / 2.0;
        double cy = (y + other->y) / 2.0;

        double rx1 = x - cx;      double ry1 = y - cy;
        double rx2 = other->x - cx; double ry2 = other->y - cy;

        double sinA = std::sin(m_omega);
        double cosA = std::cos(m_omega);

        // Update Root Wheel
        double nx1 = rx1 * cosA + ry1 * sinA;
        double ny1 = -rx1 * sinA + ry1 * cosA; // Note Y-down adjustment
        x = cx + nx1;
        y = cy + ny1;

        // Update Slave Wheel
        double nx2 = rx2 * cosA + ry2 * sinA;
        double ny2 = -rx2 * sinA + ry2 * cosA;
        other->x = cx + nx2;
        other->y = cy + ny2;
    }
}
\end{lstlisting}

\subsubsection*{Results and Discussion}

\textbf{Responsiveness and Game Feel:} The direct mapping of acceleration to counter-clockwise torque and braking to clockwise torque provided an intuitive "weight" to the car. Players could naturally perform backflips off ramps by holding acceleration, or front-flips by tapping the brake mid-air. This mechanic transformed the vehicle from a simple sliding box into a dynamic, controllable object.

\textbf{Spoiler Activation:} The case of both keys pressed gives a "spoiler" effect that increases down thrust, which helps in "snappier" landings whenever required. This goes together with the angular stabilization dynamic to provide a clean down thrust experience.

\textbf{Stability vs. Agility:} The \texttt{isRoot} hierarchy successfully solved the problem of wheel desynchronization. Without this flag, wheels would rotate around multiple pivots, breaking the illusion of a solid chassis, and adding double counting problems. The addition of the ``Both Pressed'' stabilization logic provided a necessary skill floor, allowing players to recover from bad jumps by instinctively pressing both buttons to level the car before impact.

\textbf{Nitro Integration:} The dynamic damping during nitro usage created a distinct ``mode'' of travel. The car feels significantly tighter and more aerodynamic when boosting, which contrasts satisfyingly with the floaty, rotational freedom of standard flight.
\clearpage

\begin{figure}[h]
  \centering
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/Anticlockwise.png}
    \caption{On Accelerating, produce \textbf{anticlockwise} spin}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/Clockwise.png}
    \caption{On Braking, produce \textbf{clockwise} spin}
  \end{subfigure}
\end{figure}

\begin{figure}[h]
    \ContinuedFloat
    \begin{subfigure}{\textwidth}
  \centering
    \includegraphics[width=\linewidth]{images/Stabilization.png}
  \caption{On both acceleration and braking, produce \textbf{downthrust} and angular \textbf{stabilization} to \textbf{horizontal}}
  \end{subfigure}
  \caption{Different cases of generating \textbf{rotation}, \textbf{downthrust} and \textbf{stabilization}.}
\end{figure}
\clearpage

\subsubsection*{intro.h}
	\begin{lstlisting}[style=cgstyle,language=C++]
		// intro.h
		#ifndef INTRO_H
		#define INTRO_H
		
		#include <QWidget>
		#include <QTimer>
		#include <QHash>
		#include <QColor>
		#include <QVector>
		#include <QList>
		#include "line.h"
		#include "constants.h"
		#include <QSettings>
		#include <random>
		
		class QPainter;
		class QMouseEvent;
		class QResizeEvent;
		
		struct Cloud {
			int wx;
			int wyCells;
			int wCells;
			int hCells;
			quint32 seed;
		};
		
		class IntroScreen : public QWidget {
			Q_OBJECT
			public:
			explicit IntroScreen(QWidget* parent = nullptr, int levelIndex = 0);
			void setGrandCoins(int v);
			
			signals:
			void startRequested(int levelIndex);
			void exitRequested();
			
			protected:
			void paintEvent(QPaintEvent*) override;
			void mousePressEvent(QMouseEvent*) override;
			void resizeEvent(QResizeEvent*) override;
			
			private:
			void drawStars(QPainter& p);
			void drawClouds(QPainter& p);
			void maybeSpawnCloud();
			void drawBackground(QPainter& p);
			void drawFilledTerrain(QPainter& p);
			void plotGridPixel(QPainter& p, int gx, int gy, const QColor& c);
			void rasterizeSegmentToHeightMapWorld(int x1, int y1, int x2, int y2);
			void pruneHeightMap();
			void ensureAheadTerrain(int worldX);
			QColor grassShadeForBlock(int worldGX, int worldGY, bool greenify) const;
			
			void drawPixelText(QPainter& p, const QString& s, int gx, int gy, int scale, const QColor& c, bool bold);
			int  textWidthCells(const QString& s, int scale) const;
			int  fitTextScaleToRect(int wCells, int hCells, const QString& s) const;
			
			// Buttons / rects
			QRect buttonRectStart() const;
			QRect buttonRectExit() const;
			QRect buttonRectUnlock() const;
			QRect buttonRectLevelPrev() const;
			QRect buttonRectLevelNext() const;
			
			void saveUnlocks() const;
			void loadUnlocks();
			void saveGrandCoins() const;
			void loadGrandCoins();
			
			int stageLabelBottomPx() const;
			
			// Grid helpers
			inline int gridW() const { return width()  / PIXEL_SIZE; }
			inline int gridH() const { return height() / PIXEL_SIZE; }
			void drawCircleFilledMidpointGrid(QPainter& p, int gcx, int gcy, int gr, const QColor& c);
			
			QTimer m_timer;
			double m_scrollX = 0.0;
			
			QList<Line> m_lines;
			QHash<int,int> m_heightAtGX;
			QVector<Cloud> m_clouds;
			
			int m_lastCloudSpawnX = 0;
			int m_lastX = 0;
			int m_lastY = 0;
			float m_slope = 0.0f;
			float m_difficulty = 0.005f;
			
			static constexpr int   PIXEL_SIZE = 6;
			static constexpr int   SHADING_BLOCK = 3;
			static constexpr int   STEP = 20;
			static constexpr float DIFF_INC = 0.0001f;
			static constexpr int CLOUD_SPACING_PX = 700;
			static constexpr int CLOUD_MIN_W_CELLS = 8;
			static constexpr int CLOUD_MAX_W_CELLS = 18;
			static constexpr int CLOUD_MIN_H_CELLS = 3;
			static constexpr int CLOUD_MAX_H_CELLS = 7;
			static constexpr int CLOUD_SKY_OFFSET_CELLS = 40;
			
			std::mt19937 m_rng;
			
			static constexpr int CHAR_ADV = 7;
			
			int m_camX = 0;
			int m_camY = 200;
			int m_camXFarthest = 0;
			
			qreal m_blurScale = 0.6;
			
			quint64 m_grandTotalCoins = 0;
			
			// Title helpers (existing)
			int titleScale() const;
			int titleYCells() const;
			int startTopCells(int titleScale) const;
			int exitTopCells(int btnHCells) const;
			
			int level_index;
			
			QVector<bool> levels_unlocked = {true, false, false, false, false};
		};
		
		#endif // INTRO_H
	\end{lstlisting}
	
	\subsubsection*{intro.cpp}
	\begin{lstlisting}[style=cgstyle,language=C++]
		// intro.cpp
		#include "intro.h"
		#include <QPainter>
		#include <QMouseEvent>
		#include <QImage>
		#include <array>
		#include <cmath>
		#include <algorithm>
		
		constexpr int TITLE_STAGE_GAP_PX = 30;
		
		IntroScreen::IntroScreen(QWidget* parent, int levelIndex) : QWidget(parent) {
			setAttribute(Qt::WA_OpaquePaintEvent);
			
			level_index = levelIndex;
			
			loadGrandCoins();
			loadUnlocks();
			
			connect(&m_timer, &QTimer::timeout, this, [this]{
				m_scrollX += 2.0;
				m_camX = int(m_scrollX);
				
				while ((m_camX + width()) > m_camXFarthest) {
					m_camXFarthest += STEP;
					
					m_slope += (0.5f - float(m_lastY) / std::max(1,height())) * m_difficulty;
					m_slope = std::clamp(m_slope, -1.0f, 1.0f);
					
					const int newY = m_lastY + std::lround(m_slope * std::pow(std::abs(m_slope), 0.02f) * STEP);
					
					Line seg(m_lastX, m_lastY, m_lastX + STEP, newY);
					m_lines.append(seg);
					
					rasterizeSegmentToHeightMapWorld(seg.getX1(), m_lastY, seg.getX2(), newY);
					
					m_lastY = newY;
					m_lastX += STEP;
					
					if (m_lines.size() > (width() / STEP) * 3) {
						m_lines.removeFirst();
						pruneHeightMap();
					}
					
					m_difficulty += DIFF_INC;
					maybeSpawnCloud();
				}
				
				update();
			});
			
			m_lastY = height() / 2;
			for (int i = STEP; i <= width() + STEP; i += STEP) {
				m_slope += (0.5f - float(m_lastY) / std::max(1,height())) * m_difficulty;
				m_slope = std::clamp(m_slope, -1.0f, 1.0f);
				
				const int newY = m_lastY + std::lround(m_slope * std::pow(std::abs(m_slope), 0.02f) * STEP);
				
				Line seg(i - STEP, m_lastY, i, newY);
				m_lines.append(seg);
				
				rasterizeSegmentToHeightMapWorld(seg.getX1(), m_lastY, seg.getX2(), newY);
				
				m_lastY = newY;
				m_difficulty += DIFF_INC;
			}
			m_lastX = STEP * m_lines.size();
			
			m_timer.start(16);
		}
		
		void IntroScreen::setGrandCoins(int v){
			m_grandTotalCoins = v;
			update();
		}
		
		int IntroScreen::titleScale() const {
			return std::clamp(gridH() / (7 * 12), 2, 4);
		}
		
		int IntroScreen::titleYCells() const {
			return std::max(2, gridH() / 4);
		}
		
		int IntroScreen::startTopCells(int) const {
			int btnH = std::max(10, gridH()/18);
			int gap  = std::max(10,  gridH()/40);
			int bottom = std::max(30, gridH()/24);
			return gridH() - (2*btnH + gap + bottom);
		}
		
		int IntroScreen::exitTopCells(int btnHCells) const {
			int bottom = std::max(30, gridH()/24);
			return gridH() - (btnHCells + bottom);
		}
		
		void IntroScreen::maybeSpawnCloud() {
			if (m_lastX - m_lastCloudSpawnX < CLOUD_SPACING_PX) return;
			
			std::uniform_real_distribution<double> dist(0.0, 1.0);
			if (dist(m_rng) > Constants::CLOUD_PROBABILITY[level_index]) return;
			
			int gx = m_lastX / PIXEL_SIZE;
			auto it = m_heightAtGX.constFind(gx);
			if (it == m_heightAtGX.constEnd()) return;
			
			int gyGround = it.value();
			
			auto mix = [](quint32 v, int shift, int span, int base){
				return base + int(((v >> shift) % quint32(span)));
			};
			quint32 h = 120003212u ^ quint32(m_lastX * 2654435761u);
			
			int wCells = mix(h, 0,  CLOUD_MAX_W_CELLS - CLOUD_MIN_W_CELLS + 1, CLOUD_MIN_W_CELLS);
			int hCells = mix(h, 8,  CLOUD_MAX_H_CELLS - CLOUD_MIN_H_CELLS + 1, CLOUD_MIN_H_CELLS);
			int skyLift = CLOUD_SKY_OFFSET_CELLS + mix(h, 16, 11, 0);
			
			int cloudTopCells = gyGround - skyLift;
			if (cloudTopCells < 0) cloudTopCells = 0;
			
			Cloud cl;
			cl.wx = m_lastX;
			cl.wyCells = cloudTopCells;
			cl.wCells = wCells;
			cl.hCells = hCells;
			cl.seed = h;
			m_clouds.append(cl);
			
			m_lastCloudSpawnX = m_lastX;
			
			int leftLimit = (m_lines.isEmpty() ? 0 : m_lines.first().getX1()) - width()*2;
			for (int i = 0; i < m_clouds.size(); ) {
				if (m_clouds[i].wx < leftLimit) m_clouds.removeAt(i);
				else ++i;
			}
		}
		
		void IntroScreen::drawClouds(QPainter& p) {
			if (Constants::CLOUD_PROBABILITY[level_index] <= 0.001) return;
			
			int camGX = m_camX / PIXEL_SIZE;
			int camGY = m_camY / PIXEL_SIZE;
			
			auto hash2D = [](int x, int y)->quint32{
				quint32 h = 120003212u;
				h ^= quint32(x); h *= 16777619u;
				h ^= quint32(y); h *= 16777619u;
				return h;
			};
			
			for (const Cloud& cl : m_clouds) {
				int baseGX = (cl.wx / PIXEL_SIZE) - camGX;
				int baseGY = cl.wyCells + camGY;
				
				for (int yy = 0; yy < cl.hCells; ++yy) {
					for (int xx = 0; xx < cl.wCells; ++xx) {
						double nx = ((xx + 0.5) - cl.wCells  / 2.0) / (cl.wCells  / 2.0);
						double ny = ((yy + 0.5) - cl.hCells / 2.0) / (cl.hCells / 2.0);
						double r2 = nx*nx + ny*ny;
						
						quint32 h = hash2D(int(cl.seed) + xx, yy);
						double fuzz = (h % 100) / 400.0;
						
						if (r2 <= 1.0 + fuzz) {
							QColor cMain = Constants::CLOUD_COLOR[level_index];
							QColor cSoft(cMain.red() * 0.9, cMain.green() * 0.9,
							cMain.blue() * 0.9);
							QColor pix = ((h >> 3) & 1) ? cMain : cSoft;
							plotGridPixel(p, baseGX + xx, baseGY + yy, pix);
						}
					}
				}
			}
		}
		
		void IntroScreen::drawStars(QPainter& p) {
			if (Constants::STAR_PROBABILITY[level_index] <= 0.001) return;
			
			const int BLOCK = 20;
			const int camGX = m_camX / PIXEL_SIZE;
			const int camGY = m_camY / PIXEL_SIZE;
			
			const int startBX = (camGX) / BLOCK - 1;
			const int endBX   = (camGX + gridW()) / BLOCK + 1;
			const int startBY = (-camGY) / BLOCK - 1;
			const int endBY   = (-camGY + gridH()) / BLOCK + 1;
			
			for (int bx = startBX; bx <= endBX; ++bx) {
				for (int by = startBY; by <= endBY; ++by) {
					quint32 h = 120003212u;
					h ^= quint32(bx); h *= 16777619u;
					h ^= quint32(by); h *= 16777619u;
					h = (h ^ bx) / (h ^ by) + (bx * by) - (3 * bx*bx + 4 * by*by);
					
					std::mt19937 rng(h);
					std::uniform_real_distribution<float> fdist(0.0f, 1.0f);
					
					if (fdist(rng) < Constants::STAR_PROBABILITY[level_index] * 0.4) {
						std::uniform_int_distribution<int> idist(0, BLOCK - 1);
						int wgx = bx * BLOCK + idist(rng);
						int wgy = by * BLOCK + idist(rng);
						
						int groundGy = 0;
						auto it = m_heightAtGX.constFind(wgx);
						if (it != m_heightAtGX.constEnd()) groundGy = it.value();
						else groundGy = 10000;
						
						if (wgy < groundGy - 8) {
							int sgx = wgx - camGX;
							int sgy = wgy + camGY;
							int alpha = std::uniform_int_distribution<int>(100, 255)(rng);
							plotGridPixel(p, sgx, sgy, QColor(255, 255, 255, alpha));
						}
					}
				}
			}
		}
		
		void IntroScreen::resizeEvent(QResizeEvent*) {
			m_camXFarthest = m_camX;
		}
		
		int IntroScreen::textWidthCells(const QString& s, int scale) const {
			if (s.isEmpty()) return 0;
			return (int(s.size()) - 1) * CHAR_ADV * scale + 5 * scale;
		}
		
		int IntroScreen::fitTextScaleToRect(int wCells, int hCells, const QString& s) const {
			int padX = 4;
			int padY = 2;
			int maxScale = 10;
			
			int wcap = std::max(1, (wCells - padX) / std::max(1, textWidthCells(s, 1)));
			int hcap = std::max(1, (hCells - padY) / 7);
			
			int sc   = std::min(wcap, hcap);
			sc = std::clamp(sc, 1, maxScale);
			return sc;
		}
		
		void IntroScreen::drawCircleFilledMidpointGrid(QPainter& p, int gcx, int gcy, int gr, const QColor& c) {
			int x = 0;
			int y = gr;
			int d = 1 - gr;
			auto span = [&](int cy, int xl, int xr) {
				for (int xg = xl; xg <= xr; ++xg) plotGridPixel(p, xg, cy, c);
			};
			while (y >= x) {
				span(gcy + y, gcx - x, gcx + x);
				span(gcy - y, gcx - x, gcx + x);
				span(gcy + x, gcx - y, gcx + y);
				span(gcy - x, gcx - y, gcx + y);
				++x;
				if (d < 0) d += 2 * x + 1;
				else { --y; d += 2 * (x - y) + 1; }
			}
		}
		
		void IntroScreen::paintEvent(QPaintEvent*) {
			QImage bg(size(), QImage::Format_ARGB32_Premultiplied);
			bg.fill(Constants::SKY_COLOR[level_index]);
			{
				QPainter pb(&bg);
				drawBackground(pb);
			}
			
			int sw = std::max(1, int(width() * m_blurScale));
			int sh = std::max(1, int(height() * m_blurScale));
			QImage small = bg.scaled(sw, sh, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
			
			QPainter p(this);
			p.drawImage(rect(), small, small.rect());
			
			const int r = 3;
			int iconGX = 2 + r;
			int iconGY = 2 + r;
			
			drawCircleFilledMidpointGrid(p, iconGX, iconGY, r, QColor(195,140,40));
			drawCircleFilledMidpointGrid(p, iconGX, iconGY, std::max(1, r-1), QColor(250,204,77));
			plotGridPixel(p, iconGX-1, iconGY-r+1, QColor(255,255,220));
			
			double scale = 1;
			QString total = QString("%1").arg(m_grandTotalCoins);
			int labelGX = iconGX + r*2 + 2;
			int labelGY = iconGY - (7*scale)/3;
			drawPixelText(p, total, labelGX, labelGY, (double)scale, Constants::TEXT_COLOR[level_index], false);
			
			const QString title = "Braking Bad";
			int ts = titleScale();
			int titleWCells = textWidthCells(title, ts);
			int tgx = (gridW() - titleWCells) / 2;
			int tgy = titleYCells();
			drawPixelText(p, title, tgx, tgy, ts, Constants::TEXT_COLOR[level_index], true);
			
			// --- Level selector ---
			QRect rLevelPrev = buttonRectLevelPrev();
			QRect rLevelNext = buttonRectLevelNext();
			
			p.setPen(Qt::NoPen);
			p.setBrush(QColor(0,0,0,160));
			p.drawRect(rLevelPrev.translated(3*PIXEL_SIZE,3*PIXEL_SIZE));
			p.drawRect(rLevelNext.translated(3*PIXEL_SIZE,3*PIXEL_SIZE));
			
			p.setBrush(QColor(150, 150, 160));
			p.drawRect(rLevelPrev);
			p.drawRect(rLevelNext);
			
			QString sPrev = "<";
			QString sNext = ">";
			int prevScale = fitTextScaleToRect(rLevelPrev.width()/PIXEL_SIZE, rLevelPrev.height()/PIXEL_SIZE, sPrev);
			int nextScale = fitTextScaleToRect(rLevelNext.width()/PIXEL_SIZE, rLevelNext.height()/PIXEL_SIZE, sNext);
			
			drawPixelText(p, sPrev,
			rLevelPrev.left()/PIXEL_SIZE + (rLevelPrev.width()/PIXEL_SIZE - textWidthCells(sPrev, prevScale))/2,
			rLevelPrev.top()/PIXEL_SIZE  + (rLevelPrev.height()/PIXEL_SIZE - 7*prevScale)/2,
			prevScale, QColor(25,20,24), false);
			
			drawPixelText(p, sNext,
			rLevelNext.left()/PIXEL_SIZE + (rLevelNext.width()/PIXEL_SIZE - textWidthCells(sNext, nextScale))/2,
			rLevelNext.top()/PIXEL_SIZE  + (rLevelNext.height()/PIXEL_SIZE - 7*nextScale)/2,
			nextScale, QColor(25,20,24), false);
			
			QString levelName = m_levelNames[level_index];
			int levelScale = 2;
			int levelWCells = textWidthCells(levelName, levelScale);
			int levelGX = (gridW() - levelWCells) / 2;
			const int stageGapCells = (TITLE_STAGE_GAP_PX + PIXEL_SIZE - 1) / PIXEL_SIZE;
			
			int levelGY = rLevelPrev.top()/PIXEL_SIZE
			+ (rLevelPrev.height()/PIXEL_SIZE - 7*levelScale)/2
			+ stageGapCells;
			
			drawPixelText(p, levelName, levelGX, levelGY, levelScale, Constants::TEXT_COLOR[level_index], true);
			
			QRect rStart;
			QRect rExit  = buttonRectExit();
			
			p.setPen(Qt::NoPen);
			
			if (levels_unlocked[level_index])
			{
				rStart = buttonRectStart();
				p.setBrush(QColor(0,0,0,160));
				p.drawRect(rStart.translated(3*PIXEL_SIZE,3*PIXEL_SIZE));
				p.setBrush(QColor(240,190,60));
				p.drawRect(rStart);
				
				QString sStart = "PLAY";
				int rStartWc = rStart.width()  / PIXEL_SIZE;
				int rStartHc = rStart.height() / PIXEL_SIZE;
				int bsStart = fitTextScaleToRect(rStartWc, rStartHc, sStart);
				int sWCells = textWidthCells(sStart, bsStart);
				int sGX = rStart.left()/PIXEL_SIZE + (rStartWc - sWCells)/2;
				int sGY = rStart.top()/PIXEL_SIZE  + (rStartHc - 7*bsStart)/2;
				drawPixelText(p, sStart, sGX, sGY, bsStart,  QColor(20,20,20), false);
			}
			else
			{
				rStart = buttonRectUnlock();
				
				int cost = m_levelCosts.value(level_index, 999);
				bool canAfford = (m_grandTotalCoins >= (quint64)cost);
				
				// Draw shadow
				p.setBrush(QColor(0,0,0,160));
				p.drawRect(rStart.translated(3*PIXEL_SIZE,3*PIXEL_SIZE));
				
				// Draw button (gray)
				p.setBrush(QColor(100, 100, 110));
				p.drawRect(rStart);
				
				// Draw text
				QString sStart = QString("UNLOCK: %1").arg(cost);
				int rStartWc = rStart.width()  / PIXEL_SIZE;
				int rStartHc = rStart.height() / PIXEL_SIZE;
				
				int bsStart = fitTextScaleToRect(rStartWc, rStartHc, sStart);
				
				int sWCells = textWidthCells(sStart, bsStart);
				int sGX = rStart.left()/PIXEL_SIZE + (rStartWc - sWCells)/2;
				int sGY = rStart.top()/PIXEL_SIZE  + (rStartHc - 7*bsStart)/2;
				QColor textColor = canAfford ? QColor(20, 20, 20) : QColor(255, 80, 80);
				drawPixelText(p, sStart, sGX, sGY, bsStart, textColor, false);
			}
			
			p.setBrush(QColor(0,0,0,160));
			p.drawRect(rExit.translated(3*PIXEL_SIZE,3*PIXEL_SIZE));
			p.setBrush(QColor(200,80,90));
			p.drawRect(rExit);
			
			QString sExit  = "EXIT";
			
			int rExitWc  = rExit.width()   / PIXEL_SIZE;
			int rExitHc  = rExit.height()  / PIXEL_SIZE;
			
			int bsExit  = fitTextScaleToRect(rExitWc,  rExitHc,  sExit);
			
			int eWCells = textWidthCells(sExit,  bsExit);
			
			int eGX = rExit.left()/PIXEL_SIZE  + (rExitWc  - eWCells)/2;
			int eGY = rExit.top()/PIXEL_SIZE   + (rExitHc  - 7*bsExit)/2;
			
			drawPixelText(p, sExit,  eGX, eGY,  bsExit,  QColor(20,20,20), false);
		}
		
		void IntroScreen::mousePressEvent(QMouseEvent* e) {
			if (buttonRectLevelPrev().contains(e->pos())) {
				level_index--;
				if (level_index < 0) level_index = m_levelNames.size() - 1;
				update();
				return;
			}
			
			if (buttonRectLevelNext().contains(e->pos())) {
				level_index++;
				if (level_index >= m_levelNames.size()) level_index = 0;
				update();
				return;
			}
			
			if (buttonRectStart().contains(e->pos()) && levels_unlocked[level_index]) {
				emit startRequested(level_index);
				return;
			}
			
			if (buttonRectUnlock().contains(e->pos())){
				int cost = m_levelCosts.value(level_index, 0);
				bool canAfford = (m_grandTotalCoins >= (quint64)cost);
				if(canAfford){
					m_grandTotalCoins -= cost;
					levels_unlocked[level_index] = true;
					saveGrandCoins();
					saveUnlocks();
					update();
				}
				return;
			}
			if (buttonRectExit().contains(e->pos()))  { emit exitRequested();             return; }
		}
		
		QRect IntroScreen::buttonRectLevelPrev() const {
			int hCells = std::max(10, gridH()/18);
			int wCells = hCells;
			const int stageGapCells = (TITLE_STAGE_GAP_PX + PIXEL_SIZE - 1) / PIXEL_SIZE;
			
			int yCells = startTopCells(0) - hCells - std::max(10, gridH()/40) + stageGapCells;
			
			const int fixedOffset = 80;
			int gx = (gridW() / 2) - fixedOffset - wCells;
			
			return QRect(gx*PIXEL_SIZE, yCells*PIXEL_SIZE, wCells*PIXEL_SIZE, hCells*PIXEL_SIZE);
		}
		
		QRect IntroScreen::buttonRectLevelNext() const {
			int hCells = std::max(10, gridH()/18);
			int wCells = hCells;
			const int stageGapCells = (TITLE_STAGE_GAP_PX + PIXEL_SIZE - 1) / PIXEL_SIZE;
			
			int yCells = startTopCells(0) - hCells - std::max(10, gridH()/40) + stageGapCells;
			
			
			const int fixedOffset = 80;
			int gx = (gridW() / 2) + fixedOffset;
			
			return QRect(gx*PIXEL_SIZE, yCells*PIXEL_SIZE, wCells*PIXEL_SIZE, hCells*PIXEL_SIZE);
		}
		
		int IntroScreen::stageLabelBottomPx() const {
			QRect rLevelPrev = buttonRectLevelPrev();
			const int levelScale = 2;
			int levelTopCells = rLevelPrev.top()/PIXEL_SIZE
			+ (rLevelPrev.height()/PIXEL_SIZE - 7*levelScale)/2
			+ std::max(3, gridH()/40);
			int bottomCells = levelTopCells + 7*levelScale;
			return bottomCells * PIXEL_SIZE;
		}
		
		QRect IntroScreen::buttonRectStart() const {
			int wCells = std::min(std::max(gridW()/6, 30), 50);
			int hCells = std::max(10, gridH()/18);
			int gx     = (gridW() - wCells) / 2;
			
			int topPx  = stageLabelBottomPx() + 100;
			int maxTop = gridH()*PIXEL_SIZE - hCells*PIXEL_SIZE - 1;
			if (topPx > maxTop) topPx = maxTop;
			
			return QRect(gx*PIXEL_SIZE, topPx, wCells*PIXEL_SIZE, hCells*PIXEL_SIZE);
		}
		
		QRect IntroScreen::buttonRectExit() const {
			int wCells = std::min(std::max(gridW()/6, 30), 50);
			int hCells = std::max(10, gridH()/18);
			int gx     = (gridW() - wCells) / 2;
			
			int gapCells = std::max(10, gridH()/40);
			int topPx    = stageLabelBottomPx() + 50 + hCells*PIXEL_SIZE + gapCells*PIXEL_SIZE;
			int maxTop   = gridH()*PIXEL_SIZE - hCells*PIXEL_SIZE - 1;
			if (topPx > maxTop) topPx = maxTop;
			
			return QRect(gx*PIXEL_SIZE, topPx, wCells*PIXEL_SIZE, hCells*PIXEL_SIZE);
		}
		
		QRect IntroScreen::buttonRectUnlock() const{
			int wCells = std::min(std::max(gridW()/2, 80), 120);
			int hCells = std::max(10, gridH()/18);
			int gx     = (gridW() - wCells) / 2;
			
			int topPx  = stageLabelBottomPx() + 100;
			int maxTop = gridH()*PIXEL_SIZE - hCells*PIXEL_SIZE - 1;
			if (topPx > maxTop) topPx = maxTop;
			
			return QRect(gx*PIXEL_SIZE, topPx, wCells*PIXEL_SIZE, hCells*PIXEL_SIZE);
		}
		
		void IntroScreen::drawBackground(QPainter& p) {
			p.fillRect(rect(), Constants::SKY_COLOR[level_index]);
			drawStars(p);
			drawClouds(p);
			drawFilledTerrain(p);
		}
		
		void IntroScreen::drawFilledTerrain(QPainter& p) {
			const int camGX = m_camX / PIXEL_SIZE;
			const int camGY = m_camY / PIXEL_SIZE;
			
			for (int sgx = 0; sgx <= gridW(); ++sgx) {
				const int worldGX = sgx + camGX;
				auto it = m_heightAtGX.constFind(worldGX);
				if (it == m_heightAtGX.constEnd()) continue;
				
				const int groundWorldGY = it.value();
				int startScreenGY = groundWorldGY + camGY;
				if (startScreenGY < 0) startScreenGY = 0;
				if (startScreenGY >= gridH()) continue;
				
				for (int sGY = startScreenGY; sGY <= gridH(); ++sGY) {
					const int worldGY = sGY - camGY;
					
					int depth = sGY - startScreenGY;
					if (level_index == 5) {
						QColor c;
						if (depth < 14) {
							if (depth == 0) c = QColor(80, 80, 85);
							else if (depth >= 6 && depth <= 7 && (worldGX % 20 < 10)) {
								c = QColor(240, 190, 40);
							}
							else c = QColor(50, 50, 55);
							
							plotGridPixel(p, sgx, sGY, c);
							continue;
						}
					}
					
					bool topZone = (sGY < groundWorldGY + camGY + 3*SHADING_BLOCK);
					const QColor shade = grassShadeForBlock(worldGX, worldGY, topZone);
					plotGridPixel(p, sgx, sGY, shade);
					
					if (level_index != 5) {
						const QColor edge = grassShadeForBlock(worldGX, groundWorldGY, true).darker(115);
						plotGridPixel(p, sgx, groundWorldGY + camGY, edge);
					}
				}
				
				const QColor edge = grassShadeForBlock(worldGX, groundWorldGY, true).darker(115);
				plotGridPixel(p, sgx, groundWorldGY + camGY, edge);
			}
		}
		
		QColor IntroScreen::grassShadeForBlock(int worldGX, int worldGY, bool greenify) const {
			auto hash2D = [](int x, int y)->quint32{
				quint32 h = 120003212u;
				h ^= quint32(x); h *= 16777619u;
				h ^= quint32(y); h *= 16777619u;
				return (h ^ x) / (h ^ y) + (x * y) - (3 * x*x + 4 * y*y);
			};
			
			const int bx = worldGX / SHADING_BLOCK;
			const int by = worldGY / SHADING_BLOCK;
			const quint32 h = hash2D(bx, by);
			
			if (greenify) {
				const int idxG = int(h % m_grassPalette.size());
				return m_grassPalette[level_index][idxG];
			} else {
				const int idxD = int(h % m_dirtPalette.size());
				return m_dirtPalette[level_index][idxD];
			}
		}
		
		void IntroScreen::plotGridPixel(QPainter& p, int gx, int gy, const QColor& c) {
			if (gx < 0 || gy < 0 || gx >= gridW()+1 || gy >= gridH()+1) return;
			p.fillRect(gx * PIXEL_SIZE, gy * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE, c);
		}
		
		void IntroScreen::rasterizeSegmentToHeightMapWorld(int x1,int y1,int x2,int y2){
			if (x2 < x1) { std::swap(x1,x2); std::swap(y1,y2); }
			
			const int gx1 = x1 / PIXEL_SIZE;
			const int gx2 = x2 / PIXEL_SIZE;
			
			if (x2 == x1) {
				const int gy = int(std::floor(y1 / double(PIXEL_SIZE) + 0.5));
				m_heightAtGX.insert(gx1, gy);
				return;
			}
			
			const double dx = double(x2 - x1);
			double dy = double(y2 - y1);
			
			for (int gx = gx1; gx <= gx2; ++gx) {
				const double wx = gx * double(PIXEL_SIZE);
				double t = (wx - x1) / dx;
				t = std::clamp(t, 0.0, 1.0);
				const double wy = y1 + t * dy;
				const int gy = int(std::floor(wy / double(PIXEL_SIZE) + 0.5));
				m_heightAtGX.insert(gx, gy);
			}
		}
		
		void IntroScreen::pruneHeightMap() {
			if (m_lines.isEmpty()) return;
			const int keepFromGX = (m_lines.first().getX1() / PIXEL_SIZE) - 4;
			
			QList<int> toRemove;
			toRemove.reserve(m_heightAtGX.size());
			
			for (auto it = m_heightAtGX.constBegin(); it != m_heightAtGX.constEnd(); ++it) {
				if (it.key() < keepFromGX) toRemove.append(it.key());
			}
			for (int k : toRemove) m_heightAtGX.remove(k);
		}
		
		void IntroScreen::ensureAheadTerrain(int worldX) {
			while (m_lastX < worldX) {
				m_slope += (0.5f - float(m_lastY) / std::max(1,height())) * m_difficulty;
				m_slope = std::clamp(m_slope, -1.0f, 1.0f);
				
				const int newY = m_lastY + std::lround(m_slope * std::pow(std::abs(m_slope), 0.02f) * STEP);
				
				Line seg(m_lastX, m_lastY, m_lastX + STEP, newY);
				m_lines.append(seg);
				
				rasterizeSegmentToHeightMapWorld(seg.getX1(), m_lastY, seg.getX2(), newY);
				
				m_lastY = newY;
				m_lastX += STEP;
				
				if (m_lines.size() > (width() / STEP) * 3) {
					m_lines.removeFirst();
					pruneHeightMap();
				}
				
				m_difficulty += DIFF_INC;
			}
		}
		
		void IntroScreen::drawPixelText(QPainter& p, const QString& s, int gx, int gy, int scale, const QColor& c, bool bold)
		{
			auto plot = [&](int x,int y,const QColor& col) {
				plotGridPixel(p, gx + x, gy + y, col);
			};
			
			for (int i = 0; i < s.size(); ++i) {
				const QChar ch = s.at(i).toUpper();
				const auto rows = font_map.value(font_map.contains(ch) ? ch : QChar(' '));
				int baseOff = i * CHAR_ADV * scale;
				for (int ry = 0; ry < 7; ++ry) {
					uint8_t row = rows[ry];
					for (int rx = 0; rx < 5; ++rx) {
						if (row & (1 << (4 - rx))) {
							for (int sy = 0; sy < scale; ++sy) {
								for (int sx = 0; sx < scale; ++sx) {
									if (bold) {
										plot(baseOff + rx*scale + sx - 1, ry*scale + sy, c);
										plot(baseOff + rx*scale + sx + 1, ry*scale + sy, c);
										plot(baseOff + rx*scale + sx, ry*scale + sy - 1, c);
										plot(baseOff + rx*scale + sx, ry*scale + sy + 1, c);
									}
									plot(baseOff + rx*scale + sx, ry*scale + sy, c);
								}
							}
						}
					}
				}
			}
		}
		
		
		void IntroScreen::saveGrandCoins() const {
			QSettings s("JU","F1PixelGrid");
			s.setValue("grandCoins", m_grandTotalCoins);
			s.sync();
		}
		
		void IntroScreen::loadGrandCoins() {
			QSettings s("JU","F1PixelGrid");
			m_grandTotalCoins = s.value("grandCoins", 0).toInt();
		}
		
		void IntroScreen::saveUnlocks() const {
			QSettings s("JU","F1PixelGrid");
			
			QVariantList unlockList;
			
			for(bool unlocked : levels_unlocked) {
				unlockList.append(unlocked);
			}
			
			s.setValue("unlocks", unlockList);
			s.sync();
		}
		
		void IntroScreen::loadUnlocks() {
			QSettings s("JU","F1PixelGrid");
			QVariant unlockData = s.value("unlocks");
			
			if (unlockData.isValid()) {
				
				QVariantList savedList = unlockData.toList();
				
				levels_unlocked.clear();
				
				for(const QVariant& item : savedList) {
					levels_unlocked.append(item.toBool());
				}
				
				while(levels_unlocked.size() != m_levelCosts.size()) {
					levels_unlocked.append(false);
				}
				
				saveUnlocks();
				
				if (levels_unlocked.size() > 5) {
					levels_unlocked[5] = false;
				}
			}
			else
			{
				levels_unlocked = {true, false, false, false, false, false};
			}
		}
	\end{lstlisting}
	
	\subsection*{Intro Screen Feature}
	The intro screen is implemented as a dedicated \texttt{IntroScreen} widget, which \texttt{MainWindow} uses as the initial scene before gameplay. Its primary purpose is to provide a visually rich landing page that already reflects the in–game environment. Internally, it constructs a scrolling terrain by generating line segments and rasterising them into a height map. A \texttt{QTimer} advances a virtual camera and triggers terrain extension and pruning, so the background continuously moves even while the player is idle on the menu.
	
	Rendering is handled in \texttt{paintEvent()}, which first draws into an off–screen \texttt{QImage}. Helper functions such as \texttt{drawBackground()}, \texttt{drawStars()}, \texttt{drawClouds()} and \texttt{drawFilledTerrain()} are used to compose the sky, star field, cloud layers and ground, all in a pixel–art style controlled by a logical grid. The result is then scaled and blitted to the widget to produce a slightly softened backdrop. On top of this, the intro screen overlays the game title (and any summary information) using a custom 5x7 pixel font. Mouse events are interpreted to detect clicks on the ``PLAY'' and ``EXIT'' areas, and the widget emits the high–level signals \texttt{startRequested()} and \texttt{exitRequested()}, which \texttt{MainWindow} uses to transition into the game or close the application.
	
	\begin{figure}[h]
    \centering
    \begin{subfigure}{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/intro_screen_meadow.png}
        \caption{Intro Screen: Stage -- Meadow}
        \label{fig:intro-meadow}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/intro_screen_nightlife.png}
        \caption{Intro Screen: Stage -- Nightlife}
        \label{fig:intro-martian}
    \end{subfigure}
    \caption{Intro screen for two different stages.}
    \label{fig:intro-two-stages}
    \end{figure}

	
	\subsubsection*{outro.h}
	\begin{lstlisting}[style=cgstyle,language=C++]
		// outro.h
		#pragma once
		#include <QWidget>
		#include <QRect>
		
		class QPushButton;
		class QPaintEvent;
		class QResizeEvent;
		class QMouseEvent;
		
		class OutroScreen : public QWidget {
			Q_OBJECT
			public:
			explicit OutroScreen(QWidget* parent = nullptr);
			void setStats(int coinCount, int nitroCount, int score, double distanceMeters);
			void setFlips(int flips);
			
			signals:
			void exitRequested();
			void restartRequested();
			
			protected:
			void paintEvent(QPaintEvent* e) override;
			void resizeEvent(QResizeEvent* e) override;
			void mousePressEvent(QMouseEvent* e) override;
			
			private:
			void centerInParent();
			void drawPixelCoin(QPainter& p, int gx, int gy, int rCells);
			void drawPixelFlame(QPainter& p, int gx, int gy, int lenCells);
			
			int m_flips = 0;
			
			private:
			QPushButton* m_exitBtn = nullptr;
			int  m_cell   = 6;
			
			int m_coins = 0;
			int m_nitros = 0;
			int m_score = 0;
			double m_distanceM = 0.0;
			
			QRect m_btnExitRect;
			QRect m_btnRestartRect;
		};
	\end{lstlisting}
	
	
	\subsubsection*{outro.cpp}
	\begin{lstlisting}[style=cgstyle,language=C++]
		// outro.cpp
		#include "outro.h"
		#include "intro.h"
		#include "constants.h"
		#include <QPainter>
		#include <QPaintEvent>
		#include <QPushButton>
		#include <QMouseEvent>
		#include <QMap>
		#include <array>
		#include <initializer_list>
		#include <algorithm>
		
		namespace {
			
			constexpr int CHAR_ADV = 7;
			
			inline int textHeightCells(int scale){ return 7*scale; }
			
			inline void plotGridPixel(QPainter& p, int cell, int gx, int gy, const QColor& c) {
				p.fillRect(gx*cell, gy*cell, cell, cell, c);
			}
			
			inline int textWidthCells(const QString& s, int scale){
				return s.isEmpty()?0:((int)s.size()-1)*CHAR_ADV*scale + 5*scale;
			}
			
			inline int fitTextScale(int wCells, int hCells, const QString& s){
				int wcap = std::max(1, (wCells-4)/std::max(1,textWidthCells(s,1)));
				int hcap = std::max(1, (hCells-2)/7);
				return std::clamp(std::min(wcap,hcap),1,18);
			}
			
			void drawPixelText(QPainter& p, const QString& s, int cell, int gx, int gy, int scale, const QColor& c, bool bold){
				auto plot=[&](int x,int y,const QColor& col){ plotGridPixel(p,cell,gx+x,gy+y,col); };
				for(int i=0;i<s.size();++i){
					const QChar ch = s.at(i).toUpper();
					const auto rows = ::font_map.value(::font_map.contains(ch) ? ch : QChar(' '));
					int base=i*CHAR_ADV*scale;
					for(int ry=0;ry<7;++ry){
						uint8_t row=rows[ry];
						for(int rx=0;rx<5;++rx){
							if(row&(1<<(4-rx))){
								for(int sy=0;sy<scale;++sy){
									for(int sx=0;sx<scale;++sx){
										if(bold){
											plot(base+rx*scale+sx-1,ry*scale+sy,QColor(20,20,22));
											plot(base+rx*scale+sx+1,ry*scale+sy,QColor(20,20,22));
											plot(base+rx*scale+sx,ry*scale+sy-1,QColor(20,20,22));
											plot(base+rx*scale+sx,ry*scale+sy+1,QColor(20,20,22));
										}
										plot(base+rx*scale+sx,ry*scale+sy,c);
									}
								}
							}
						}
					}
				}
			}
		}
		
		OutroScreen::OutroScreen(QWidget* parent)
		: QWidget(parent)
		{
			setAttribute(Qt::WA_StyledBackground, true);
			setAutoFillBackground(true);
			QPalette pal=palette();
			pal.setColor(QPalette::Window, QColor(15,12,20,230));
			setPalette(pal);
			
			m_exitBtn=new QPushButton("Exit",this);
			m_exitBtn->setCursor(Qt::PointingHandCursor);
			connect(m_exitBtn,&QPushButton::clicked,this,[this]{ emit exitRequested(); });
			m_exitBtn->hide();
			
			// Larger panel
			if(parent){
				int w = int(parent->width()  * 0.60);
				int h = int(parent->height() * 0.50);
				resize(w, h);
				centerInParent();
			}
			m_cell=std::max(4,std::min(width(),height())/90);
			setFocusPolicy(Qt::StrongFocus);
			setVisible(true);
			raise();
		}
		
		void OutroScreen::centerInParent(){
			if(!parentWidget()) return;
			move(parentWidget()->width()/2 - width()/2, parentWidget()->height()/2 - height()/2);
		}
		
		void OutroScreen::setStats(int coinCount, int nitroCount, int score, double distanceMeters){
			m_coins  = coinCount;
			m_nitros = nitroCount;
			m_score  = score;
			m_distanceM = distanceMeters;
			update();
		}
		
		void OutroScreen::paintEvent(QPaintEvent*){
			QPainter p(this);
			p.setRenderHint(QPainter::Antialiasing,false);
			p.setRenderHint(QPainter::TextAntialiasing,false);
			
			const int cell = m_cell;
			const int pad = cell;
			
			const int gw = (width()-2*pad)/cell;
			const int gh = (height()-2*pad)/cell;
			const int panelX = pad;
			const int panelY = pad;
			const QRect panel(panelX,panelY,gw*cell,gh*cell);
			
			p.fillRect(panel,QColor(28,24,36));
			p.setPen(QColor(65,60,80));
			p.drawRect(panel.adjusted(0,0,-1,-1));
			
			const int pgx=panelX/cell;
			const int pgy=panelY/cell;
			auto GX=[&](int c){ return pgx+c; };
			auto GY=[&](int c){ return pgy+c; };
			
			const QString title="GAME OVER";
			const int titleScale = fitTextScale(gw-10, 9, title);
			const int titleW = textWidthCells(title,titleScale);
			const int tGX = GX((gw-titleW)/2);
			const int tGY = GY(std::max(2, gh/10));
			drawPixelText(p,title,cell,tGX,tGY,titleScale,QColor(230,230,240),false);
			
			const int titleH = textHeightCells(titleScale);
			const int topGap = std::max(12, gh/18);
			const int rowGap = std::max(10, gh/24);
			
			const int contentTop = tGY + titleH + topGap;
			
			// Left column (coins / nitro)
			int iconR = std::clamp(gw/50, 2, 5);
			int gapL  = std::max(8, gw/40);
			int leftGX = GX(std::max(6, gw/12));
			
			// Right column strings
			QString scoreStr = QString("SCORE: %1").arg(m_score);
			QString distStr  = QString("DIST: %1 m").arg(QString::number(m_distanceM,'f',1));
			QString flipsStr = QString("FLIPS: x%1").arg(m_flips);
			
			int numScale    = std::max(1, titleScale/2);
			int rightScale  = std::max(1, titleScale/2);
			
			auto leftEndGX = [&](const QString& s, int baseGX){
				return baseGX + gapL + textWidthCells(s, numScale);
			};
			auto rightStartGX = [&](const QString& s){
				int rightPadCells = std::clamp(gw/10, 12, 30);
				int w = textWidthCells(s, rightScale);
				return GX(gw - rightPadCells - w);
			};
			
			// Equal vertical spacing for the three right rows (score, dist, flips)
			const int rightRowH = textHeightCells(rightScale);
			const int row1Y = contentTop;
			const int row2Y = row1Y + rightRowH + rowGap;
			const int row3Y = row2Y + rightRowH + rowGap;
			
			// Ensure left rows don't collide with right rows; shrink scales if necessary
			int iter=12;
			while (iter--){
				int sGX = rightStartGX(scoreStr);
				int dGX = rightStartGX(distStr);
				int fGX = rightStartGX(flipsStr);
				int l1End = leftEndGX(QString("x%1").arg(m_coins), leftGX + iconR);
				int l2End = leftEndGX(QString("x%1").arg(m_nitros), leftGX + iconR);
				bool overlap = (l1End + 2 >= sGX) || (l2End + 2 >= dGX) || (l2End + 2 >= fGX);
				if (!overlap) break;
				if (rightScale > 1) --rightScale;
				if (numScale   > 1) --numScale;
			}
			
			// Left column draw
			drawPixelCoin(p,leftGX,row1Y+3,iconR);
			drawPixelText(p,QString("x%1").arg(m_coins),cell,leftGX+iconR+std::max(8, gw/40),row1Y,numScale,QColor(230,230,240),false);
			
			drawPixelFlame(p,leftGX,row2Y+3,iconR*2);
			drawPixelText(p,QString("x%1").arg(m_nitros),cell,leftGX+iconR+std::max(8, gw/40),row2Y,numScale,QColor(230,230,240),false);
			
			drawPixelText(p, scoreStr, cell, rightStartGX(scoreStr), row1Y, rightScale, QColor(230,230,240), false);
			drawPixelText(p, distStr,  cell, rightStartGX(distStr),  row2Y, rightScale, QColor(230,230,240), false);
			drawPixelText(p, flipsStr, cell, rightStartGX(flipsStr), row3Y, rightScale, QColor(230,230,240), false);
			
			// Buttons: RESTART (left, dark green) and EXIT (right, red)
			const int gwBtn = gw;
			int btnWCells = std::min(std::max(int(gwBtn/4), 24), gwBtn - 12);
			int btnHCells = std::max(9, gh/10);
			int gapCells  = std::max(12, gw/12);
			
			int totalW = btnWCells*2 + gapCells;
			int bGX0 = GX((gwBtn - totalW)/2);
			int bGY  = GY(gh - btnHCells - std::max(3, gh/40));
			
			QRect rRestart(bGX0*cell, bGY*cell, btnWCells*cell, btnHCells*cell);
			QRect rExit   ((bGX0 + btnWCells + gapCells)*cell, bGY*cell, btnWCells*cell, btnHCells*cell);
			
			m_btnRestartRect = rRestart;
			m_btnExitRect = rExit;
			
			// RESTART button (dark green bg, white text)
			p.setPen(Qt::NoPen);
			p.setBrush(QColor(20,100,40));
			p.drawRect(rRestart);
			
			const QString sRestart = "RESTART";
			int innerW = btnWCells-6;
			int innerH = btnHCells-4;
			int rsW = std::max(1, innerW/std::max(1,textWidthCells(sRestart,1)));
			int rsH = std::max(1, innerH/7);
			int rs  = std::clamp(std::min(rsW,rsH),1,12);
			int rLabelW = textWidthCells(sRestart,rs);
			int rGX = rRestart.left()/cell + (btnWCells - rLabelW)/2;
			int rGY = rRestart.top() /cell + (btnHCells - 7*rs)/2;
			drawPixelText(p, sRestart, cell, rGX, rGY, rs, QColor(255,255,255), false);
			
			// EXIT button (red bg, white text)
			p.setBrush(QColor(255,0,0));
			p.drawRect(rExit);
			
			const QString sExit = "EXIT";
			int bsW = std::max(1, innerW/std::max(1,textWidthCells(sExit,1)));
			int bsH = std::max(1, innerH/7);
			int bs  = std::clamp(std::min(bsW,bsH),1,12);
			int labelW = textWidthCells(sExit,bs);
			int txGX = rExit.left()/cell + (btnWCells - labelW)/2;
			int tyGY = rExit.top() /cell + (btnHCells - 7*bs)/2;
			drawPixelText(p, sExit, cell, txGX, tyGY, bs, QColor(255,255,255), false);
			
		}
		
		void OutroScreen::resizeEvent(QResizeEvent*){
			m_cell=std::max(4,std::min(width(),height())/90);
			centerInParent();
			update();
		}
		
		void OutroScreen::mousePressEvent(QMouseEvent* e){
			if (m_btnRestartRect.contains(e->pos())) { emit restartRequested(); return; }
			if(m_btnExitRect.contains(e->pos())){ emit exitRequested(); return; }
			QWidget::mousePressEvent(e);
		}
		
		void OutroScreen::drawPixelCoin(QPainter& p, int gx, int gy, int rCells){
			auto plot=[&](int x,int y,const QColor& c){
				p.fillRect(x*m_cell,y*m_cell,m_cell,m_cell,c);
			};
			
			int x0=gx,y0=gy,r=rCells,x=0,y=r,d=1-r;
			
			auto span=[&](int cy,int xl,int xr,const QColor& c){
				for(int xx=xl;xx<=xr;++xx)
				plot(xx,cy,c);
			};
			
			QColor c1(195,140,40),c2(250,204,77),hl(255,255,220);
			while(y>=x){
				span(y0+y,x0-x,x0+x,c1);
				span(y0-y,x0-x,x0+x,c1);
				span(y0+x,x0-y,x0+y,c1);
				span(y0-x,x0-y,x0+y,c1);
				++x;
				if(d<0) d+=2*x+1;
				else { --y; d+=2*(x-y)+1; }
			}
			
			for(int yy=-r+1; yy<=r-1; ++yy){
				int rad=int(std::floor(std::sqrt(double(r*r-yy*yy))));
				span(y0+yy,x0-rad+1,x0+rad-1,c2);
			}
			
			plot(x0-1,y0-r+1,hl);
		}
		
		void OutroScreen::drawPixelFlame(QPainter& p, int gx, int gy, int lenCells){
			auto plot=[&](int x,int y,const QColor& c){
				p.fillRect(x*m_cell,y*m_cell,m_cell,m_cell,c);
			};
			QColor cOuter(255,100,35),cMid(255,160,45),cCore(255,240,120);
			int x0=gx,y0=gy;
			
			for(int i=0;i<lenCells;++i){
				int cx=x0-i, cy=y0;
				
				int w=std::max(0,2-i/2);
				for(int j=-w;j<=w;++j) plot(cx,cy+j,cOuter);
				
				int w2=std::max(0,w-1);
				for(int j=-w2;j<=w2;++j) plot(cx,cy+j,cMid);
				
				if(w2>=0) plot(cx,cy,cCore);
			}
		}
		
		void OutroScreen::setFlips(int flips) {
			m_flips = std::max(0, flips);
			update();
		}
	\end{lstlisting}
	
	\subsection*{Game Over / Outro Screen Feature}
	The game over interface is implemented as a dedicated \texttt{OutroScreen} widget, created as a child overlay of \texttt{MainWindow}. When a run ends, \texttt{MainWindow} calls \texttt{setStats()} and \texttt{setFlips()} to pass the final coins collected, nitro usage, score, distance travelled (in metres), and number of flips to this widget. The constructor configures a semi–transparent dark background using a styled palette and sizes the panel to a fixed fraction of the parent window, with \texttt{centerInParent()} keeping it visually centred and \texttt{resizeEvent()} recalculating the logical cell size for different resolutions.
	
	The core visual layout is handled in \texttt{paintEvent()}, which renders into a coarse pixel grid. A titled panel (“GAME OVER”) is drawn with the shared 5x7 bitmap font via \texttt{drawPixelText()}, using helper functions \texttt{textWidthCells()} and \texttt{fitTextScale()} to choose an appropriate font scale. The left column shows a coin icon and nitro flame, rendered with \texttt{drawPixelCoin()} and \texttt{drawPixelFlame()}, together with their counts. The right column displays the score, distance, and flips in evenly spaced rows, with dynamic scaling to prevent overlap. At the bottom, two large buttons (“RESTART” and “EXIT”) are drawn as rectangular regions with pixel text; \texttt{mousePressEvent()} tests clicks against these rectangles and emits \texttt{restartRequested()} or \texttt{exitRequested()}, which \texttt{MainWindow} uses to either restart the level or return to the intro screen.
	
	\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/outro_screen.png}
    \caption{Outro Screen: Game Over}
    \label{fig:outro}
    \end{figure}
	
	\subsubsection*{pause.h}
	\begin{lstlisting}[style=cgstyle, language=C++]
		#pragma once
		#include <QWidget>
		#include <QTimer>
		#include <QRect>
		#include <QString>
		#include "constants.h"
		
		class PauseOverlay : public QWidget {
			Q_OBJECT
			public:
			explicit PauseOverlay(QWidget* parent=nullptr);
			void setLevelIndex(int idx);
			void showPaused();
			signals:
			void resumeRequested();
			protected:
			void paintEvent(QPaintEvent*) override;
			void mousePressEvent(QMouseEvent*) override;
			void resizeEvent(QResizeEvent*) override;
			private:
			int m_levelIndex = 0;
			enum State { Paused, CountingDown } m_state = Paused;
			int m_count = 3;
			QTimer m_timer;
			QRect m_resumeRectPx;
			static constexpr int CHAR_ADV = 7;
			inline int gridW() const { return width()  / Constants::PIXEL_SIZE; }
			inline int gridH() const { return height() / Constants::PIXEL_SIZE; }
			int textWidthCells(const QString& s, int scale) const;
			void drawPixelText(QPainter& p, const QString& s, int gx, int gy, int scale, const QColor& c, bool bold);
			void plotGridPixel(QPainter& p, int gx, int gy, const QColor& c);
			QRect resumeRectPx() const;
		};
	\end{lstlisting}
	
	\subsubsection*{pause.cpp}
	\begin{lstlisting}[style=cgstyle, language=C++]
		#include "pause.h"
		#include <QPainter>
		#include <QMouseEvent>
		#include <algorithm>
		
		PauseOverlay::PauseOverlay(QWidget* parent) : QWidget(parent) {
			setAttribute(Qt::WA_TranslucentBackground);
			setAttribute(Qt::WA_NoSystemBackground, false);
			setFocusPolicy(Qt::NoFocus);
			connect(&m_timer, &QTimer::timeout, this, [this]{
				if (--m_count <= 0) { m_timer.stop(); emit resumeRequested(); }
				update();
			});
		}
		
		void PauseOverlay::setLevelIndex(int idx) {
			m_levelIndex = idx;
		}
		
		void PauseOverlay::showPaused() {
			m_state = Paused;
			m_count = 3;
			m_timer.stop();
			show();
			raise();
			update();
		}
		
		void PauseOverlay::paintEvent(QPaintEvent*) {
			QPainter p(this);
			p.fillRect(rect(), QColor(0,0,0,150));
			
			const int gw = gridW();
			const int gh = gridH();
			const QString title = "GAME PAUSED";
			
			int ts = std::clamp(gh / (7 * 8), 2, 6);
			int tw = textWidthCells(title, ts);
			int tgx = (gw - tw) / 2;
			int tgy = gh / 3;
			drawPixelText(p, title, tgx, tgy, ts, Constants::TEXT_COLOR[m_levelIndex], true);
			
			if (m_state == Paused) {
				QRect r = resumeRectPx();
				p.setPen(Qt::NoPen);
				p.setBrush(QColor(0,0,0,160));
				p.drawRect(r.translated(3*Constants::PIXEL_SIZE, 3*Constants::PIXEL_SIZE));
				p.setBrush(QColor(180,180,190));
				p.drawRect(r);
				const QString lab = "RESUME";
				int rc = r.width()  / Constants::PIXEL_SIZE;
				int rr = r.height() / Constants::PIXEL_SIZE;
				int s  = std::clamp(std::min(rc / (int(lab.size())*CHAR_ADV - (CHAR_ADV-5)), rr / 2), 1, 6);
				int gx = r.left()/Constants::PIXEL_SIZE + (rc - textWidthCells(lab, s))/2;
				int gy = r.top() /Constants::PIXEL_SIZE + (rr - 7*s)/2;
				drawPixelText(p, lab, gx, gy, s, QColor(25,25,28), false);
				m_resumeRectPx = r;
			} else {
				const QString num = QString::number(m_count);
				int ns = std::clamp(gh / (7 * 4), 3, 10);
				int nw = textWidthCells(num, ns);
				int ngx = (gw - nw) / 2;
				int ngy = tgy + 7*ts + 8;
				drawPixelText(p, num, ngx, ngy, ns, Constants::TEXT_COLOR[m_levelIndex], true);
			}
		}
		
		void PauseOverlay::mousePressEvent(QMouseEvent* e) {
			if (m_state != Paused) return;
			if (resumeRectPx().contains(e->pos())) {
				m_state = CountingDown;
				m_count = 3;
				m_timer.start(1000);
				update();
			}
		}
		
		void PauseOverlay::resizeEvent(QResizeEvent*) {
			update();
		}
		
		int PauseOverlay::textWidthCells(const QString& s, int scale) const {
			if (s.isEmpty()) return 0;
			return (int(s.size()) - 1) * CHAR_ADV * scale + 5 * scale;
		}
		
		void PauseOverlay::drawPixelText(QPainter& p, const QString& s, int gx, int gy, int scale, const QColor& c, bool bold) {
			auto plot = [&](int x,int y,const QColor& col){ plotGridPixel(p, gx + x, gy + y, col); };
			for (int i = 0; i < s.size(); ++i) {
				const QChar ch = s.at(i).toUpper();
				const auto rows = font_map.value(font_map.contains(ch) ? ch : QChar(' '));
				int baseOff = i * CHAR_ADV * scale;
				for (int ry=0; ry<7; ++ry) {
					uint8_t row = rows[ry];
					for (int rx=0; rx<5; ++rx) {
						if (row & (1<<(4-rx))) {
							for (int sy=0; sy<scale; ++sy) {
								for (int sx=0; sx<scale; ++sx) {
									if (bold) {
										plot(baseOff + rx*scale+sx-1, ry*scale+sy, c);
										plot(baseOff + rx*scale+sx+1, ry*scale+sy, c);
										plot(baseOff + rx*scale+sx, ry*scale+sy-1, c);
										plot(baseOff + rx*scale+sx, ry*scale+sy+1, c);
									}
									plot(baseOff + rx*scale+sx, ry*scale+sy, c);
								}
							}
						}
					}
				}
			}
		}
		
		void PauseOverlay::plotGridPixel(QPainter& p, int gx, int gy, const QColor& c) {
			if (gx < 0 || gy < 0 || gx >= gridW()+1 || gy >= gridH()+1) return;
			p.fillRect(gx * Constants::PIXEL_SIZE, gy * Constants::PIXEL_SIZE, Constants::PIXEL_SIZE, Constants::PIXEL_SIZE, c);
		}
		
		QRect PauseOverlay::resumeRectPx() const {
			int rc = std::min(std::max(gridW()/6, 30), 60);
			int rr = std::max(10, gridH()/18);
			int gx = (gridW() - rc) / 2;
			int gy = gridH()/2;
			return QRect(gx*Constants::PIXEL_SIZE, gy*Constants::PIXEL_SIZE, rc*Constants::PIXEL_SIZE, rr*Constants::PIXEL_SIZE);
		}
	\end{lstlisting}
	
	\subsection*{Pause Overlay Feature}
	
	The pause functionality is implemented as a dedicated \texttt{PauseOverlay} widget that is owned and controlled by \texttt{MainWindow}. When the player presses the pause key, \texttt{MainWindow} invokes \texttt{showPaused()}, which switches the internal state to \texttt{Paused}, resets a 3 second counter, and shows a semi transparent dark overlay above the game. The overlay uses the global pixel size (\texttt{Constants::PIXEL\_SIZE}) and logical grid dimensions \texttt{gridW()} and \texttt{gridH()} to render a centered panel independent of window resolution.
	
	The core rendering is implemented in \texttt{paintEvent()}. It draws a translucent black full screen rectangle and a large pixel font title "GAME PAUSED" using \texttt{drawPixelText()}, with text color selected from \texttt{Constants::TEXT\_COLOR} via \texttt{setLevelIndex()}. In the paused state, a rectangular "RESUME" button is drawn using grid based metrics from \texttt{resumeRectPx()}, and the text scale is computed by \texttt{textWidthCells()} to fit inside the button. When the button is clicked (\texttt{mousePressEvent()}), the overlay switches to the \texttt{CountingDown} state, starts a 1 Hz \texttt{QTimer}, and displays a large countdown (3, 2, 1) in the same pixel font. Each timer tick decrements \texttt{m\_count}, and when it reaches zero, the timer stops and the signal \texttt{resumeRequested()} is emitted, allowing \texttt{MainWindow} to resume the game loop cleanly.
	
	\begin{figure}[h]
    \centering
    \begin{subfigure}{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/pause.png}
        \caption{Game Paused}
        \label{fig:pause}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/pause_countdown.png}
        \caption{Game resuming with countdown}
        \label{fig:pause_countdown}
    \end{subfigure}
    \caption{Pause overlay and countdown sequence.}
    \label{fig:pause-both}
    \end{figure}

    \subsubsection*{Feature: Coins persistence across runs}
	\textbf{Relevant functions:} \texttt{loadGrandCoins()}, \texttt{saveGrandCoins()}, \texttt{showGameOver()}, \texttt{returnToIntro()}, \texttt{closeEvent()}.
	
	This feature uses a separate aggregate counter \texttt{m\_grandTotalCoins} to preserve the total coins earned across all runs, independent of the per-run \texttt{m\_coinCount}. On startup and whenever a new round is prepared, \texttt{loadGrandCoins()} reads the last saved value from \texttt{QSettings} (organisation \texttt{"JU"}, application \texttt{"F1PixelGrid"}) and initialises \texttt{m\_grandTotalCoins}. At the end of a run, both the restart path and the exit path in \texttt{showGameOver()} and \texttt{returnToIntro()} add the current \texttt{m\_coinCount} into \texttt{m\_grandTotalCoins} before resetting the round. \texttt{saveGrandCoins()} then writes this updated total back to \texttt{QSettings} and is also called from \texttt{closeEvent()} to guard against abrupt application exits. As a result, the overall coin total survives across sessions and never resets to zero when starting a new game.

    \vspace{10pt}
    Relevant excerpts from mainwindow.cpp (for reference)
	\begin{lstlisting}[style=cgstyle, language=C++]
		void MainWindow::loadGrandCoins() {
			QSettings s("JU","F1PixelGrid");
			m_grandTotalCoins = s.value("grandCoins", 0).toInt();
		}
		
		void MainWindow::saveGrandCoins() const {
			QSettings s("JU","F1PixelGrid");
			s.setValue("grandCoins", m_grandTotalCoins);
			s.sync();
		}
		
		void MainWindow::showGameOver() {
			if (m_media) m_media->playGameOverOnce();
			if (m_leaderboardMgr) {
				QString stageName = QStringLiteral("UNKNOWN");
				if (level_index >= 0 && level_index < m_levelNames.size()) {
					stageName = m_levelNames[level_index];
				}
				m_leaderboardMgr->submitScore(stageName, m_score);
			}
			if (m_outro) return;
			if (m_timer) m_timer->stop();
			
			m_outro = new OutroScreen(this);
			m_outro->setStats(m_coinCount, m_nitroUses, m_score, (m_totalDistanceCells * Constants::PIXEL_SIZE) / 100.0);
			m_outro->setFlips(m_flip.total());
			m_outro->show();
			m_outro->raise();
			
			connect(m_outro, &OutroScreen::restartRequested, this, [this]{
				if (m_outro) {
					m_outro->hide();
					m_outro->deleteLater();
					m_outro = nullptr;
				}
				m_grandTotalCoins += m_coinCount;
				saveGrandCoins();
				
				resetGameRound();
				m_pause->hide();
				m_roofCrashLatched = false;
				m_gameOverArmed = false;
				if (m_timer) {
					m_clock.restart();
					m_timer->start(10);
				}
				setFocus();
			});
			
			connect(m_outro, &OutroScreen::exitRequested, this, [this]{ returnToIntro(); });
		}		
	\end{lstlisting}
	
	
	\subsubsection*{Feature: Exit flow and return to intro screen}
	\textbf{Relevant functions:} \texttt{showGameOver()}, \texttt{returnToIntro()}, lambda connected to \texttt{IntroScreen::startRequested} inside \texttt{returnToIntro()}.
	
	This behaviour is mainly handled by \texttt{showGameOver()} and \texttt{returnToIntro()}, together with the \texttt{IntroScreen} connections created inside \texttt{returnToIntro()}. When the player clicks the \texttt{EXIT} button on the game-over panel, \texttt{OutroScreen} emits \texttt{exitRequested()}, which \texttt{MainWindow::showGameOver()} connects directly to \texttt{returnToIntro()}. In \texttt{returnToIntro()}, the current run is gracefully closed: the timer is stopped, the session id is advanced, game-over flags are cleared, and any remaining run coins are folded into \texttt{m\_grandTotalCoins} and persisted via \texttt{saveGrandCoins()}. The existing \texttt{OutroScreen} is deleted and all input state is reset. A fresh \texttt{IntroScreen} instance is then constructed, initialised with the last played \texttt{level\_index} and current \texttt{m\_grandTotalCoins}, and shown full-screen. New signal connections from this intro instance back to \texttt{MainWindow} allow the next stage selection to start a completely reset game round.
	
    \vspace{10pt}
    Relevant excerpts from mainwindow.cpp (for reference)
	\begin{lstlisting}[style=cgstyle, language=C++]
	void MainWindow::returnToIntro() {
		loadGrandCoins();
		++m_sessionId;
		m_gameOverArmed = false;
		m_roofCrashLatched = false;
		
		if (m_timer) m_timer->stop();
		
		m_grandTotalCoins += m_coinCount;
		saveGrandCoins();
		
		if (m_outro) {
			m_outro->hide();
			m_outro->deleteLater();
			m_outro = nullptr;
		}
		
		m_accelerating = m_braking = m_nitroKey = false;
		m_prevNitroActive = false;
		
		m_intro = new IntroScreen(this, level_index);
		m_intro->setGeometry(rect());
		m_intro->setGrandCoins(m_grandTotalCoins);
		m_intro->show();
		
		connect(m_intro, &IntroScreen::exitRequested, this, &QWidget::close);
		connect(m_intro, &IntroScreen::startRequested, this, [this](int levelIndex){
			if (m_intro) {
				m_intro->hide();
				m_intro->deleteLater();
				m_intro = nullptr;
			}
			
			level_index = levelIndex;
			
	
			if (m_media) {
				m_media->setStageBgm(level_index);
			}
			
			QPalette pal = palette();
			pal.setColor(QPalette::Window, Constants::SKY_COLOR[level_index]);
			setAutoFillBackground(true);
			setPalette(pal);
            
			resetGameRound();
			setFocus();
			if (m_timer) m_timer->start();
		});
	}
	
	void MainWindow::closeEvent(QCloseEvent* e) {
		saveGrandCoins();
		QWidget::closeEvent(e);
	}
	\end{lstlisting}
	
	\subsubsection*{Feature: Restarting the same stage after Game Over}
	\textbf{Relevant functions:} \texttt{showGameOver()}, \texttt{resetGameRound()}, \texttt{saveGrandCoins()}.
	
	Restarting the same stage after game over is implemented inside \texttt{showGameOver()} through the connection to \texttt{OutroScreen::restartRequested} and the shared reset routine \texttt{resetGameRound()}. When the game-over overlay is created, \texttt{MainWindow} connects the restart signal to a lambda that first hides and deletes the existing \texttt{OutroScreen}. Before reinitialising gameplay, the lambda adds the coins earned in the finished run (\texttt{m\_coinCount}) into \texttt{m\_grandTotalCoins} and calls \texttt{saveGrandCoins()}, ensuring progression is preserved. It then invokes \texttt{resetGameRound()}, which regenerates terrain, re-creates the car, resets fuel, score, nitro state, flip tracker and camera variables, and restarts the internal clock. Game-over latches and pause state are cleared, and the main timer is restarted at a fixed timestep. Because \texttt{level\_index} is left unchanged, the player automatically restarts on the same stage configuration.

    \vspace{10pt}
    Relevant excerpts from mainwindow.cpp (for reference)
	\begin{lstlisting}[style=cgstyle, language=C++]
		void MainWindow::disarmGameOver() { m_gameOverArmed = false; }
		
		void MainWindow::resetGameRound() {
			loadGrandCoins();
			QPalette pal = palette();
			pal.setColor(QPalette::Window, Constants::SKY_COLOR[level_index]);
			setAutoFillBackground(true);
			setPalette(pal);
			
			m_gameOverArmed = false;
			m_roofCrashLatched  = false;
			++m_sessionId;
			
			m_nitroSys = NitroSystem();
			m_fuelSys  = FuelSystem();
			m_coinSys  = CoinSystem();
			
			m_fuel = Constants::FUEL_MAX;
			m_coinCount = 0;
			m_nitroUses = 0;
			m_elapsedSeconds= 0.0;
			
			m_camX = m_camY = m_camVX = m_camVY = 0.0;
			m_cameraX = 0; m_cameraY = 200; m_cameraXFarthest = 0;
			
			m_lines.clear();
			m_heightAtGX.clear();
			m_lastX = 0;
			m_lastY = 0;
			m_slope = 0;
			m_difficulty = Constants::INITIAL_DIFFICULTY[level_index];
			m_irregularity = Constants::INITIAL_IRREGULARITY[level_index];
			m_terrain_height = Constants::INITIAL_TERRAIN_HEIGHT[level_index];
			generateInitialTerrain();
			
			m_clouds.clear();
			m_lastCloudSpawnX = 0;
			m_propSys.clear();
			
			qDeleteAll(m_wheels); m_wheels.clear();
			qDeleteAll(m_bodies); m_bodies.clear();
			
			createCar();
			
			m_totalDistanceCells = 0.0;
			m_score = 0;
			
			{
				double ax = 0.0;
				for (const Wheel* w : m_wheels) ax += w->x;
				m_lastScoreX = m_wheels.isEmpty() ? 0.0 : ax / m_wheels.size();
			}
			
			m_accelerating = m_braking = m_nitroKey = false;
			m_prevNitroActive = false;
			m_flip.reset();
			m_clock.restart();
		}
	\end{lstlisting}
	
	\vspace{30pt}
	\subsubsection*{Feature: On–the–fly HUD score and distance rendering}
	\textbf{Relevant functions:} \texttt{MainWindow::drawHUDDistance()}, \texttt{MainWindow::drawHUDScore()}.
	
	The HUD display of score and distance is layered on top of the world rendering inside \texttt{paintEvent()}. After drawing terrain, props, car, wheels, fuel, coins, nitro flame and flip popups, \texttt{paintEvent()} calls \texttt{drawHUDDistance(p)} and \texttt{drawHUDScore(p)} every frame, ensuring that both values update continuously during gameplay. These helpers use a bold monospace \texttt{QFont}, the per–stage text colour from \texttt{Constants::TEXT\_COLOR[level\_index]}, and \texttt{QFontMetrics} to right–align text against the window edge. \texttt{drawHUDDistance()} converts the accumulated distance in grid cells (\texttt{m\_totalDistanceCells}) into metres using \texttt{PIXEL\_SIZE} and formats it with one decimal place, while \texttt{drawHUDScore()} renders \texttt{m\_score} as an integer directly above the distance label. Together, these functions provide a clean, always–visible summary of run progress.
	
	\subsubsection*{Feature: Continuous score and distance calculation}
	\textbf{Relevant functions:} \texttt{MainWindow::gameLoop()}, \texttt{MainWindow::resetGameRound()}.
	
	Score and travel distance are computed incrementally in \texttt{gameLoop()}, with initialisation performed in \texttt{resetGameRound()}. At the start of each round,
    \[
    D(0) = 0,\quad S(0) = 0,\quad x_{\text{last}} = \overline{x}(0),
    \]
    where $D$ is the total distance in cells, $S$ is the score and $\overline{x}$ is the average $x$–position of all wheels. At simulation step $k$,
    \[
    \overline{x}(k) = \frac{1}{N}\sum_{i=1}^{N} x_i(k), \qquad
    \Delta x(k) = \max\bigl(0,\; \overline{x}(k) - x_{\text{last}}(k-1)\bigr),
    \]
    so reversing never decreases distance. The increment in grid cells is
    \[
    \Delta D(k) = \frac{\Delta x(k)}{\text{PIXEL\_SIZE}}, \qquad
    D(k) = D(k-1) + \Delta D(k),
    \]
    and $x_{\text{last}}(k)$ is updated to $\overline{x}(k)$. The final scalar score is then computed as
    \[
    S = \left\lfloor\; \mathrm{round}\bigl(
    \alpha \, D + \beta \, C + \gamma \, N
    \bigr)\;\right\rfloor,
    \]
    where $C$ is the coin count, $N$ is the number of nitro uses, and
    \vspace{-10pt}
    \[
    \alpha = \texttt{Constants::SCORE\_DIST\_PER\_CELL},\quad
    \beta  = \texttt{Constants::SCORE\_PER\_COIN},\quad
    \gamma = \texttt{Constants::SCORE\_PER\_NITRO}.
    \]

    Relevant excerpts from mainwindow.cpp (for reference)
	\begin{lstlisting}[style=cgstyle, language=C++]
	void MainWindow::drawHUDDistance(QPainter& p) {
		double meters = (m_totalDistanceCells * Constants::PIXEL_SIZE) / 100.0;
		QString s = QString::number(meters, 'f', 1) + " m";
		QFont f; f.setFamily("Monospace"); f.setBold(true); f.setPointSize(12);
		p.setFont(f);
		p.setPen(Constants::TEXT_COLOR[level_index]);
		QFontMetrics fm(f);
		int px = width() - fm.horizontalAdvance(s) - 12;
		int py = (Constants::HUD_TOP_MARGIN + Constants::COIN_RADIUS_CELLS + 2) * Constants::PIXEL_SIZE;
		p.drawText(px, py, s);
	}
	
	void MainWindow::drawHUDScore(QPainter& p) {
		const QString s = QString::number(m_score);
		QFont f; f.setFamily("Monospace"); f.setBold(true); f.setPointSize(12);
		p.setFont(f);
		p.setPen(Constants::TEXT_COLOR[level_index]);
		QFontMetrics fm(f);
		const int rightPadPx = 12;
		const int px = width() - fm.horizontalAdvance(s) - rightPadPx;
		const int distancePy = (Constants::HUD_TOP_MARGIN + Constants::COIN_RADIUS_CELLS + 2) * Constants::PIXEL_SIZE;
		const int gapPx = 8;
		const int py = distancePy - fm.height() - gapPx;
		p.drawText(px, py, s);
	}
	\end{lstlisting}

    \begin{figure}[h]
    \centering
    \begin{subfigure}{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/grand_total_coins _across_all_runs.png}
        \caption{The grand total coins is maintained across all runs. (Top left of the image). It is refreshed every time the game is opened and every time the game gets over.}
        \label{fig:grand_total_coins _across_all_runs}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/on-the-fly_score_ and_dist.png}
        \caption{On the fly score and distance calculation. (Top right of the image). The score calculations have also been described.}
        \label{fig:on-the-fly_score_ and_dist}
    \end{subfigure}
    \caption{grand total coins and on the fly score \& dist metrics}
    \label{fig:grand_total_coins and on_the_fly score \& dist metrics}
\end{figure}
\clearpage


\subsubsection*{Feature: Coin System and HUD Coins Indicator}
\textbf{Relevant classes and functions:} \texttt{CoinSystem}, \texttt{CoinSystem::maybePlaceCoinStreamAtEdge()}, \texttt{CoinSystem::drawWorldCoins()}, \texttt{CoinSystem::handlePickups()}, \texttt{MainWindow::gameLoop()}, \texttt{MainWindow::drawHUDCoins()}.

In my implementation, coins are modelled as light-weight world objects stored in a dedicated \texttt{CoinSystem}. Each coin is represented by integer world coordinates $(c_x, c_y)$ in pixel space and a Boolean flag:
\[
  C_i = (c_{x,i}, c_{y,i}, \texttt{taken}_i), \quad \texttt{taken}_i \in \{0,1\}.
\]
Coins are spawned just outside the current view frustum in short ``streams'' that follow the terrain profile; at run-time they are rendered in world space using a midpoint circle rasteriser and collected via an Euclidean distance test around the car wheels and body.

\paragraph{Temporal and spatial spawning conditions.}
Coin streams are not spawned continuously, but are throttled by a simple time condition. Let $t$ be the current elapsed time in seconds and $t_{\text{last}}$ the time at which the previous stream was spawned. A new stream is considered only if
\[
  \Delta t_{\text{spawn}} = t - t_{\text{last}} \;\geq\; 5.0 \text{ s}.
\]
The stream is also constrained to lie on terrain that already exists ahead of the current camera. If $x_{\text{cam}}$ is the camera world $x$ coordinate, $W_{\text{view}}$ is the view width in pixels, and $x_{\text{terr}}^{\max}$ denotes the last generated terrain $x$ (in pixels), then I compute:
\begin{align*}
  x_{\text{right}}^{\text{view}} &= x_{\text{cam}} + W_{\text{view}},\\
  x_{\text{off}} &= x_{\text{right}}^{\text{view}} + M_{\text{coin}},\\
  x_{\text{terr}}^{\max} &= x_{\text{lastTerrain}} - 10 \cdot s_{\text{px}},
\end{align*}
where $M_{\text{coin}} = \texttt{COIN\_SPAWN\_MARGIN\_CELLS} \cdot s_{\text{px}}$ and $s_{\text{px}} = \texttt{PIXEL\_SIZE}$ is the world-to-grid scale. A coin stream is only spawned if
\[
  x_{\text{terr}}^{\max} > x_{\text{off}},
\]
ensuring there is sufficient terrain to place the entire arc of coins ahead of the player.

\paragraph{Randomised coin streams and sinusoidal vertical offset.}
Every stream draws a random integer length $N$ and horizontal spacing (in grid cells) from uniform distributions:
\[
  N \sim \mathcal{U}(\texttt{COIN\_GROUP\_MIN}, \texttt{COIN\_GROUP\_MAX}), \qquad
  s_{\text{step}} \sim \mathcal{U}(\texttt{COIN\_GROUP\_STEP\_MIN}, \texttt{COIN\_GROUP\_STEP\_MAX}).
\]
The total horizontal width of the stream in pixels is
\[
  W_{\text{stream}} = (N-1)\,s_{\text{step}}\,s_{\text{px}}.
\]
I initially place the leftmost coin at
\[
  x_{\text{start}} = x_{\text{off}} + 2\,s_{\text{px}},
\]
and clamp $(x_{\text{start}}, x_{\text{end}})$ to ensure the group fits before the current terrain limit:
\[
  x_{\text{end}} = x_{\text{start}} + W_{\text{stream}}, \qquad
  x_{\text{end}} \le x_{\text{terr}}^{\max}.
\]
If the naive placement would cross the terrain limit, I simply shift the whole group left so that $x_{\text{end}} = x_{\text{terr}}^{\max}$.

For each coin index $i \in \{0,\dots,N-1\}$, the world $x$ coordinate is
\[
  w_x(i) = x_{\text{start}} + i \cdot s_{\text{step}} \cdot s_{\text{px}}.
\]
I convert this to a terrain grid column
\[
  g_x(i) = \left\lfloor \frac{w_x(i)}{s_{\text{px}}} \right\rfloor,
\]
look up the corresponding ground height $g_y^{\text{ground}}(i)$ from the integer height map \texttt{heightAtGX}, and then place the coin a fixed number of cells above the floor plus a sinusoidal arc. With amplitude $A = \texttt{COIN\_STREAM\_AMP\_CELLS}$ and a random phase $\varphi \in [0, 2\pi)$, the vertical offset in cells is
\[
  \Delta g_y(i) = \big\lfloor \mathrm{round}\big(\sin(\varphi + 0.55\,i)\,A\big) \big\rfloor,
\]
so the final grid $y$ coordinate for coin $i$ becomes
\[
  g_y(i) = g_y^{\text{ground}}(i) - \texttt{COIN\_FLOOR\_OFFSET\_CELLS} - \Delta g_y(i),
\]
and the world pixel coordinates stored in the \texttt{Coin} struct are
\[
  c_{x,i} = w_x(i), \qquad c_{y,i} = g_y(i)\,s_{\text{px}}.
\]

\paragraph{World-space rasterisation of coin sprites.}
To render coins in the world, I reuse the integer midpoint circle algorithm on the logical grid, similar to the wheel and HUD icons. For each coin that has not yet been taken, I convert its world position $(c_x,c_y)$ into screen grid coordinates relative to the camera
\[
  g_x^{\text{screen}} = \frac{c_x}{s_{\text{px}}} - g_x^{\text{cam}}, \qquad
  g_y^{\text{screen}} = \frac{c_y}{s_{\text{px}}} + g_y^{\text{cam}},
\]
where $g_x^{\text{cam}} = \lfloor x_{\text{cam}}/s_{\text{px}} \rfloor$ and $g_y^{\text{cam}} = \lfloor y_{\text{cam}}/s_{\text{px}} \rfloor$ are the camera grid offsets. I then draw three concentric filled discs with radii
\[
  r,\quad r-1,\quad r-2,\qquad r = \texttt{COIN\_RADIUS\_CELLS},
\]
using different colours for rim and fill, plus a small highlight pixel in the top-left of the sprite to suggest specular shine.

\paragraph{Pickup detection with Euclidean distance.}
Coin collection is implemented in two stages. First, I do a radial pickup test against all wheel centres. For each coin $C_i$ that is still active and every wheel centre $(w_{x,j}, w_{y,j})$, I compute the squared Euclidean distance
\[
  d^2_{ij} = (w_{x,j} - c_{x,i})^2 + (w_{y,j} - c_{y,i})^2,
\]
and keep the minimum
\[
  d^2_i = \min_j d^2_{ij}.
\]
With a global pickup radius $R = \texttt{COIN\_PICKUP\_RADIUS}$, the coin is collected if
\[
  d_i^2 \le R^2.
\]
When this condition holds, I mark \texttt{taken} for that coin and increment the run-specific counter \texttt{m\_coinCount}. This \texttt{m\_coinCount} is later folded into the total score and also added to a persistent \texttt{m\_grandTotalCoins} at the end of each run (both on restart and when exiting to the intro screen).

In addition to wheel-based pickups, I perform a more precise overlap check between each remaining coin and the car polygon to catch edge cases where the body intersects a coin without a wheel touching it. For each polygon edge segment $\overline{AB}$, I compute the orthogonal projection of the coin centre $P$ onto the segment:
\[
  t = \mathrm{clamp}_{[0,1]}\left(
    \frac{(P-A)\cdot(B-A)}{\|B-A\|^2}
  \right), \quad
  C = A + t\,(B-A),
\]
and test the squared distance $\|P-C\|^2$ against $R^2$. If no edge collision is found, I also check whether $P$ lies inside the body polygon via an odd-even scan, analogous to a standard point-in-polygon test. Any hit again marks the coin as taken and increments \texttt{m\_coinCount}.

\paragraph{HUD coins indicator.}
On the HUD, I show a compact representation of the current coin count in the top-left corner using the same pixel-grid renderer as the rest of the UI. The HUD circle icon is drawn in grid space at
\[
  g_x^{\text{HUD}} = L_{\text{HUD}} + r + 1, \qquad
  g_y^{\text{HUD}} = T_{\text{HUD}} + r,
\]
where $L_{\text{HUD}}=\texttt{HUD\_LEFT\_MARGIN}$, $T_{\text{HUD}}=\texttt{HUD\_TOP\_MARGIN}$ and $r=\texttt{COIN\_RADIUS\_CELLS}$. These grid coordinates are converted to pixels by multiplying with $s_{\text{px}}$. The icon is rendered as two concentric filled circles plus a highlight, and the numeric coin count is then drawn to the right using a bold monospace \texttt{QFont}. The layout ensures that increments in \texttt{m\_coinCount} are immediately visible to the player after each pickup.

\bigskip
\noindent\textbf{Core code snippets.} The following excerpts show the core of the coin system and HUD implementation used in the project.

coin.h
\begin{lstlisting}[style=cgstyle,language=C++]
#ifndef COIN_H
#define COIN_H

#include <QVector>
#include <QColor>
#include <QPainter>
#include <QHash>
#include <random>
#include "constants.h"
#include "wheel.h"

struct Coin {
    int cx;
    int cy;
    bool taken = false;
};

class CoinSystem {
public:
    QVector<Coin> coins;
    int    lastPlacedCoinX = 0;
    double lastSpawnTimeSec = 0.0;

    void maybePlaceCoinStreamAtEdge(
        double elapsedSeconds,
        int cameraX,
        int viewWidth,
        const QHash<int,int>& heightAtGX,
        int lastTerrainX,
        std::mt19937& rng,
        std::uniform_real_distribution<float>& dist
        );

    void drawWorldCoins(QPainter& p, int cameraX, int cameraY, int gridW, int gridH) const;

    void handlePickups(const QList<Wheel*>& wheels, int& coinCount);
};

#endif // COIN_H
\end{lstlisting}

coin.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "coin.h"
#include <cmath>
#include <algorithm>

void CoinSystem::maybePlaceCoinStreamAtEdge(
    double elapsedSeconds,
    int cameraX,
    int viewWidth,
    const QHash<int,int>& heightAtGX,
    int lastTerrainX,
    std::mt19937& rng,
    std::uniform_real_distribution<float>& dist
    ) {
    if ((elapsedSeconds - lastSpawnTimeSec) < 5.0) {
        return;
    }

    const int viewRightX = cameraX + viewWidth;
    const int marginPx   = Constants::COIN_SPAWN_MARGIN_CELLS * Constants::PIXEL_SIZE;
    const int offRightX  = viewRightX + marginPx;

    const int terrainLimitX = lastTerrainX - Constants::PIXEL_SIZE * 10;
    if (terrainLimitX <= offRightX) {
        return;
    }

    std::uniform_int_distribution<int> coinLenDist(Constants::COIN_GROUP_MIN, Constants::COIN_GROUP_MAX);
    const int groupN = coinLenDist(rng);

    std::uniform_int_distribution<int> stepDist(Constants::COIN_GROUP_STEP_MIN, Constants::COIN_GROUP_STEP_MAX);
    const int stepCells = stepDist(rng);

    const int streamWidthPx = (groupN - 1) * stepCells * Constants::PIXEL_SIZE;

    int startX = offRightX + Constants::PIXEL_SIZE * 2;
    int endX   = startX + streamWidthPx;

    if (endX > terrainLimitX) {
        startX = terrainLimitX - streamWidthPx;
        endX   = terrainLimitX;
    }

    if (startX <= offRightX) {
        return;
    }

    const int ampCells = Constants::COIN_STREAM_AMP_CELLS;
    const double phase = dist(rng) * 6.2831853;

    for (int i = 0; i < groupN; ++i) {
        const int wx = startX + i * (stepCells * Constants::PIXEL_SIZE);
        const int gx = wx / Constants::PIXEL_SIZE;

        auto it = heightAtGX.constFind(gx);
        if (it == heightAtGX.constEnd()) {
            continue;
        }

        const int gyGround = it.value();
        const int arcOffsetCells =
            int(std::lround(std::sin(phase + i * 0.55) * ampCells));
        const int gy = gyGround - Constants::COIN_FLOOR_OFFSET_CELLS - arcOffsetCells;

        Coin c;
        c.cx = wx;
        c.cy = gy * Constants::PIXEL_SIZE;
        c.taken = false;
        coins.append(c);
    }

    lastPlacedCoinX   = endX;
    lastSpawnTimeSec  = elapsedSeconds;
}

void CoinSystem::drawWorldCoins(QPainter& p, int cameraX, int cameraY, int /*gridW*/, int /*gridH*/) const {
    const int camGX = cameraX / Constants::PIXEL_SIZE;
    const int camGY = cameraY / Constants::PIXEL_SIZE;

    QColor rim  (195,140,40);
    QColor fill (250,204,77);
    QColor fill2(245,184,50);
    QColor shine(255,255,220);

    auto plotGridPixel = [&](int gx, int gy, const QColor& c) {
        p.fillRect(gx * Constants::PIXEL_SIZE,
                   gy * Constants::PIXEL_SIZE,
                   Constants::PIXEL_SIZE,
                   Constants::PIXEL_SIZE, c);
    };

    auto drawCircleFilledMidpointGrid = [&](int gcx, int gcy, int gr, const QColor& color) {
        auto span = [&](int cy, int xl, int xr) {
            for (int xg = xl; xg <= xr; ++xg) {
                plotGridPixel(xg, cy, color);
            }
        };
        int x = 0;
        int y = gr;
        int d = 1 - gr;
        while (y >= x) {
            span(gcy + y, gcx - x, gcx + x);
            span(gcy - y, gcx - x, gcx + x);
            span(gcy + x, gcx - y, gcx + y);
            span(gcy - x, gcx - y, gcx + y);
            ++x;
            if (d < 0) {
                d += 2 * x + 1;
            } else {
                --y;
                d += 2 * (x - y) + 1;
            }
        }
    };

    for (const Coin& c : coins) {
        if (c.taken) continue;

        int scx = (c.cx / Constants::PIXEL_SIZE) - camGX;
        int scy = (c.cy / Constants::PIXEL_SIZE) + camGY;
        int r   = Constants::COIN_RADIUS_CELLS;

        drawCircleFilledMidpointGrid(scx, scy, r,   rim);
        if (r-1 > 0) {
            drawCircleFilledMidpointGrid(scx, scy, r-1, fill);
        }
        if (r-2 > 0) {
            drawCircleFilledMidpointGrid(scx, scy, r-2, fill2);
        }

        plotGridPixel(scx-1, scy-r+1, shine);
        plotGridPixel(scx,   scy-r+1, shine);
    }
}

void CoinSystem::handlePickups(const QList<Wheel*>& wheels, int& coinCount) {
    if (wheels.isEmpty()) return;

    for (Coin& c : coins) {
        if (c.taken) continue;
        double minD2 = 1e18;
        for (const Wheel* w : wheels) {
            const double dx = w->x - c.cx;
            const double dy = w->y - c.cy;
            const double d2 = dx*dx + dy*dy;
            if (d2 < minD2) minD2 = d2;
        }
        const double R = Constants::COIN_PICKUP_RADIUS;
        if (minD2 <= R*R) { c.taken = true; ++coinCount; }
    }
}

\end{lstlisting}

mainwindow.cpp (HUD coins excerpt)
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::drawHUDCoins(QPainter& p) {
    int iconGX = Constants::HUD_LEFT_MARGIN + Constants::COIN_RADIUS_CELLS + 1;
    int iconGY = Constants::HUD_TOP_MARGIN  + Constants::COIN_RADIUS_CELLS;
    drawCircleFilledMidpointGrid(p, iconGX, iconGY, Constants::COIN_RADIUS_CELLS, QColor(195,140,40));
    drawCircleFilledMidpointGrid(p, iconGX, iconGY, std::max(1, Constants::COIN_RADIUS_CELLS-1), QColor(250,204,77));
    plotGridPixel(p, iconGX-1, iconGY-Constants::COIN_RADIUS_CELLS+1, QColor(255,255,220));
    QFont f; f.setFamily("Monospace"); f.setBold(true); f.setPointSize(12);
    p.setFont(f);
    p.setPen(Constants::TEXT_COLOR[level_index]);
    int px = (Constants::HUD_LEFT_MARGIN + Constants::COIN_RADIUS_CELLS*2 + 3) * Constants::PIXEL_SIZE;
    int py = (Constants::HUD_TOP_MARGIN  + Constants::COIN_RADIUS_CELLS + 2) * Constants::PIXEL_SIZE;
    p.drawText(px, py, QString::number(m_coinCount));
}
\end{lstlisting}
\begin{figure}[h]
  \centering
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/Coin_spawning.png}
    \caption{Procedural coin stream spawning ahead of the vehicle}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/Coin_collection_&_HUD_update.png}
    \caption{Coin collection and HUD counter update}
  \end{subfigure}
  \caption{Coin system: terrain-following stream placement and real-time collection with HUD feedback.}
\end{figure}

\subsubsection*{Coin System Results}
In practice, the sinusoidal coin streams remained tightly aligned with the generated terrain and always spawned just outside the current view, avoiding unfair or unreachable placements. During gameplay, every successful pickup immediately updated the on-screen coin counter and the persistent grand-total, confirming the correctness of both the world-space collision logic and the HUD integration.
\newline\subsubsection*{Feature: Fuel System, Consumption Model and HUD Fuel Bar}
\textbf{Relevant classes and functions:} \texttt{FuelSystem}, \texttt{FuelSystem::currentFuelSpacing()}, \newline\texttt{FuelSystem::maybePlaceFuelAtEdge()}, \texttt{FuelSystem::drawWorldFuel()}, \texttt{FuelSystem::handlePickups()}, \newline\texttt{MainWindow::gameLoop()}, \texttt{MainWindow::drawHUDFuel()}.

In my implementation, fuel is treated as a continuous scalar resource
\[
  f(t) \in [0, F_{\max}], \qquad F_{\max} = \texttt{Constants::FUEL\_MAX},
\]
normalized to the range $[0,1]$ for HUD display. At the beginning of a run I set
\[
  f(0) = F_{\max},
\]
and the rest of the system either dissipates or refills this quantity as the car moves, accelerates and collects fuel cans.

\paragraph{Fuel consumption per frame.}
Each simulation step has duration $\Delta t = \texttt{dt}$ (in seconds). If there is still fuel available, I subtract a base burn rate and an additional speed-dependent term. Let
\[
  k_{\text{base}} = \texttt{FUEL\_BASE\_BURN\_PER\_SEC}, \qquad
  k_{\text{speed}} = \texttt{FUEL\_EXTRA\_PER\_SPEED},
\]
and let $\bar v(t)$ denote the average horizontal speed of the car at time $t$. The instantaneous burn components are:
\begin{align*}
  b_{\text{base}}(t)  &= k_{\text{base}}\,\Delta t,\\[2pt]
  b_{\text{speed}}(t) &= 
  \begin{cases}
    0, & \text{if the accelerator is not pressed},\\[4pt]
    \max(0,\bar v(t))\,k_{\text{speed}}\,\Delta t, & \text{if accelerating}.
  \end{cases}
\end{align*}
Nitro increases the fuel drain multiplicatively. I define
\[
  \alpha(t) =
  \begin{cases}
    3, & \text{if nitro is active at time } t,\\
    1, & \text{otherwise},
  \end{cases}
\]
and update the continuous fuel value whenever $f(t) > 0$ as
\[
  f(t + \Delta t) \;=\;
  \max\bigl(0,\; f(t) - \alpha(t)\bigl(b_{\text{base}}(t) + b_{\text{speed}}(t)\bigr)\bigr).
\]
In other words, nitro simply triples the total burn. Once $f$ reaches zero, inputs are suppressed and the run will eventually end when either the car flips or forward progress stops.

\paragraph{Spatially adaptive fuel spawning.}
Fuel pickups are modelled as light-weight world-space objects:
\[
  F_i = (w_{x,i}, w_{y,i}, \texttt{taken}_i), \quad \texttt{taken}_i \in \{0,1\},
\]
where $(w_{x,i},w_{y,i})$ are pixel coordinates. To avoid clustering and to make later stages more demanding, I make the spacing between successive cans an explicit function of both difficulty and elapsed run time.

Let $d$ denote the current difficulty (a small positive number) and $t$ the elapsed time in seconds. I first compute an unscaled spacing in pixels:
\begin{align*}
  S_{\text{raw}}(d,t)
  &= 700
   + 500\left(\frac{d}{0.005}\right)
   + 35\,t.
\end{align*}
This is then globally scaled by the factor $E = \texttt{FUEL\_SPAWN\_EASE}$ and clamped to a practical range:
\begin{align*}
  S(d,t)
  &= \mathrm{clip}\Bigl(
      E\,S_{\text{raw}}(d,t),\;
      S_{\min},\;S_{\max}
    \Bigr),\\
  S_{\min} &= 10000\,E, \qquad
  S_{\max} = 200000\,E.
\end{align*}
Here $\mathrm{clip}(x,a,b)=\min(\max(x,a),b)$. Let $x_{\text{lastTerr}}$ be the world $x$ of the last generated terrain vertex and $x_{\text{lastFuel}}$ the $x$ coordinate at which the previous fuel can was placed. A new can is spawned only if
\[
  x_{\text{lastTerr}} - x_{\text{lastFuel}} \;\geq\; S(d,t),
\]
so that increasing difficulty and elapsed time push fuel cans further apart.

When the spacing condition is satisfied, I convert the current terrain tip from pixels to grid space
\[
  g_x = \left\lfloor \frac{x_{\text{lastTerr}}}{s_{\text{px}}} \right\rfloor,
  \qquad s_{\text{px}} = \texttt{PIXEL\_SIZE},
\]
look up the ground height $g_y^{\text{ground}}(g_x)$ from the height map, and place the new can a fixed offset above the floor:
\begin{align*}
  w_{x,\text{new}} &= x_{\text{lastTerr}},\\
  w_{y,\text{new}} &= \bigl(g_y^{\text{ground}}(g_x) - \texttt{FUEL\_FLOOR\_OFFSET\_CELLS}\bigr)\,s_{\text{px}},\\
  \texttt{taken}_{\text{new}} &= 0.
\end{align*}
This ensures that each fuel can sits at a visually consistent height above the terrain, right at the edge of the currently generated world.

\paragraph{World-space rendering of fuel cans.}
Rendering uses the same logical grid as the rest of the pixel-art world. For each fuel can that has not been collected, I transform its world coordinates into camera-relative grid coordinates:
\[
  s_x = \frac{w_x}{s_{\text{px}}} - g_x^{\text{cam}}, \qquad
  s_y = \frac{w_y}{s_{\text{px}}} + g_y^{\text{cam}},
\]
with $(g_x^{\text{cam}}, g_y^{\text{cam}})$ the camera offset in grid cells. Around this origin I draw a small jerry-can sprite using a few hard-coded pixels:
\begin{itemize}
  \item a grey cap on top,
  \item a red rectangular body,
  \item a yellow “label” band across the centre,
  \item a semi-transparent shadow offset to one side.
\end{itemize}
Everything is filled using \texttt{plotGridPixel} calls on the grid, which results in a crisp, stylised jerry-can icon that is consistent with the overall pixel-art aesthetic.

\paragraph{Pickup detection and full refuel.}
For collision, I approximate the visual centre of each can as
\[
  P_i = (f_{x,i}, f_{y,i})
      = (w_{x,i} + 2s_{\text{px}},\, w_{y,i} + 3s_{\text{px}}),
\]
which roughly corresponds to the middle of the painted body rectangle. For each can and every wheel centre $W_j = (w_{x,j}, w_{y,j})$, I compute the squared Euclidean distance
\[
  d_{ij}^2 = \|P_i - W_j\|^2
  = (w_{x,j} - f_{x,i})^2 + (w_{y,j} - f_{y,i})^2,
\]
and keep the minimum over wheels
\[
  d_i^2 = \min_j d_{ij}^2.
\]
Using an effective pickup radius
\[
  R_{\text{fuel}} = \texttt{FUEL\_PICKUP\_RADIUS} + 20,
\]
the can is collected if
\[
  d_i^2 \le R_{\text{fuel}}^2.
\]
On a successful pickup I mark
\[
  \texttt{taken}_i \leftarrow 1, \qquad
  f(t^+) \leftarrow F_{\max},
\]
i.e., a single can currently refills the tank completely. I also play a short fuel-pickup sound and reset the spawn spacing logic accordingly. Although there is a configuration constant \texttt{FUEL\_PICKUP\_AMOUNT}, in the current build I chose the simpler “full refill” semantics for clarity of gameplay.

\paragraph{HUD fuel bar and low-fuel warning.}
On the HUD, I present the fuel level as a horizontal colour-gradient bar centred at the top of the screen. Let the bar width in grid cells be
\[
  W_{\text{bar}} = \mathrm{clip}\bigl(\lfloor \tfrac{1}{4}\,\text{gridW} \rfloor, 24, 48\bigr),
\]
and height $H_{\text{bar}} = 3$ cells. The current fuel fraction
\[
  \varphi(t) = \mathrm{clamp}\left(\frac{f(t)}{F_{\max}}, 0, 1\right)
\]
is mapped to a number of filled cells
\[
  N_{\text{filled}}(t) = \left\lfloor W_{\text{bar}}\,\varphi(t) \right\rfloor.
\]
For $x=0,\dots,W_{\text{bar}}-1$ I define a normalised horizontal parameter
\[
  \tau(x) = \frac{x}{\max(W_{\text{bar}}-1,1)},
\]
and assign each filled column a colour obtained by piecewise-linear interpolation between three key colours:
\[
  C_{\text{bar}}(x) =
  \begin{cases}
    \mathrm{lerp}(C_{\text{red}}, C_{\text{yellow}}, 2\tau(x)),
      & \tau(x) < 0.5,\\[4pt]
    \mathrm{lerp}(C_{\text{yellow}}, C_{\text{green}}, 2(\tau(x)-0.5)),
      & \tau(x) \ge 0.5,
  \end{cases}
\]
where $C_{\text{red}}$, $C_{\text{yellow}}$ and $C_{\text{green}}$ are fixed RGB values.
The background and border of the bar are drawn in darker tones, and I overlay small tick marks every few cells to give a coarse sense of consumption rate.

To emphasise imminent depletion, I introduce a low-fuel threshold
\[
  f_{\text{low}} = 0.25\,F_{\max}.
\]
Whenever $f(t) \le f_{\text{low}}$, I trigger a blinking warning symbol below the bar. Blinking is implemented via
\[
  \texttt{flashOn}(t) =
  \begin{cases}
    \text{true}, & \operatorname{frac}(t) < 0.5,\\
    \text{false}, & \text{otherwise},
  \end{cases}
\]
where $\operatorname{frac}(t)$ is the fractional part of the global elapsed time in seconds. If both the low-fuel and flashing conditions hold, I draw a red triangular warning icon followed by the pixel text “LOW”, centred under the bar, using the same grid-based rasteriser.

\bigskip
\noindent\textbf{Core code snippets.} The following excerpts show the complete fuel system implementation and the HUD fuel bar rendering as used in the project.

fuel.h
\begin{lstlisting}[style=cgstyle,language=C++]
#ifndef FUEL_H
#define FUEL_H

#include <QVector>
#include <QColor>
#include <QPainter>
#include <QHash>
#include <random>
#include "constants.h"
#include "wheel.h"

struct FuelCan {
    int wx;
    int wy;
    bool taken = false;
};

class FuelSystem {
public:
    QVector<FuelCan> cans;
    int lastPlacedFuelX = 0;

    int currentFuelSpacing(double difficulty, double elapsedSeconds) const;

    void maybePlaceFuelAtEdge(int lastTerrainX,
                              const QHash<int,int>& heightAtGX,
                              double difficulty,
                              double elapsedSeconds);

    void drawWorldFuel(QPainter& p, int cameraX, int cameraY) const;
    void handlePickups(const QList<Wheel*>& wheels, double& fuel);
};

#endif // FUEL_H
\end{lstlisting}

fuel.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "fuel.h"
#include <cmath>
#include <algorithm>

int FuelSystem::currentFuelSpacing(double difficulty,
                                   double elapsedSeconds) const {
    int base    = 700;
    int byDiff  = int(500 * (difficulty / 0.005));
    int byTime  = int(35 * elapsedSeconds);
    int spacing = base + byDiff + byTime;
    spacing     = int(std::round(spacing * Constants::FUEL_SPAWN_EASE));

    int minSpacing = int(std::round(10000 * Constants::FUEL_SPAWN_EASE));
    int maxSpacing = int(std::round(200000 * Constants::FUEL_SPAWN_EASE));
    if (spacing < minSpacing) spacing = minSpacing;
    if (spacing > maxSpacing) spacing = maxSpacing;

    return spacing;
}

void FuelSystem::maybePlaceFuelAtEdge(
    int lastTerrainX,
    const QHash<int,int>& heightAtGX,
    double difficulty,
    double elapsedSeconds
    ) {
    if (lastTerrainX - lastPlacedFuelX <
        currentFuelSpacing(difficulty, elapsedSeconds)) return;

    int gx = lastTerrainX / Constants::PIXEL_SIZE;
    auto it = heightAtGX.constFind(gx);
    if (it == heightAtGX.constEnd()) return;

    const int gyGround = it.value();

    FuelCan f;
    f.wx = lastTerrainX;
    f.wy = (gyGround - Constants::FUEL_FLOOR_OFFSET_CELLS)
            * Constants::PIXEL_SIZE;
    f.taken = false;
    cans.append(f);

    lastPlacedFuelX = lastTerrainX;
}

void FuelSystem::drawWorldFuel(QPainter& p,
                               int cameraX,
                               int cameraY) const {
    const int camGX = cameraX / Constants::PIXEL_SIZE;
    const int camGY = cameraY / Constants::PIXEL_SIZE;

    QColor body(230, 60, 60);
    QColor cap(230,230,230);
    QColor label(255,200,50);
    QColor shadow(0,0,0,90);

    auto plotGridPixel = [&](int gx, int gy, const QColor& c) {
        p.fillRect(gx * Constants::PIXEL_SIZE,
                   gy * Constants::PIXEL_SIZE,
                   Constants::PIXEL_SIZE,
                   Constants::PIXEL_SIZE, c);
    };

    for (const FuelCan& f : cans) {
        if (f.taken) continue;

        int sx = (f.wx / Constants::PIXEL_SIZE) - camGX;
        int sy = (f.wy / Constants::PIXEL_SIZE) + camGY;

        auto px = [&](int gx, int gy, const QColor& c){
            plotGridPixel(sx+gx, sy+gy, c);
        };

        // shadow
        px(2,1,shadow);
        px(5,2,shadow);

        // cap
        px(1,0,cap);
        px(2,0,cap);

        // body
        for (int y=1; y<=5; ++y) {
            for (int x=0; x<=4; ++x) {
                px(x,y,body);
            }
        }

        // label stripe
        for (int x=1; x<=3; ++x) {
            px(x,3,label);
        }
    }
}

void FuelSystem::handlePickups(const QList<Wheel*>& wheels,
                               double& fuel) {
    if (wheels.isEmpty()) return;

    for (FuelCan& f : cans) {
        if (f.taken) continue;
        const double fx = f.wx + 2 * Constants::PIXEL_SIZE;
        const double fy = f.wy + 3 * Constants::PIXEL_SIZE;
        double minD2 = 1e18;
        for (const Wheel* w : wheels) {
            const double dx = w->x - fx;
            const double dy = w->y - fy;
            const double d2 = dx*dx + dy*dy;
            if (d2 < minD2) minD2 = d2;
        }
        const double R = Constants::FUEL_PICKUP_RADIUS + 20;
        if (minD2 <= R*R) {
            f.taken = true;
            fuel = Constants::FUEL_MAX;
        }
    }
}
\end{lstlisting}

\noindent mainwindow.cpp (HUD fuel excerpt)
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::drawHUDFuel(QPainter& p) {
    int gy = Constants::HUD_TOP_MARGIN;
    int wcells = std::min(std::max(gridW()/4, 24), 48);
    int gx = (gridW() - wcells)/2;
    int barH = 3;

    double frac = std::clamp(m_fuel / Constants::FUEL_MAX, 0.0, 1.0);
    int filled = int(std::floor(wcells * frac));

    auto lerp = [](const QColor& c1, const QColor& c2, double t)->QColor {
        int r = int((1-t)*c1.red()   + t*c2.red());
        int g = int((1-t)*c1.green() + t*c2.green());
        int b = int((1-t)*c1.blue()  + t*c2.blue());
        return QColor(r,g,b);
    };

    QColor startC(230,50,40), midC(250,230,80), endC(40,230,55);

    // background
    for (int x=0; x<wcells; ++x)
        for (int y=0; y<barH; ++y)
            plotGridPixel(p, gx+x, gy+y, QColor(20,14,24));

    // filled gradient
    for (int x=0; x<filled; ++x) {
        double t = double(x)/std::max(wcells-1,1);
        QColor c = (t<0.5)
            ? lerp(startC, midC, t*2)
            : lerp(midC, endC, (t-0.5)*2);
        for (int y=0; y<barH; ++y)
            plotGridPixel(p, gx+x, gy+y, c);
    }

    // vertical borders
    for (int y=0; y<barH; ++y) {
        plotGridPixel(p,gx-1,gy+y,QColor(35,35,48));
        plotGridPixel(p,gx+wcells,gy+y,QColor(35,35,48));
    }

    // horizontal borders
    for (int x=-1; x<=wcells; ++x) {
        plotGridPixel(p,gx+x,gy-1,QColor(35,35,48));
        plotGridPixel(p,gx+x,gy+barH,QColor(35,35,48));
    }

    // tick marks
    int tickEvery = std::max(6, wcells/6);
    for (int x=tickEvery; x<wcells; x+=tickEvery)
        plotGridPixel(p, gx+x, gy+barH, QColor(80,80,70));

    const double lowFuelThreshold = Constants::FUEL_MAX * 0.25;
    const bool isLow = (m_fuel <= lowFuelThreshold);
    const bool isFlashingOn =
        (std::fmod(m_elapsedSeconds, 1.0) < 0.5);

    if (isLow && isFlashingOn) {
        const QColor red(230, 50, 40);
        const QColor white(255, 255, 255);
        const int warningGap = 3;
        const int warningTopGY = gy + barH + 1 + warningGap;

        const int totalWidth = 5 + 2 + 3 + 1 + 3 + 1 + 5;
        int currentGX = (gridW() - totalWidth) / 2;

        const int triTopGY = warningTopGY;

        // triangle with exclamation
        plotGridPixel(p, currentGX + 2, triTopGY,     red);
        plotGridPixel(p, currentGX + 1, triTopGY + 1, red);
        plotGridPixel(p, currentGX + 2, triTopGY + 1, white);
        plotGridPixel(p, currentGX + 3, triTopGY + 1, red);
        plotGridPixel(p, currentGX,     triTopGY + 2, red);
        plotGridPixel(p, currentGX + 1, triTopGY + 2, red);
        plotGridPixel(p, currentGX + 2, triTopGY + 2, white);
        plotGridPixel(p, currentGX + 3, triTopGY + 2, red);
        plotGridPixel(p, currentGX + 4, triTopGY + 2, red);
        plotGridPixel(p, currentGX + 2, triTopGY + 4, white);

        currentGX += 5 + 2;

        const int textTopGY = warningTopGY;

        // 'L'
        for(int y=0; y<5; ++y)
            plotGridPixel(p, currentGX, textTopGY+y, red);
        plotGridPixel(p, currentGX+1, textTopGY+4, red);
        plotGridPixel(p, currentGX+2, textTopGY+4, red);
        currentGX += 3 + 1;

        // 'O'
        for(int y=0; y<5; ++y) {
            plotGridPixel(p, currentGX,   textTopGY+y, red);
            plotGridPixel(p, currentGX+2, textTopGY+y, red);
        }
        plotGridPixel(p, currentGX+1, textTopGY,   red);
        plotGridPixel(p, currentGX+1, textTopGY+4, red);
        currentGX += 3 + 1;

        // 'W'
        for(int y=0; y<5; ++y) {
            plotGridPixel(p, currentGX,   textTopGY+y, red);
            plotGridPixel(p, currentGX+4, textTopGY+y, red);
        }
        plotGridPixel(p, currentGX+1, textTopGY+3, red);
        plotGridPixel(p, currentGX+2, textTopGY+2, red);
        plotGridPixel(p, currentGX+3, textTopGY+3, red);
    }
}
\end{lstlisting}
\begin{figure}[h]
  \centering
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/fuel_spawning.png}
    \caption{Procedural fuel can spawning at the terrain edge}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/fuel_collection_&_HUD_update.png}
    \caption{Fuel pickup and HUD bar refill}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/Low_Fuel_Indicator.png}
    \caption{Blinking low fuel warning indicator on the HUD}
  \end{subfigure}
  \caption{Fuel system: adaptive fuel can placement, world-space collection, and HUD feedback including low fuel indication.}
\end{figure}
\clearpage
\subsubsection*{Fuel System Results}
In practice, the adaptive spacing function produced fuel cans that became noticeably rarer as difficulty and run time increased, forcing me to drive more efficiently while still avoiding unwinnable “fuel starvation” scenarios. The continuous consumption model, coupled with nitro’s triple burn, gave a clear risk–reward trade-off, and every successful can pickup immediately refilled the HUD bar and cancelled the low-fuel warning, confirming the correctness of the world-space collision logic and the HUD fuel indicator.
\subsubsection*{Feature: Nitro Boost System}
\textbf{Relevant classes and functions:} \texttt{NitroSystem}, \texttt{NitroSystem::update()}, \texttt{NitroSystem::applyThrust()}, \texttt{NitroSystem::drawHUD()}, \texttt{NitroSystem::drawFlame()}, \texttt{MainWindow::gameLoop()}, \texttt{Wheel::simulate()}.

In my implementation, the nitro boost is modelled as a short-lived state machine that directly injects additional thrust into the wheels while a dedicated key is held, with activation gated by the current fuel level. At any physical time $t$ (measured in seconds of game time), the nitro subsystem is described by the state
\[
  S_{\text{nitro}}(t) = \bigl(\texttt{active}(t),\, t_{\text{end}},\, t_{\text{cool}},\, y_{\text{ceil}}\bigr),
\]
where $\texttt{active}(t) \in \{0,1\}$ encodes whether nitro is currently firing, $t_{\text{end}}$ is the scheduled shutoff time for the current burst, $t_{\text{cool}}$ is the earliest time at which a new burst may be triggered (cooldown), and $y_{\text{ceil}}$ is a vertical altitude ceiling for the wheels expressed in world pixels. This state lives inside a dedicated \texttt{NitroSystem} object and is updated once per frame from \texttt{MainWindow::gameLoop()} using the current input, fuel value and local terrain geometry.

The global fuel level is maintained as a scalar $f(t)$ in \texttt{m\_fuel}, with invariant
\[
  0 \;\le\; f(t) \;\le\; F_{\max} = \texttt{Constants::FUEL\_MAX}.
\]
Nitro can only be activated while $f(t) > 0$, and all bursts are forcibly terminated once fuel reaches zero. Thus nitro behaves as a higher-intensity consumer of the same fuel resource rather than a separate energy pool.

\paragraph{Activation and cooldown logic.}
Let $k(t)\in\{0,1\}$ denote the nitro key state passed into \texttt{NitroSystem::update()} as \texttt{nitroKey}, and let $f(t)$ be the current fuel level. Conceptually, I implement the following piecewise rule for the \texttt{active} flag:
\[
  \texttt{active}(t^+) =
  \begin{cases}
    1, & \text{if } \texttt{active}(t^-) = 0,\; k(t)=1,\; f(t) > 0,\; t \ge t_{\text{cool}},\\[3pt]
    0, & \text{if } \texttt{active}(t^-) = 1 \text{ and } \bigl(k(t)=0 \;\lor\; f(t)\le 0 \;\lor\; t \ge t_{\text{end}}\bigr),\\[3pt]
    \texttt{active}(t^-), & \text{otherwise.}
  \end{cases}
\]
When a new nitro burst is started at time $t$, I schedule its end time and leave cooldown unset for the moment:
\[
  t_{\text{end}} = t + T_{\text{burst}}, \qquad
  T_{\text{burst}} = \texttt{Constants::NITRO\_DURATION\_SECOND}.
\]
Once the burst ends (because the key is released, fuel hits zero, or the timer expires), nitro is switched off and a cooldown window is scheduled:
\[
  t_{\text{cool}} = t + T_{\text{cool}}, \qquad
  T_{\text{cool}} \approx 2.0~\text{s}.
\]
During $[t, t_{\text{cool}})$, even if the player presses the nitro key and still has fuel, the \texttt{update()} function will refuse reactivation.

\paragraph{Altitude ceiling from terrain height.}
At the start of a burst, I also compute a maximum “hop” height relative to the ground under the car’s average $x$ coordinate. Let $x_{\text{avg}}$ be the average of the two wheel $x$ positions and $s_{\text{px}} = \texttt{PIXEL\_SIZE}$ be the world-to-grid scale. I convert to a terrain grid column
\[
  g_x = \left\lfloor \frac{x_{\text{avg}}}{s_{\text{px}}} \right\rfloor,
\]
and query the corresponding ground row via a function object \texttt{groundGyNearestGX} supplied by the main window:
\[
  g_y^{\text{ground}} = \texttt{groundGyNearestGX}(g_x).
\]
With a maximum allowed vertical offset $H_{\max} = \texttt{Constants::NITRO\_MAX\_ALT\_CELLS}$ (in grid cells), I define the ceiling grid row
\[
  g_y^{\text{ceil}} = g_y^{\text{ground}} - H_{\max}, \qquad
  y_{\text{ceil}} = g_y^{\text{ceil}} \, s_{\text{px}}.
\]
In screen coordinates (where smaller $y$ means visually “higher”), the constraint $y \ge y_{\text{ceil}}$ means that neither wheel is allowed to move above this ceiling; any such motion is immediately clamped in \texttt{applyThrust()}, preventing nitro from flinging the car indefinitely upwards.

\paragraph{Boost direction from terrain tangent.}
The direction of the nitro thrust is derived from the local terrain slope. From \texttt{MainWindow::gameLoop()} I pass a function \texttt{terrainTangentAngleAtX(wx)} which returns the tangent angle of the procedural terrain at a world $x$ position $w_x$. At activation time, I sample it at the average $x$:
\[
  \theta_{\text{terr}} = \texttt{terrainTangentAngleAtX}(x_{\text{avg}}),
\]
and then add a fixed launch angle offset
\[
  \theta_{\text{boost}} = \theta_{\text{terr}} + \texttt{Constants::NITRO\_LAUNCH\_ANGLE\_RADIANS}.
\]
The unit direction vector used to accelerate the wheels is
\[
  \mathbf{u} = (u_x,u_y) = \bigl(\cos\theta_{\text{boost}},\; -\sin\theta_{\text{boost}}\bigr),
\]
where the minus sign on the sine term compensates for the inverted $y$ axis in screen coordinates (larger $y$ is visually “downwards”).

\paragraph{Thrust application and altitude clamping on wheels.}
Actual velocity changes are applied to the physical wheels in \texttt{NitroSystem::applyThrust()}. Let the back and front wheels have positions $(x_b,y_b)$ and $(x_f,y_f)$ and velocities $(v_{x,b},v_{y,b})$ and $(v_{x,f},v_{y,f})$. First, I compute the chassis direction based on the two wheels:
\[
  \mathbf{d} = (d_x,d_y) = (x_f-x_b,\; y_b-y_f), \qquad
  \mathbf{u}_{\text{chassis}} = \frac{\mathbf{d}}{\|\mathbf{d}\|},
\]
again using $y_b-y_f$ to compensate for screen coordinates. In this implementation, the instantaneous boost is applied along $\mathbf{u}_{\text{chassis}}$ with a fixed magnitude $K_{\text{nitro}} = \texttt{Constants::NITRO\_THRUST}$:
\[
  \mathbf{v}_w(t^+) = \mathbf{v}_w(t^-) + K_{\text{nitro}}\,\mathbf{u}_{\text{chassis}}
\]
for each wheel $w \in \{\text{back, front}\}$. After this update, I enforce the altitude ceiling by clamping
\[
  y_w(t^+) \gets \max\bigl(y_w(t^+),\, y_{\text{ceil}}\bigr),
\]
and if a wheel has been pushed above the ceiling ($y_w < y_{\text{ceil}}$) I reset its vertical velocity component to zero to avoid numerical tunnelling through the ceiling.

\paragraph{Exhaust flame rendering behind the rear wheel.}
The visual nitro flame is rendered in \texttt{NitroSystem::drawFlame()} as a small pixel-art plume attached to the rear wheel. I first project the back wheel centre and radius into screen grid coordinates using the existing helper:
\[
  (c_x, c_y, r_{\text{px}}) = \texttt{back->get}(\ldots),
  \qquad g_{cx} = \frac{c_x}{s_{\text{px}}},\quad g_{cy} = \frac{c_y}{s_{\text{px}}},
\]
and derive a nozzle position by stepping a few cells backwards along the chassis direction. With $\mathbf{u}_{\text{chassis}}$ as above and an offset in grid cells
\[
  N_{\text{off}} = \left\lfloor \frac{r_{\text{px}}}{s_{\text{px}}} \right\rfloor + 2,
\]
the nozzle grid coordinates are
\[
  g_x^{\text{nozzle}} = g_{cx} - \big\lfloor u_x\,N_{\text{off}} \big\rfloor,\qquad
  g_y^{\text{nozzle}} = g_{cy} - \big\lfloor u_y\,N_{\text{off}} \big\rfloor.
\]
Around this nozzle point I plot a small cross-shaped cluster of pixels using three colours (outer orange, mid yellow, inner white) via a lambda
\[
  \texttt{plot}(g_x,g_y) \to \texttt{fillRect}(g_x s_{\text{px}}, g_y s_{\text{px}}, s_{\text{px}}, s_{\text{px}}),
\]
which yields a stylised exhaust flame that rotates with the car as it climbs and descends hills.

\paragraph{HUD nitro countdown and fuel gating.}
The nitro HUD is drawn by \texttt{NitroSystem::drawHUD()}, which renders a small rocket icon plus a numeric countdown in the same grid-based style as the rest of the UI. The icon is anchored at a base grid coordinate
\[
  g_x^{\text{base}} = \texttt{HUD\_LEFT\_MARGIN}, \qquad
  g_y^{\text{base}} = \texttt{HUD\_TOP\_MARGIN} + 2\,\texttt{COIN\_RADIUS\_CELLS} + 4,
\]
and implemented as a fixed $5\times 5$ pattern of coloured cells (hull, window, tip, flame and shadow).

The text next to the rocket shows a remaining time value $\tau(t)$ computed from the nitro state:
\[
  \tau(t) =
  \begin{cases}
    \max(0,\, t_{\text{end}} - t), & \text{if } \texttt{active}(t)=1,\\[3pt]
    \max(0,\, t_{\text{cool}} - t), & \text{if } \texttt{active}(t)=0 \text{ and } t < t_{\text{cool}},\\[3pt]
    0, & \text{otherwise.}
  \end{cases}
\]
I convert this to an integer via $\lceil \tau(t) \rceil$ and draw it as a bold monospace number to the right of the rocket sprite. Since activation is gated by $f(t)>0$, the combination of the on-screen countdown and the fuel check makes nitro availability transparent to the player.

\bigskip
\noindent\textbf{Core code snippets.} The following excerpts show the core of the nitro system and its integration with the main update and rendering loop.

nitro.h
\begin{lstlisting}[style=cgstyle,language=C++]
#ifndef NITRO_H
#define NITRO_H

#include <QPainter>
#include <QList>
#include <QHash>
#include <functional>
#include <cmath>

#include "constants.h"
#include "wheel.h"

class NitroSystem {
public:
    bool   active        = false;
    double endTime       = 0.0;
    double cooldownUntil = 0.0;
    double dirX          = 0.0;
    double dirY          = -1.0;
    int    ceilY         = -1000000000;

    void reset() {
        active        = false;
        endTime       = 0.0;
        cooldownUntil = 0.0;
        dirX          = 0.0;
        dirY          = -1.0;
        ceilY         = -1000000000;
    }

    void update(bool nitroKey,
                double fuel,
                double elapsedSeconds,
                double avgX,
                const std::function<int(int)>& groundGyNearestGX,
                const std::function<double(double)>& terrainTangentAngleAtX);

    void applyThrust(QList<Wheel*>& wheels) const;

    void drawHUD(QPainter& p,
                 double elapsedSeconds,
                 int levelIndex) const;

    void drawFlame(QPainter& p,
                   const QList<Wheel*>& wheels,
                   int cameraX,
                   int cameraY,
                   int viewW,
                   int viewH) const;
};

#endif // NITRO_H
\end{lstlisting}

nitro.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "nitro.h"
#include <QtMath>
#include <algorithm>

void NitroSystem::update(bool nitroKey,
                         double fuel,
                         double elapsedSeconds,
                         double avgX,
                         const std::function<int(int)>& groundGyNearestGX,
                         const std::function<double(double)>& terrainTangentAngleAtX)
{
    const bool wantNitro = nitroKey;

    if (!active) {
        if (wantNitro && fuel > 0.0 && elapsedSeconds >= cooldownUntil) {
            active  = true;
            endTime = elapsedSeconds + Constants::NITRO_DURATION_SECOND;

            const double launchAngle =
                terrainTangentAngleAtX(avgX)
                + Constants::NITRO_LAUNCH_ANGLE_RADIANS;
            dirX = std::cos(launchAngle);
            dirY = -std::sin(launchAngle);

            const int gx = int(std::round(avgX / Constants::PIXEL_SIZE));

            int gyGround = 0;
            if (groundGyNearestGX) {
                gyGround = groundGyNearestGX(gx);
            }

            ceilY = (gyGround - Constants::NITRO_MAX_ALT_CELLS)
                    * Constants::PIXEL_SIZE;
        }
    } else {
        if (!wantNitro || fuel <= 0.0 || elapsedSeconds >= endTime) {
            active        = false;
            cooldownUntil = elapsedSeconds + 2.0;
        }
    }
}

void NitroSystem::applyThrust(QList<Wheel*>& wheels) const
{
    if (!active) return;
    if (wheels.size() < 2) return;

    Wheel* back  = wheels[0];
    Wheel* front = wheels[1];

    const double dx  = front->x - back->x;
    const double dy  = back->y  - front->y;
    const double len = std::sqrt(dx*dx + dy*dy);
    if (len < 1e-6) return;

    const double ux = dx / len;
    const double uy = dy / len;

    const double thrust = Constants::NITRO_THRUST;

    for (Wheel* w : wheels) {
        w->m_vx += thrust * ux;
        w->m_vy += thrust * uy;

        if (w->y < ceilY) {
            w->y = ceilY;
            if (w->m_vy > 0.0) {
                w->m_vy = 0.0;
            }
        }
    }
}

void NitroSystem::drawHUD(QPainter& p,
                          double elapsedSeconds,
                          int levelIndex) const
{
    const int baseGX = Constants::HUD_LEFT_MARGIN;
    const int baseGY = Constants::HUD_TOP_MARGIN
                       + Constants::COIN_RADIUS_CELLS * 2 + 4;

    QColor hull   (180, 180, 190);
    QColor tip    (230, 230, 240);
    QColor windowC(120, 170, 220);
    QColor flame1 (250, 160,  60);
    QColor flame2 (255, 210,  90);
    QColor shadow ( 10,  10,  20);

    auto plot = [&](int gxCell, int gyCell, const QColor& c) {
        p.fillRect((baseGX + gxCell) * Constants::PIXEL_SIZE,
                   (baseGY + gyCell) * Constants::PIXEL_SIZE,
                   Constants::PIXEL_SIZE,
                   Constants::PIXEL_SIZE,
                   c);
    };

    // Simple 5x5 rocket sprite
    plot(1,1,hull);    plot(2,1,hull);    plot(3,1,hull);    plot(4,1,hull);
    plot(1,2,hull);    plot(2,2,windowC); plot(3,2,hull);    plot(4,2,hull);
    plot(5,2,tip);
    plot(1,3,hull);    plot(2,3,hull);    plot(3,3,hull);    plot(4,3,hull);
    plot(0,2,flame1);  plot(0,3,flame2);
    plot(2,4,shadow);

    QFont f;
    f.setFamily("Monospace");
    f.setBold(true);
    f.setPointSize(12);
    p.setFont(f);
    p.setPen(Constants::TEXT_COLOR[levelIndex]);

    double tleft = 0.0;
    if (active) {
        tleft = std::max(0.0, endTime - elapsedSeconds);
    } else if (elapsedSeconds < cooldownUntil) {
        tleft = std::max(0.0, cooldownUntil - elapsedSeconds);
    }

    const int pxText = (baseGX + 8) * Constants::PIXEL_SIZE;
    const int pyText = (baseGY + 5) * Constants::PIXEL_SIZE;
    p.drawText(pxText, pyText,
               QString::number(int(std::ceil(tleft))));
}

void NitroSystem::drawFlame(QPainter& p,
                            const QList<Wheel*>& wheels,
                            int cameraX,
                            int cameraY,
                            int viewW,
                            int viewH) const
{
    if (!active) return;
    if (wheels.size() < 2) return;

    const Wheel* back  = wheels[0];
    const Wheel* front = wheels[1];

    auto screenInfo = back->get(cameraX, cameraY,
                                viewW, viewH,
                                -cameraX, cameraY);
    if (!screenInfo.has_value()) return;

    const int cx = (*screenInfo)[0];
    const int cy = (*screenInfo)[1];
    const int r  = (*screenInfo)[2];
    if (r <= 0) return;

    const int gcx = cx / Constants::PIXEL_SIZE;
    const int gcy = cy / Constants::PIXEL_SIZE;

    const double dx  = front->x - back->x;
    const double dy  = back->y  - front->y;
    const double len = std::sqrt(dx*dx + dy*dy);
    if (len < 1e-6) return;

    const double ux = dx / len;
    const double uy = dy / len;

    const int offsetCells = r / Constants::PIXEL_SIZE + 2;
    const int nozzleGX =
        gcx - int(std::round(ux * offsetCells));
    const int nozzleGY =
        gcy - int(std::round(uy * offsetCells));

    QColor cOuter(255,160,60);
    QColor cMid  (255,210,90);
    QColor cCore (255,255,255);

    auto plot = [&](int gx, int gy, const QColor& c) {
        p.fillRect(gx * Constants::PIXEL_SIZE,
                   gy * Constants::PIXEL_SIZE,
                   Constants::PIXEL_SIZE,
                   Constants::PIXEL_SIZE,
                   c);
    };

    plot(nozzleGX - 1, nozzleGY,     cOuter);
    plot(nozzleGX - 2, nozzleGY,     cOuter);
    plot(nozzleGX - 2, nozzleGY + 1, cMid);
    plot(nozzleGX - 3, nozzleGY,     cCore);
}
\end{lstlisting}

wheel.h (excerpt: nitro-aware simulation signature)
\begin{lstlisting}[style=cgstyle,language=C++]
#ifndef WHEEL_H
#define WHEEL_H

#include <QPainter>
#include <QVector>
#include <optional>
#include <array>
#include "constants.h"

class Wheel {
public:
    double x = 0.0;
    double y = 0.0;
    double m_vx = 0.0;
    double m_vy = 0.0;
    double radius = 0.0;
    bool   onGround = false;

    Wheel(double cx, double cy, double r);

    void simulate(int level_index,
                  const QVector<QLine>& groundLines,
                  bool accelerating,
                  bool braking,
                  bool nitro);

    void draw(QPainter& p,
              int cameraX,
              int cameraY,
              int gridW,
              int gridH) const;

    std::optional<std::array<int,3>> get(int cameraX,
                                         int cameraY,
                                         int viewW,
                                         int viewH,
                                         int offsetX,
                                         int offsetY) const;
};

#endif // WHEEL_H
\end{lstlisting}

mainwindow.cpp (nitro integration excerpts)
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::gameLoop() {
    ...
    // Average wheel X used as sample point for nitro terrain queries
    double avgX = 0.0;
    if (m_wheels.size() >= 2) {
        avgX = 0.5 * (m_wheels[0]->x + m_wheels[1]->x);
    }

    m_nitroSys.update(
        m_nitroKey,
        m_fuel,
        m_elapsedSeconds,
        avgX,
        [this](int gx) {
            return this->groundGyNearestGX(gx);
        },
        [this](double wx) {
            return this->terrainTangentAngleAtX(wx);
        }
    );

    for (Wheel* w : m_wheels) {
        w->simulate(level_index,
                    m_lines,
                    accelDrive,
                    brakeDrive,
                    m_nitroKey);
    }

    // Inject nitro thrust on top of normal wheel dynamics
    m_nitroSys.applyThrust(m_wheels);
    ...
}

void MainWindow::paintEvent(QPaintEvent* /*ev*/) {
    QPainter p(this);
    ...
    // World-space rendering (terrain, car, wheels, etc.)
    ...
    // Nitro exhaust and HUD overlay
    m_nitroSys.drawFlame(p,
                         m_wheels,
                         m_cameraX,
                         m_cameraY,
                         width(),
                         height());

    m_nitroSys.drawHUD(p,
                       m_elapsedSeconds,
                       level_index);
}
\end{lstlisting}
\begin{figure}[h]
  \centering
  \begin{subfigure}{0.6\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/nitro_flame_&_countdown.png}
    \caption{Nitro exhaust flame and HUD countdown indicator}
  \end{subfigure}
  \caption{Nitro boost system: world-space flame rendering attached to the rear wheel and rocket-style HUD countdown for burst and cooldown timing.}
\end{figure}

\subsubsection*{Nitro System Results}
In practice, the nitro subsystem produced short, controlled bursts of acceleration that let the car clear steep hills and gaps without destabilising the lightweight physics. The altitude ceiling and the fuel-gated activation meant players could not “fly” indefinitely; instead, they had to choose their boost windows carefully based on remaining fuel. The combination of the animated exhaust plume and the rocket-style countdown HUD made nitro availability and remaining burst time immediately readable during gameplay, so the system felt responsive and intentional rather than arbitrary.

\subsubsection*{Feature: Camera Stabilisation and Smooth Follow}
\textbf{Relevant classes and functions:} \texttt{MainWindow}, \texttt{MainWindow::gameLoop()}, \texttt{MainWindow::updateCamera()}, \texttt{CarBody}, \texttt{Wheel}.

In my implementation, the world camera is modelled as a damped second–order system that tracks a moving target attached to the car body. Instead of snapping the viewport directly to the car position, I maintain a continuous camera state
\[
  C_{\text{cam}}(t) = \bigl(x_{\text{cam}}(t),\, y_{\text{cam}}(t),\, v_x(t),\, v_y(t)\bigr),
\]
where $(x_{\text{cam}},y_{\text{cam}})$ is the camera centre in world pixels and $(v_x,v_y)$ is the camera velocity. This state is updated once per frame to follow a target point $(x_{\text{tgt}},y_{\text{tgt}})$ derived from the car position, with overshoot and oscillations controlled by a natural frequency $\omega_n$ and damping ratio $\zeta$.

\paragraph{Target point in world and screen space.}
Each frame, I first compute an average wheel position
\[
  x_{\text{avg}} = \frac{1}{N}\sum_{i=1}^{N} x_i,\qquad
  y_{\text{avg}} = \frac{1}{N}\sum_{i=1}^{N} y_i,
\]
over all wheels (with $N = \texttt{m\_wheels.size()}$). For the actual camera anchor, I prefer the car body centre when available:
\[
  x_{\text{body}} = 
  \begin{cases}
    \texttt{m\_bodies.first()->getX()}, & \text{if body exists},\\
    x_{\text{avg}}, & \text{otherwise,}
  \end{cases}
  \qquad
  y_{\text{body}} = 
  \begin{cases}
    \texttt{m\_bodies.first()->getY()}, & \text{if body exists},\\
    y_{\text{avg}}, & \text{otherwise.}
  \end{cases}
\]
To give the player a better look ahead, I offset the camera target a fixed horizontal amount behind the car and vertically centre the car on the screen. With window height $H = \texttt{height()}$ I define
\[
  x_{\text{tgt}} = x_{\text{body}} - \Delta_x, \qquad
  y_{\text{tgt}} = -y_{\text{body}} + \frac{H}{2},
\]
where $\Delta_x = 200$ pixels in my current tuning, and the minus sign on $y_{\text{body}}$ compensates for the inverted screen $y$ axis (larger $y$ is “downwards” on screen).

\paragraph{Second-order smoothing model.}
To avoid jitter when the car bounces over rough terrain, I do not set $(x_{\text{cam}},y_{\text{cam}})$ directly to $(x_{\text{tgt}},y_{\text{tgt}})$. Instead, I approximate a critically damped mass–spring system per axis. For one dimension (say $x$), the continuous-time model is
\[
  \ddot{x}_{\text{cam}}(t) + 2\zeta\omega_n\,\dot{x}_{\text{cam}}(t)
  + \omega_n^2\bigl(x_{\text{cam}}(t) - x_{\text{tgt}}(t)\bigr) = 0,
\]
with natural frequency $\omega_n = \texttt{m\_camWN}$ and damping ratio $\zeta = \texttt{m\_camZeta}$. In my implementation I use
\[
  \omega_n = 20.0,\qquad \zeta = 0.98,
\]
which yields a fast, slightly over-damped response: the camera catches up quickly but without visible oscillations.

Given the current state $(x_{\text{cam}},v_x)$ and target $x_{\text{tgt}}$, I compute the instantaneous acceleration as
\[
  a_x = \omega_n^2\,(x_{\text{tgt}} - x_{\text{cam}}) - 2\zeta\omega_n\,v_x,
\]
and analogously for $y$:
\[
  a_y = \omega_n^2\,(y_{\text{tgt}} - y_{\text{cam}}) - 2\zeta\omega_n\,v_y.
\]

\paragraph{Time-stepping and numerical stability.}
The game loop passes a raw frame time step $\Delta t_{\text{raw}}$ into \texttt{updateCamera()}, which I clamp to a safe range to avoid numerical instability:
\[
  \Delta t = \mathrm{clamp}\bigl(\Delta t_{\text{raw}},\,\Delta t_{\min},\,\Delta t_{\max}\bigr),
  \qquad \Delta t_{\min}=10^{-4},\quad \Delta t_{\max}=0.05.
\]
I then integrate the second-order system using semi-implicit Euler:
\begin{align*}
  v_x(t+\Delta t) &= v_x(t) + a_x(t)\,\Delta t,\\
  x_{\text{cam}}(t+\Delta t) &= x_{\text{cam}}(t) + v_x(t+\Delta t)\,\Delta t,
\end{align*}
and similarly for $y$. This scheme is inexpensive and, combined with the fixed $(\omega_n,\zeta)$ and $\Delta t$ clamp, keeps the camera motion smooth even under fluctuating frame rates.

Once the continuous camera centre $(x_{\text{cam}},y_{\text{cam}})$ has been updated, I quantise it to integer pixels for use as the draw offset:
\[
  \texttt{m\_cameraX} = \big\lfloor x_{\text{cam}} + 0.5 \big\rfloor, \qquad
  \texttt{m\_cameraY} = \big\lfloor y_{\text{cam}} + 0.5 \big\rfloor.
\]
All world elements (terrain, car body, wheels, coins, fuel, etc.) are then rendered relative to $(\texttt{m\_cameraX},\texttt{m\_cameraY})$, so the entire scene inherits this stabilised camera motion.

\bigskip
\noindent\textbf{Core code snippets.} The following excerpts show the camera state, its integration in the main loop, and the stabilisation update step.

mainwindow.h (camera state)
\begin{lstlisting}[style=cgstyle,language=C++]
class MainWindow : public QWidget
{
    Q_OBJECT
    ...
    // Smoothed camera in world space
    double m_camX   = 0.0;
    double m_camY   = 0.0;
    double m_camVX  = 0.0;
    double m_camVY  = 0.0;
    double m_camWN  = 20.0;   // Natural frequency
    double m_camZeta= 0.98;   // Damping ratio

    // Integer camera used for rendering offsets
    int m_cameraX   = 0;
    int m_cameraY   = 0;
    ...
    void updateCamera(double targetX, double targetY, double rawDt);
    ...
};
\end{lstlisting}

mainwindow.cpp (camera target in \texttt{gameLoop()} and quantisation)
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::gameLoop() {
    ...
    double avgX = 0.0, avgY = 0.0;
    if (!m_wheels.isEmpty()) {
        for (Wheel* w : m_wheels) {
            avgX += w->x;
            avgY += w->y;
        }
        avgX /= m_wheels.size();
        avgY /= m_wheels.size();
    }

    ...
    double bodyX = (!m_bodies.isEmpty()) ? m_bodies.first()->getX() : avgX;
    double bodyY = (!m_bodies.isEmpty()) ? m_bodies.first()->getY() : avgY;

    const double targetX = bodyX - 200.0;
    const double targetY = -bodyY + height() / 2.0;

    updateCamera(targetX, targetY, dt);

    m_cameraX = int(std::lround(m_camX));
    m_cameraY = int(std::lround(m_camY));
    ...
}
\end{lstlisting}

mainwindow.cpp (camera stabilisation update)
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::updateCamera(double targetX, double targetY, double rawDt) {
    const double dt = std::clamp(rawDt, 1e-4, 0.05);

    const double wn2       = m_camWN * m_camWN;
    const double twoZetaWN = 2.0 * m_camZeta * m_camWN;

    const double ax = wn2 * (targetX - m_camX) - twoZetaWN * m_camVX;
    const double ay = wn2 * (targetY - m_camY) - twoZetaWN * m_camVY;

    m_camVX += ax * dt;
    m_camVY += ay * dt;

    m_camX  += m_camVX * dt;
    m_camY  += m_camVY * dt;
}
\end{lstlisting}

\subsubsection*{Camera Stabilisation Results}
In practice, this damped second–order camera produced a smooth, “weighty” follow behaviour that filters out high-frequency jitter from the wheels while still keeping the car centred and readable. The chosen $(\omega_n,\zeta)$ parameters let the view catch up quickly after jumps and crashes without overshooting or oscillating, and the horizontal look-ahead offset gave players extra reaction time when approaching steep slopes and gaps. Overall, the stabilised camera significantly improved comfort and perceived polish compared to a naïve, instant-follow implementation.

\subsubsection*{Feature: Aerial Flip Detection and Reward System}
\textbf{Relevant classes and functions:} \texttt{FlipTracker}, \texttt{MainWindow::gameLoop()}, \texttt{MainWindow::paintEvent()}.

In my implementation, I developed a dedicated system to track the car's rotational history to detect and reward 360-degree aerial flips. Unlike simple state checks (e.g., checking if the car is upside down), detecting a flip requires integrating the angular velocity over time to distinguish between a full rotation and a simple oscillation. This logic is encapsulated in the \texttt{FlipTracker} class.

\paragraph{Angular Integration and Normalization.}
The core challenge in tracking rotation is the discontinuity of angles at $\pm \pi$. The physics engine provides the car's current angle $\theta_t \in (-\pi, \pi]$. Simply subtracting the current angle from the previous angle $\theta_{t-1}$ can yield incorrect large deltas when the angle crosses the cut line (e.g., moving from $\pi - \epsilon$ to $-\pi + \epsilon$).

To solve this, I calculate the raw difference $\delta_{\text{raw}} = \theta_t - \theta_{t-1}$ and normalize it into the principal interval $(-\pi, \pi]$:
\[
    \Delta \theta = 
    \begin{cases} 
      \delta_{\text{raw}} - 2\pi, & \text{if } \delta_{\text{raw}} > \pi \\
      \delta_{\text{raw}} + 2\pi, & \text{if } \delta_{\text{raw}} \le -\pi \\
      \delta_{\text{raw}}, & \text{otherwise}
    \end{cases}
\]
This normalized $\Delta \theta$ represents the true physical rotation magnitude and direction that occurred during the frame $\Delta t$. I maintain a continuous accumulator $\Phi_{\text{accum}}$:
\[
    \Phi_{\text{accum}}(t) = \Phi_{\text{accum}}(t-1) + \Delta \theta
\]

\paragraph{Flip Detection Logic.}
A complete flip is defined as a net rotation of $2\pi$ radians. The system checks $\Phi_{\text{accum}}$ against this threshold every frame:

\begin{itemize}
    \item \textbf{Counter-Clockwise (Backflip):} If $\Phi_{\text{accum}} \ge 2\pi$, a flip is recorded, the flip count $N_{\text{ccw}}$ is incremented, and $2\pi$ is subtracted from the accumulator to allow detection of subsequent flips (double flips).
    \item \textbf{Clockwise (Frontflip):} If $\Phi_{\text{accum}} \le -2\pi$, a flip is recorded, $N_{\text{cw}}$ is incremented, and $2\pi$ is added to the accumulator.
\end{itemize}

Upon detecting a flip, the system triggers a callback to the \texttt{MainWindow} to award coins and spawns a floating "Flip!" popup text at the car's world coordinates $(x_{\text{car}}, y_{\text{car}})$.

\paragraph{Visual Feedback.}
To provide immediate feedback, I implemented a lightweight particle system within \texttt{FlipTracker}. When a flip occurs, a \texttt{Popup} struct is created containing the world location and an expiration timestamp:
\[
    T_{\text{expire}} = t_{\text{now}} + 1.5\text{s}
\]
During the render pass, these popups are drawn by manually plotting pixels to form the word "Flip!", creating a retro aesthetic consistent with the grid-based terrain.

\bigskip
\noindent\textbf{Source Code.} Below is the complete implementation of the flip tracking module and the relevant integration points in the main game loop.

flip.h 
\begin{lstlisting}[style=cgstyle,language=C++]
#pragma once
#include <QPainter>
#include <QList>
#include <QString>
#include <functional>
#include "constants.h"

class FlipTracker {
public:
    void reset() {
        m_init = false;
        m_lastAng = 0.0;
        m_accum = 0.0;
        m_cw = m_ccw = 0;
        m_popups.clear();
    }

    void update(double angleRad, double carX, double carY, double nowSec, const std::function<void(int)>& onAward);
    void drawHUD(QPainter& p, int levelIndex) const;
    void drawWorldPopups(QPainter& p, int cameraX, int cameraY, int level_index) const;

    int total() const { return m_cw + m_ccw; }
    int cw()    const { return m_cw; }
    int ccw()   const { return m_ccw; }

private:
    static constexpr double TWO_PI = 6.283185307179586;
    static constexpr int    COINS_PER_FLIP     = 50;
    static constexpr double POPUP_LIFETIME     = 1.5; // seconds
    static constexpr int    POPUP_OFFSET_CELLS = 10;

    struct Popup {
        int wx, wy;
        double until;
    };

    static void drawPixelWordFlip(QPainter& p, int gx, int gy, int cell, const QColor& c);

    bool   m_init = false;
    double m_lastAng = 0.0;
    double m_accum   = 0.0;
    int    m_cw = 0, m_ccw = 0;
    QList<Popup> m_popups;
};
\end{lstlisting}

flip.cpp 
\begin{lstlisting}[style=cgstyle,language=C++]
#include "flip.h"
#include <QtMath>
#include <algorithm>

static inline int gx_from_px(int px){
    return px / Constants::PIXEL_SIZE;
}

static inline int gy_from_px(int py){
    return py / Constants::PIXEL_SIZE;
}

void FlipTracker::update(double angleRad, double carX, double carY, double nowSec, const std::function<void(int)>& onAward)
{
    if (!m_init) {
        m_init = true;
        m_lastAng = angleRad;
        m_accum = 0.0;
        return;
    }

    // Normalize angle difference to (-PI, PI]
    double d = angleRad - m_lastAng;
    while (d >  M_PI) d -= TWO_PI;
    while (d <= -M_PI) d += TWO_PI;

    m_accum += d;
    m_lastAng = angleRad;

    // Check for CCW Flip (Backflip)
    while (m_accum >= TWO_PI) {
        ++m_ccw; m_accum -= TWO_PI;
        if (onAward) onAward(COINS_PER_FLIP);
        m_popups.append({int(carX), int(carY - POPUP_OFFSET_CELLS * Constants::PIXEL_SIZE),
                         nowSec + POPUP_LIFETIME});
    }
    // Check for CW Flip (Frontflip)
    while (m_accum <= -TWO_PI) {
        ++m_cw; m_accum += TWO_PI;
        if (onAward) onAward(COINS_PER_FLIP);
        m_popups.append({int(carX), int(carY - POPUP_OFFSET_CELLS * Constants::PIXEL_SIZE),
                         nowSec + POPUP_LIFETIME});
    }

    // Remove expired popups
    for (int i = 0; i < m_popups.size();) {
        if (m_popups[i].until <= nowSec) m_popups.removeAt(i);
        else ++i;
    }
}

void FlipTracker::drawHUD(QPainter& p, int levelIndex) const
{
    const int textGX = Constants::HUD_LEFT_MARGIN + 1;
    const int nitroBaselineGY = Constants::HUD_TOP_MARGIN + Constants::COIN_RADIUS_CELLS*2 + 4;
    const int extraGapCells = 10;
    const int textGY = nitroBaselineGY + 7 + extraGapCells;
    QFont f; f.setFamily("Monospace"); f.setBold(true); f.setPointSize(12);
    p.setFont(f);
    p.setPen(Constants::TEXT_COLOR[levelIndex]);
    p.drawText(textGX * Constants::PIXEL_SIZE,
               textGY  * Constants::PIXEL_SIZE,
               QString("Flips: %1").arg(total()));
}

void FlipTracker::drawPixelWordFlip(QPainter& p, int gx, int gy, int cell, const QColor& c)
{
    auto plot=[&](int x,int y){ p.fillRect((gx+x)*cell,(gy+y)*cell,cell,cell,c); };
    
    // Bitmaps for letters F, l, i, p, !
    static const uint8_t F[7]={0x1F,0x10,0x1E,0x10,0x10,0x10,0x10};
    static const uint8_t l[7]={0x04,0x04,0x04,0x04,0x04,0x04,0x06};
    static const uint8_t i[7]={0x00,0x08,0x00,0x18,0x08,0x08,0x1C};
    static const uint8_t glyphP[7]={0x00,0x00,0x1C,0x12,0x1C,0x10,0x10};
    static const uint8_t ex[7]={0x04,0x04,0x04,0x04,0x04,0x00,0x04};

    auto drawChar=[&](const uint8_t rows[7], int ox){
        for(int ry=0; ry<7; ++ry){
            uint8_t row=rows[ry];
            for(int rx=0; rx<5; ++rx)
                if (row & (1<<(4-rx))) plot(ox+rx, ry);
        }
    };

    int adv=6;
    drawChar(F, 0);
    drawChar(l, adv*1);
    drawChar(i, adv*2);
    drawChar(glyphP, adv*3);
    drawChar(ex,adv*4);
}

void FlipTracker::drawWorldPopups(QPainter& p, int cameraX, int cameraY, int level_index) const
{
    const int cell = Constants::PIXEL_SIZE;
    const int screenPadCells = 10;

    for (const auto& pop : m_popups) {
        const int gx = gx_from_px(pop.wx - cameraX) + screenPadCells;
        const int gy = gy_from_px(pop.wy + cameraY);
        drawPixelWordFlip(p, gx, gy, cell, Constants::FLIP_COLOR[level_index]);
    }
}
\end{lstlisting}

mainwindow.cpp (Integration Excerpt)
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::gameLoop() {
    ...
    double angleRad = 0.0;
    if (m_wheels.size() >= 2) {
        const double dx = (m_wheels[1]->x - m_wheels[0]->x);
        const double dy = (m_wheels[1]->y - m_wheels[0]->y);
        angleRad = std::atan2(dy, dx);
    }
    double carX = (!m_bodies.isEmpty()) ? m_bodies.first()->getX() : avgX;
    double carY = (!m_bodies.isEmpty()) ? m_bodies.first()->getY() : avgY;

    // Update tracker with current car angle and position
    m_flip.update(angleRad, carX, carY, m_elapsedSeconds, [this](int bonus){ 
        m_coinCount += bonus; 
    });  
    ...
}

void MainWindow::paintEvent(QPaintEvent *event) {
    ...
    p.save();
    p.translate(offX, offY);
    
    // Draw world objects
    ...
    m_flip.drawWorldPopups(p, m_cameraX, m_cameraY, level_index);

    p.restore();

    // Draw HUD elements
    ...
    m_flip.drawHUD(p, level_index);
    ...
}
\end{lstlisting}
\begin{figure}[h]
  \centering
  \begin{subfigure}{0.7\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/flip.png}
    \caption{World-space text popup triggered by a $360^\circ$ rotation}
  \end{subfigure}
  \caption{Aerial Flip Detection: Visual feedback showing the generated ``Flip!'' pixel-art text spawned relative to the car's position and the corresponding increment on the HUD counter.}
  \label{fig:flip_system}
\end{figure}
\subsubsection*{Results}
The \texttt{FlipTracker} successfully rewards skilled play by detecting loops in the car's trajectory. The normalization logic ensures that crossing the $180^\circ$ boundary does not reset or glitch the flip counter, and the pixel-art "Flip!" popup provides satisfying visual confirmation of the stunt without requiring complex texture assets.
\subsubsection*{Feature: Real-time Input Visualization (KeyLog) and HUD}
\textbf{Relevant classes and functions:} \texttt{KeyLog}, \texttt{MainWindow::paintEvent()}, \texttt{MainWindow::keyPressEvent()}, \texttt{MainWindow::keyReleaseEvent()}.

To provide immediate visual feedback on the player's control inputs—a feature commonly seen in speed-running tools and replays—I implemented a modular \texttt{KeyLog} class. This system overlays a pixel-art representation of the directional keys (W, A, D) onto the screen, lighting them up dynamically as the user presses the corresponding buttons.

\paragraph{Grid-based Layout and Positioning.}
Since the game renders in a low-resolution pixel grid scaled up by a factor $P_{\text{size}}$ (typically 4 or 5 screen pixels per game pixel), the input overlay must align perfectly with this grid. I calculate the grid dimensions as:
\[
    W_{\text{grid}} = \lfloor W_{\text{screen}} / P_{\text{size}} \rfloor, \qquad
    H_{\text{grid}} = \lfloor H_{\text{screen}} / P_{\text{size}} \rfloor.
\]
The keys are anchored to the bottom-right corner of the screen to avoid obstructing the gameplay view. If a key cluster has dimensions $w_{\text{pack}} \times h_{\text{pack}}$ (in grid cells) and a margin $m$, the top-left origin $(x_0, y_0)$ of the cluster is calculated as:
\[
    x_0 = W_{\text{grid}} - m - w_{\text{pack}}, \qquad
    y_0 = H_{\text{grid}} - m - h_{\text{pack}}.
\]
From this anchor, the specific keys ('A', 'W', 'D') are offset relatively. For example, the 'W' key is centered above the 'A' and 'D' keys:
\[
    x_W = x_0 + \frac{w_{\text{pack}} - w_{\text{key}}}{2}, \qquad y_W = y_0.
\]

\paragraph{Bitwise Glyph Rendering.}
To maintain the retro aesthetic without importing external font textures, I implemented a lightweight bitmapped font renderer within \texttt{KeyLog::drawGlyph}. Each character is represented by an array of bytes, where each byte corresponds to a row of pixels.

For a given row $r$ containing the byte value $B_r$, and a glyph width $w_g$, the visibility of a pixel at column $c$ is determined by a bitwise check:
\[
    \text{pixel}(c, r) = 
    \begin{cases} 
      \text{on}, & \text{if } (B_r \gg (w_g - 1 - c)) \& 1 \\
      \text{off}, & \text{otherwise}
    \end{cases}
\]
This allows me to draw crisp, scalable alphanumeric characters directly onto the \texttt{QPainter} surface using the game's unified \texttt{plot} function.

\paragraph{State Management and Rendering.}
The visual state (pressed vs. unpressed) is managed via boolean flags updated in the Qt event loop. During the render pass, I select the border color $C_{\text{border}}$ based on this state:
\[
    C_{\text{border}} = 
    \begin{cases} 
      C_{\text{hot}} = (255, 255, 255), & \text{if pressed} \\
      C_{\text{dim}} = (70, 70, 80), & \text{otherwise}
    \end{cases}
\]
This provides a high-contrast response that is instantly readable even during fast-paced gameplay.

\bigskip
\noindent\textbf{Core Code Snippets.} Below is the complete implementation of the input visualization module and its integration into the main window's event handling.

keylog.h 
\begin{lstlisting}[style=cgstyle,language=C++]
#pragma once
#include <QPainter>
#include <Qt>

class KeyLog {
public:
    void setPressed(int key, bool down) {
        if (key == Qt::Key_W) m_w = down;
        else if (key == Qt::Key_A) m_a = down;
        else if (key == Qt::Key_D) m_d = down;
    }
    void draw(QPainter& p, int screenW, int screenH, int pixelSize);

private:
    bool m_w = false, m_a = false, m_d = false;

    static inline void plot(QPainter& p, int gx, int gy, int ps, const QColor& c) {
        p.fillRect(gx*ps, gy*ps, ps, ps, c);
    }
    void drawKey(QPainter& p, int gx, int gy, int w, int h, int ps, QChar label, bool pressed);
    void drawGlyph(QPainter& p, int gx, int gy, int w, int h, int ps, QChar ch, const QColor& color);
};
\end{lstlisting}

keylog.cpp 
\begin{lstlisting}[style=cgstyle,language=C++]
#include "keylog.h"
#include "constants.h"
#include <QRect>
#include <algorithm>

void KeyLog::draw(QPainter& p, int screenW, int screenH, int ps) {
    const int gridW = screenW / ps;
    const int gridH = screenH / ps;

    const int margin = 2;
    const int gap    = 1;
    const int keyW   = 11;
    const int keyH   = 9;

    const int packW  = 2*keyW + gap;
    const int packH  = 2*keyH + gap;

    // Calculate anchor position (Bottom-Right)
    const int gx0 = gridW - margin - packW;
    const int gy0 = gridH - margin - packH;

    // Relative positions for W, A, D
    const int gxW = gx0 + (packW - keyW)/2;
    const int gyW = gy0;

    const int gxA = gx0;
    const int gyA = gy0 + keyH + gap;

    const int gxD = gx0 + keyW + gap;
    const int gyD = gyA;

    p.save();
    drawKey(p, gxW, gyW, keyW, keyH, ps, QChar('W'), m_w);
    drawKey(p, gxA, gyA, keyW, keyH, ps, QChar('A'), m_a);
    drawKey(p, gxD, gyD, keyW, keyH, ps, QChar('D'), m_d);
    p.restore();
}

void KeyLog::drawKey(QPainter& p, int gx, int gy, int w, int h, int ps, QChar label, bool pressed) {
    const QColor fill(120,120,130,40);
    const QColor borderDim(70,70,80);
    const QColor borderHot(255,255,255);

    // Fill background
    for (int y=0; y<h; ++y)
        for (int x=0; x<w; ++x)
            plot(p, gx+x, gy+y, ps, fill);

    // Draw Border based on state
    const QColor bc = pressed ? borderHot : borderDim;
    for (int x=0; x<w; ++x) { plot(p, gx+x, gy+0, ps, bc); plot(p, gx+x, gy+h-1, ps, bc); }
    for (int y=0; y<h; ++y) { plot(p, gx+0, gy+y, ps, bc); plot(p, gx+w-1, gy+y, ps, bc); }

    drawGlyph(p, gx, gy, w, h, ps, label, QColor(255,255,255));
}

void KeyLog::drawGlyph(QPainter& p, int gx, int gy, int w, int h, int ps, QChar ch, const QColor& color) {
    auto it = font_map.find(ch.toUpper()); // font_map defined in constants.h
    if (it == font_map.end()) return;

    const int gw = 5, gh = 7;
    const int pad = 2;
    const int innerW = std::max(0, w - 2*pad);
    const int innerH = std::max(0, h - 2*pad);
    const int cell = std::max(1, std::min(innerW / gw, innerH / gh));
    const int ox = gx + pad + (innerW - gw*cell)/2;
    const int oy = gy + pad + (innerH - gh*cell)/2;

    const auto& rows = it.value();
    for (int r=0; r<gh; ++r) {
        uint8_t row = rows[r];
        for (int c=0; c<gw; ++c) {
            // Bitwise check for pixel presence
            if (row & (1 << (gw-1-c))) {
                for (int yy=0; yy<cell; ++yy)
                    for (int xx=0; xx<cell; ++xx)
                        plot(p, ox + c*cell + xx, oy + r*cell + yy, ps, color);
            }
        }
    }
}
\end{lstlisting}

mainwindow.cpp (Event Handling and HUD Integration)
\begin{lstlisting}[style=cgstyle,language=C++]
void MainWindow::keyPressEvent(QKeyEvent *event) {
    if (event->isAutoRepeat()) return;

    switch (event->key()) {
        case Qt::Key_D:
        case Qt::Key_Right:
            // ... physics logic ...
            m_keylog.setPressed(Qt::Key_D, true);
            break;

        case Qt::Key_A:
        case Qt::Key_Left:
            // ... physics logic ...
            m_keylog.setPressed(Qt::Key_A, true);
            break;

        case Qt::Key_W:
        case Qt::Key_Up:
            // ... physics logic ...
            m_keylog.setPressed(Qt::Key_W, true);
            break;
        // ...
    }
}

void MainWindow::keyReleaseEvent(QKeyEvent *event) {
    if (event->isAutoRepeat()) return;

    switch (event->key()) {
    case Qt::Key_D:
    case Qt::Key_Right:
        // ...
        m_keylog.setPressed(Qt::Key_D, false);
        break;
    case Qt::Key_A:
    case Qt::Key_Left:
        // ...
        m_keylog.setPressed(Qt::Key_A, false);
        break;
    case Qt::Key_W:
    case Qt::Key_Up:
        // ...
        m_keylog.setPressed(Qt::Key_W, false);
        break;
    // ...
    }
}

void MainWindow::paintEvent(QPaintEvent *event) {
    // ... (Scene rendering) ...

    // Draw HUD overlay elements
    drawHUDFuel(p);
    drawHUDCoins(p);
    m_nitroSys.drawHUD(p, m_elapsedSeconds, level_index);
    drawHUDDistance(p);
    drawHUDScore(p);

    // Draw Input Visualizer on top
    m_keylog.draw(p, width(), height(), Constants::PIXEL_SIZE);
}
\end{lstlisting}
\begin{figure}[h]
  \centering
  \begin{subfigure}{0.6\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/key.png}
    \caption{Real-time input visualization overlay}
  \end{subfigure}
  \caption{KeyLog HUD: Pixel-perfect rendering of the directional keys (W, A, D) anchored to the bottom-right corner, providing immediate visual feedback of the player's control inputs during gameplay.}
  \label{fig:keylog_system}
\end{figure}
\subsubsection*{Results}
The \texttt{KeyLog} system was successfully integrated, providing a clean, non-intrusive visual indicator of input states. The mathematical scaling ensures it remains pixel-perfect regardless of the window size or screen resolution, maintaining the game's coherent 8-bit aesthetic.
\subsubsection*{Feature: Procedural Environmental Props and Audio Management}
\textbf{Relevant classes and functions:} \texttt{PropSystem}, \texttt{Media}, \texttt{assets.qrc}.

To enhance the visual diversity of the infinite terrain and provide auditory feedback, I implemented two distinct subsystems: a procedural prop generator and a low-latency audio manager.

\paragraph{Programmatic Prop Generation.}
Rather than relying on external sprite textures, which can cause scaling artifacts in a pixel-grid renderer, I implemented the \texttt{PropSystem} to draw environmental elements programmatically using geometric primitives. This ensures that trees, buildings, and rocks align perfectly with the global pixel grid $G_{\text{size}}$.

The spawning logic in \texttt{maybeSpawnProp} utilizes a stochastic process constrained by terrain topology. For a given world coordinate $x_w$ and a generated random variable $r \in [0, 1]$, a prop of type $T$ is spawned if:
\[
    r < P(\text{spawn}| \text{level}) \quad \text{and} \quad |\text{slope}(x_w)| < \theta_{\text{max}},
\]
where $\theta_{\text{max}}$ is a slope threshold (e.g., $0.15$ for camels/igloos) ensuring that structure-like props only appear on relatively flat ground.

For the "Nightlife" level, I implemented a specific procedural generation algorithm for buildings. The system generates skyscrapers with varying widths, heights, and window patterns. To simulate neon lighting without lighting engines, I use modulus arithmetic on the coordinate space to determine window states:
\[
    \text{Window}(x, y) = 
    \begin{cases} 
      \text{On}, & \text{if } (x \mod S_x = 0) \land ((x+y) \mod S_y \neq 0) \\
      \text{Off}, & \text{otherwise}
    \end{cases}
\]
This creates complex, scrolling interference patterns that resemble lit windows as the camera moves.

\paragraph{Audio Pooling and Dynamic Mixing.}
The \texttt{Media} class manages the game's soundscape. A significant challenge in fast-paced games is "sound cutting," where a new sound effect (like a coin pickup) terminates the previous one if a single audio channel is reused. To solve this, I implemented an audio pool (Round-Robin scheduling) for high-frequency events.

For coin pickups, I maintain a pool of $N=3$ media players. When a coin is collected at step $k$, the player index $i$ is selected as:
\[
    i_k = (i_{k-1} + 1) \mod N
\]
This allows up to three coin sounds to overlap naturally.

Additionally, I implemented a dynamic engine sound loop. To avoid abrupt audio cuts when the player releases the accelerator, I use a \texttt{QPropertyAnimation} to interpolate the volume $V$ over time $t$:
\[
    V(t) = V_{\text{initial}} \cdot (1 - \frac{t}{T_{\text{fade}}})
\]
This provides a smooth audio decay that mimics physical engine spin-down.

\bigskip
\noindent\textbf{Source Code.} Below are the complete implementations for the prop generation system, the media manager, and the resource configuration.

prop.h
\begin{lstlisting}[style=cgstyle,language=C++]
#ifndef PROP_H
#define PROP_H

#include <QVector>
#include <QColor>
#include <random>
#include <QPainter>
#include <QHash>
#include "constants.h"

enum class PropType {
    Tree, Rock, Flower, Mushroom,
    Cactus, Tumbleweed, Camel,
    Igloo, Penguin, Snowman, IceSpike,
    UFO,
    Rover, Alien,
    Building, StreetLamp
};

struct Prop {
    int wx;
    int wy;
    PropType type;
    int variant;
    bool flipped;
};

class PropSystem {
public:
    PropSystem();

    void maybeSpawnProp(int worldX, int groundGy, int levelIndex, float slope, std::mt19937& rng);
    void draw(QPainter& p, int camX, int camY, int screenW, int screenH, const QHash<int,int>& heightMap);
    void prune(int minWorldX);
    void clear();

private:
    QVector<Prop> m_props;

    void plot(QPainter& p, int gx, int gy, const QColor& c);

    void drawTree(QPainter& p, int gx, int gy, int worldGX, int wx, int wy, int variant, const QHash<int,int>& heightMap);
    void drawRock(QPainter& p, int gx, int gy, int variant);
    void drawFlower(QPainter& p, int gx, int gy, int variant);
    void drawMushroom(QPainter& p, int gx, int gy, int variant);
    void drawCactus(QPainter& p, int gx, int gy, int variant);
    void drawTumbleweed(QPainter& p, int gx, int gy, int variant);
    void drawCamel(QPainter& p, int gx, int gy, int variant, bool flipped);
    void drawIgloo(QPainter& p, int gx, int gy, int worldGX, int variant, const QHash<int,int>& heightMap);
    void drawPenguin(QPainter& p, int gx, int gy, int variant, bool flipped);
    void drawSnowman(QPainter& p, int gx, int gy, int variant);
    void drawIceSpike(QPainter& p, int gx, int gy, int variant);
    void drawUFO(QPainter& p, int gx, int gy, int variant);
    void drawRover(QPainter& p, int gx, int gy, int worldGX, int variant, bool flipped, const QHash<int,int>& heightMap);
    void drawAlien(QPainter& p, int gx, int gy, int variant);

    void drawBuilding(QPainter& p, int gx, int gy, int worldGX, int variant, const QHash<int,int>& heightMap);
    void drawStreetLamp(QPainter& p, int gx, int gy, int worldGX, int variant, const QHash<int,int>& heightMap);
};

#endif
\end{lstlisting}

prop.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "prop.h"
#include <cmath>
#include <algorithm>
#include <vector>

PropSystem::PropSystem() {}

void PropSystem::clear() {
    m_props.clear();
}

void PropSystem::prune(int minWorldX) {
    auto it = std::remove_if(m_props.begin(), m_props.end(), [minWorldX](const Prop& p){
        return p.wx < minWorldX - 500;
    });
    m_props.erase(it, m_props.end());
}

void PropSystem::maybeSpawnProp(int worldX, int groundGy, int levelIndex, float slope, std::mt19937& rng) {
    std::uniform_real_distribution<float> dist(0.0f, 1.0f);
    std::uniform_int_distribution<int> varDist(0, 6);
    std::uniform_int_distribution<int> flipDist(0, 1);

    if (!m_props.isEmpty()) {
        int minSpacing = 120;
        if (levelIndex == 5) minSpacing = 30;

        if (std::abs(worldX - m_props.last().wx) < minSpacing) {
            return;
        }
    }

    float chance = dist(rng);
    int wy = groundGy * Constants::PIXEL_SIZE;

    if (levelIndex == 0) {
        if (chance < 0.03f)      m_props.append({worldX, wy, PropType::Tree,    varDist(rng), (bool)flipDist(rng)});
        else if (chance < 0.06f) m_props.append({worldX, wy, PropType::Rock,    varDist(rng), (bool)flipDist(rng)});
        else if (chance < 0.12f) m_props.append({worldX, wy, PropType::Flower,  varDist(rng), false});
        else if (chance < 0.14f) m_props.append({worldX, wy, PropType::Mushroom,varDist(rng), false});
    }
    else if (levelIndex == 1) {
        if (chance < 0.02f) {
            if (std::abs(slope) < 0.15f) {
                bool camelNearby = false;
                for(const auto& p : m_props) {
                    if (p.type == PropType::Camel && std::abs(p.wx - worldX) < 3000) {
                        camelNearby = true;
                        break;
                    }
                }
                if (!camelNearby) {
                    m_props.append({worldX, wy, PropType::Camel, varDist(rng), (bool)flipDist(rng)});
                }
            }
        }
        else if (chance < 0.06f) {
            m_props.append({worldX, wy, PropType::Cactus, varDist(rng), (bool)flipDist(rng)});
        }
        else if (chance > 0.998f) {
            bool exists = false;
            for(const auto& p : m_props) {
                if (p.type == PropType::Tumbleweed && std::abs(p.wx - worldX) < 1000) {
                    exists = true;
                    break;
                }
            }
            if (!exists) {
                m_props.append({worldX, wy, PropType::Tumbleweed, varDist(rng), (bool)flipDist(rng)});
            }
        }
    }
    else if (levelIndex == 2) {
        if (chance < 0.018f) {
            m_props.append({worldX, wy, PropType::Penguin, varDist(rng), (bool)flipDist(rng)});
        }
        else if (chance < 0.048f) {
            if (std::abs(slope) < 0.15f) {
                bool iglooNearby = false;
                for (const auto& p : m_props) {
                    if (p.type == PropType::Igloo && std::abs(p.wx - worldX) < 2500) {
                        iglooNearby = true;
                        break;
                    }
                }
                if (!iglooNearby) {
                    m_props.append({worldX, wy, PropType::Igloo, varDist(rng), false});
                }
            }
        }
        else if (chance < 0.06f) {
            m_props.append({worldX, wy, PropType::Snowman, varDist(rng), (bool)flipDist(rng)});
        }
        else if (chance < 0.08f) {
            m_props.append({worldX, wy, PropType::IceSpike, varDist(rng), (bool)flipDist(rng)});
        }
    }
    else if (levelIndex == 3) {
        if (chance < 0.009f) {
            int liftCells = 50 + (varDist(rng) * 2);
            int skyWy = wy - (liftCells * Constants::PIXEL_SIZE);
            m_props.append({worldX, skyWy, PropType::UFO, varDist(rng), false});
        }
    }
    else if (levelIndex == 4) {
        if (chance < 0.015f) {
            if (std::abs(slope) < 0.25f) {
                m_props.append({worldX, wy, PropType::Rover, varDist(rng), (bool)flipDist(rng)});
            }
        }
        else if (chance > 0.998f) {
            m_props.append({worldX, wy, PropType::Alien, varDist(rng), false});
        }
    }
    else if (levelIndex == 5) {
        if (chance < 0.5f) {
            m_props.append({worldX, wy, PropType::Building, varDist(rng), false});
        }

        float lampChance = dist(rng);
        if (lampChance < 0.1f) {
            m_props.append({worldX + 15, wy, PropType::StreetLamp, varDist(rng), false});
        }
    }
}

void PropSystem::draw(QPainter& p, int camX, int camY, int screenW, int screenH, const QHash<int,int>& heightMap) {
    int camGX = camX / Constants::PIXEL_SIZE;
    int camGY = camY / Constants::PIXEL_SIZE;

    auto drawProp = [&](const Prop& prop) {
        if (prop.wx < camX - 200 || prop.wx > camX + screenW + 200) return;

        int gx = (prop.wx / Constants::PIXEL_SIZE) - camGX;
        int gy = (prop.wy / Constants::PIXEL_SIZE) + camGY;
        int worldGX = prop.wx / Constants::PIXEL_SIZE;

        switch (prop.type) {
        case PropType::Tree:       drawTree(p, gx, gy, worldGX, prop.wx, prop.wy, prop.variant, heightMap); break;
        case PropType::Rock:       drawRock(p, gx, gy, prop.variant); break;
        case PropType::Flower:     drawFlower(p, gx, gy, prop.variant); break;
        case PropType::Mushroom:   drawMushroom(p, gx, gy, prop.variant); break;
        case PropType::Cactus:     drawCactus(p, gx, gy, prop.variant); break;
        case PropType::Tumbleweed: drawTumbleweed(p, gx, gy, prop.variant); break;
        case PropType::Camel:      drawCamel(p, gx, gy, prop.variant, prop.flipped); break;
        case PropType::Igloo:      drawIgloo(p, gx, gy, worldGX, prop.variant, heightMap); break;
        case PropType::Penguin:    drawPenguin(p, gx, gy, prop.variant, prop.flipped); break;
        case PropType::Snowman:    drawSnowman(p, gx, gy, prop.variant); break;
        case PropType::IceSpike:   drawIceSpike(p, gx, gy, prop.variant); break;
        case PropType::UFO:        drawUFO(p, gx, gy, prop.variant); break;
        case PropType::Rover:      drawRover(p, gx, gy, worldGX, prop.variant, prop.flipped, heightMap); break;
        case PropType::Alien:      drawAlien(p, gx, gy, prop.variant); break;
        case PropType::Building:   drawBuilding(p, gx, gy, worldGX, prop.variant, heightMap); break;
        case PropType::StreetLamp: drawStreetLamp(p, gx, gy, worldGX, prop.variant, heightMap); break;
        }
    };

    for (const Prop& prop : m_props) {
        if (prop.type == PropType::Building) drawProp(prop);
    }

    for (const Prop& prop : m_props) {
        if (prop.type != PropType::Building) drawProp(prop);
    }
}

void PropSystem::plot(QPainter& p, int gx, int gy, const QColor& c) {
    p.fillRect(gx * Constants::PIXEL_SIZE, gy * Constants::PIXEL_SIZE,
               Constants::PIXEL_SIZE, Constants::PIXEL_SIZE, c);
}

void PropSystem::drawBuilding(QPainter& p, int gx, int gy, int worldGX, int variant, const QHash<int,int>& heightMap) {
    QColor bDark(10, 10, 18);
    QColor bFrame(40, 40, 60);

    std::vector<QColor> neons = {
        QColor(30, 180, 180), QColor(180, 0, 90), QColor(120, 0, 200),
        QColor(50, 180, 40),  QColor(200, 180, 40), QColor(200, 80, 40),
        QColor(80, 100, 180)
    };
    QColor neon = neons[(variant + worldGX) % neons.size()];

    int h = 30 + (variant * 4);
    int w = 32 + (variant % 3) * 8;

    if (variant == 5) { w = 25; h = 80; }
    if (variant == 3) { w = 36; h = 100; }

    int leftRel = -w/2;
    int rightRel = w/2;
    int topScreenY = gy - h;

    for (int dx = leftRel; dx <= rightRel; dx++) {
        int currentWX = worldGX + dx;
        int currentScreenX = gx + dx;

        int centerGroundY = heightMap.value(worldGX, 0);
        int groundYAtCol = heightMap.value(currentWX, centerGroundY);
        int groundScreenY = gy + (groundYAtCol - centerGroundY);

        int columnHeight = groundScreenY - topScreenY;
        if (columnHeight > 0) {
            bool isSideEdge = (dx == leftRel || dx == rightRel);
            p.fillRect(currentScreenX * Constants::PIXEL_SIZE,
                       topScreenY * Constants::PIXEL_SIZE,
                       Constants::PIXEL_SIZE,
                       columnHeight * Constants::PIXEL_SIZE,
                       isSideEdge ? bFrame : bDark);
        }

        plot(p, currentScreenX, topScreenY, bFrame);

        if (dx > leftRel && dx < rightRel) {
            int yStart = topScreenY + 2;

            for (int y = yStart; y < groundScreenY - 1; y += 4) {
                bool windowExists = false;
                int relY = y - topScreenY;

                if (variant == 5) {
                    windowExists = true;
                } else if (variant == 3) {
                    if ((dx % 4) == 0) windowExists = true;
                } else {
                    if ((dx % 3 == 0) && ((dx + relY) % 3 != 0)) windowExists = true;
                }

                if (windowExists) {
                    p.fillRect(currentScreenX * Constants::PIXEL_SIZE,
                               y * Constants::PIXEL_SIZE,
                               Constants::PIXEL_SIZE,
                               2 * Constants::PIXEL_SIZE,
                               neon);
                }
            }
        }
    }

    if (variant == 3 || variant == 5) {
        for(int i=1; i<=10; i++){
            plot(p, gx, topScreenY - i, bFrame);
        }
    }
}

void PropSystem::drawStreetLamp(QPainter& p, int gx, int gy, int worldGX, int variant, const QHash<int,int>& heightMap) {
    QColor pole(100, 100, 110);
    QColor light(255, 255, 220);

    if (variant % 3 == 1) light = QColor(200, 240, 255);
    else if (variant % 3 == 2) light = QColor(255, 200, 180);

    int h = 24;
    int groundScreenY = gy;

    p.fillRect(gx * Constants::PIXEL_SIZE, (groundScreenY - h) * Constants::PIXEL_SIZE,
               Constants::PIXEL_SIZE, h * Constants::PIXEL_SIZE, pole);

    plot(p, gx + 1, groundScreenY - h, pole);
    plot(p, gx + 2, groundScreenY - h, pole);
    plot(p, gx + 2, groundScreenY - h + 1, light);
    plot(p, gx + 1, groundScreenY - h + 2, light);
    plot(p, gx + 3, groundScreenY - h + 2, light);
    plot(p, gx + 2, groundScreenY - h + 2, light);
}

void PropSystem::drawTree(QPainter& p, int gx, int gy, int worldGX, int wx, int wy, int variant, const QHash<int,int>& heightMap) {
    QColor cTrunk(184, 115, 51); QColor cTrunkDark(100, 50, 20); QColor cHole(80, 40, 10);
    QColor cLeafBase(46, 184, 46); QColor cLeafLight(154, 235, 90); QColor cLeafDark(20, 110, 35);
    int trunkW = 6; int trunkH = 30 + (variant * 2);
    int centerGroundWorldY = heightMap.value(worldGX, 0); int camYOffset = gy - centerGroundWorldY;
    int peakScreenY = 999999; int halfTrunk = trunkW / 2;
    for(int dx = -halfTrunk; dx < halfTrunk; dx++) { 
        int wgx = worldGX + dx; 
        if(heightMap.contains(wgx)) { 
            int sGY = heightMap.value(wgx) + camYOffset; 
            if(sGY < peakScreenY) peakScreenY = sGY; 
        } 
    }
    if(peakScreenY == 999999) peakScreenY = gy;
    int effectiveBaseY = peakScreenY - 1;
    for(int dx = -halfTrunk + 1; dx < halfTrunk; dx++) { 
        int wgx = worldGX + dx; 
        int groundScreenY = gy; 
        if(heightMap.contains(wgx)) groundScreenY = heightMap.value(wgx) + camYOffset; 
        int trunkTopY = effectiveBaseY - trunkH;
        for(int y = trunkTopY; y <= groundScreenY; y++) {
            bool isBorder = (dx == -halfTrunk+1 || dx == halfTrunk-1); 
            bool isShadow = (dx == -1 && (effectiveBaseY - y) > 0 && (effectiveBaseY - y) % 3 == 0); 
            bool isLight  = (dx == 1  && (effectiveBaseY - y) > 0 && (effectiveBaseY - y) % 4 == 0);
            bool isRootFill = (y > effectiveBaseY); 
            QColor c = cTrunk; 
            if (isRootFill) c = cTrunkDark; 
            else if (isBorder) c = cTrunkDark; 
            else if (isShadow) c = cTrunkDark; 
            else if (isLight)  c = cTrunk.lighter(110);
            plot(p, gx + dx, y, c);
        }
    }
    plot(p, gx, effectiveBaseY - trunkH/2, cHole); plot(p, gx, effectiveBaseY - trunkH/2 - 1, cHole);
    int folBot = effectiveBaseY - trunkH + 2;
    std::vector<int> rows = { 26, 28, 30, 30, 28, 26, 22, 20, 22, 24, 24, 22, 20, 16, 14, 18, 20, 18, 16, 14, 12, 10, 14, 16, 14, 12, 10, 8, 6, 8, 6, 4, 2 };
    for(int i=0; i<rows.size(); i++) { 
        int w = rows[i]; if (variant % 2 == 0) w += 2; 
        int py = folBot - i; int startX = gx - w/2; int endX = gx + w/2;
        for(int px = startX; px <= endX; px++) { 
            int snX = (wx / Constants::PIXEL_SIZE) + (px - gx); 
            int snY = (wy / Constants::PIXEL_SIZE) - i; 
            int pat = (snX * 17 + snY * 13 + variant * 7) % 100; 
            int lightThresh = 50; int shadowThresh = 15;
            if (px < gx) { lightThresh -= 15; shadowThresh -= 10; } 
            else if (px > gx) { lightThresh += 25; shadowThresh += 20; }
            QColor c = cLeafBase; 
            if (pat > lightThresh) c = cLeafLight; 
            else if (pat < shadowThresh) c = cLeafDark; 
            if (px == startX || px == endX || i == rows.size()-1) { c = cLeafDark; }
            plot(p, px, py, c);
        }
    }
}

void PropSystem::drawRock(QPainter& p, int gx, int gy, int variant) { 
    QColor c(100, 100, 110); QColor highlight(140, 140, 150); int r = 2 + (variant % 2); 
    for(int dy = -r; dy <= 0; dy++) { 
        for(int dx = -r; dx <= r; dx++) { 
            if (dx*dx + (dy*dy)*1.5 <= r*r) { plot(p, gx+dx, gy+dy, (dx<0 && dy<-r/2) ? highlight : c); } 
        } 
    } 
}

void PropSystem::drawFlower(QPainter& p, int gx, int gy, int variant) { 
    QColor stem(50, 160, 50); 
    QColor petal = (variant % 3 == 0) ? QColor(255, 50, 50) : ((variant % 3 == 1) ? QColor(255, 255, 50) : QColor(100, 100, 255)); 
    plot(p, gx, gy, stem); plot(p, gx, gy-1, stem); plot(p, gx-2, gy-1, petal); plot(p, gx-1, gy-1, petal); 
    plot(p, gx, gy-1, petal); plot(p, gx+1, gy-1, petal); plot(p, gx+2, gy-1, petal); 
    plot(p, gx-1, gy-2, petal); plot(p, gx, gy-2, petal); plot(p, gx+1, gy-2, petal); plot(p, gx, gy-3, petal); 
}

void PropSystem::drawMushroom(QPainter& p, int gx, int gy, int variant) { 
    QColor stalk(220, 220, 210); 
    QColor cap = (variant % 2 == 0) ? QColor(200, 60, 60) : QColor(180, 140, 80); 
    plot(p, gx, gy, stalk); plot(p, gx, gy-1, stalk); plot(p, gx-2, gy-1, cap); plot(p, gx-1, gy-1, cap); 
    plot(p, gx, gy-1, cap); plot(p, gx+1, gy-1, cap); plot(p, gx+2, gy-1, cap); 
    plot(p, gx-1, gy-2, cap); plot(p, gx, gy-2, cap); plot(p, gx+1, gy-2, cap); 
}

void PropSystem::drawCactus(QPainter& p, int gx, int gy, int variant) { 
    QColor c(40, 150, 40); int h = 10 + variant * 2; 
    for(int y=0; y<h; y++) { plot(p, gx, gy - y, c); plot(p, gx - 1, gy - y, c); plot(p, gx + 1, gy - y, c); } 
    plot(p, gx, gy - h, c); 
    if (variant > 0) { 
        int armY = gy - (h/2); plot(p, gx-2, armY, c); plot(p, gx-3, armY, c); plot(p, gx-2, armY+1, c); 
        plot(p, gx-3, armY+1, c); plot(p, gx-3, armY-1, c); plot(p, gx-4, armY-1, c); plot(p, gx-3, armY-2, c); plot(p, gx-4, armY-2, c); 
    } 
    if (variant > 2) { 
        int armY2 = gy - (h/2) - 2; plot(p, gx+2, armY2, c); plot(p, gx+3, armY2, c); plot(p, gx+2, armY2+1, c); 
        plot(p, gx+3, armY2+1, c); plot(p, gx+3, armY2-1, c); plot(p, gx+4, armY2-1, c); plot(p, gx+3, armY2-2, c); plot(p, gx+4, armY2-2, c); 
    } 
}

void PropSystem::drawTumbleweed(QPainter& p, int gx, int gy, int variant) { 
    QColor twigDark(100, 80, 50); QColor twigLight(180, 140, 90); int r = 7 + (variant % 3); int cy = gy - r; 
    for(int dy = -r; dy <= r; dy++) { 
        for(int dx = -r; dx <= r; dx++) { 
            double dist = std::sqrt(dx*dx + dy*dy); 
            if (dist <= r) { 
                int lines1 = (dx * 3 + dy * 3 + variant * 11) % 7; int lines2 = (dx * -3 + dy * 4 + variant * 5) % 6; int lines3 = (dx * 5 + dy + variant * 2) % 9; 
                bool isBranch = false; QColor c = twigDark; 
                if (lines1 == 0 || lines2 == 0) isBranch = true; 
                if (lines3 == 0 && dist < r - 2) isBranch = true; 
                if (dist > r - 1.5) { isBranch = true; c = twigDark; } else if (isBranch) { c = twigLight; } 
                int noise = (dx * 97 + dy * 89) % 100; 
                if (isBranch && lines1 != 0 && lines2 != 0 && noise < 20) { isBranch = false; } 
                if (isBranch) { plot(p, gx+dx, cy+dy, c); } 
            } 
        } 
    } 
}

void PropSystem::drawCamel(QPainter& p, int gx, int gy, int variant, bool flipped) { 
    int d = flipped ? -1 : 1; QColor bodyColor(218, 165, 32); QColor legColor(139, 69, 19); 
    for (int y = 0; y < 8; ++y) plot(p, gx + (4 * d), gy - y, legColor); 
    for (int y = 0; y < 8; ++y) plot(p, gx - (6 * d), gy - y, legColor); 
    for (int y = 1; y < 8; ++y) plot(p, gx + (3 * d), gy - y, bodyColor); 
    for (int y = 1; y < 8; ++y) plot(p, gx - (5 * d), gy - y, bodyColor); 
    for (int x = -7; x <= 5; ++x) { for (int y = 8; y < 14; ++y) { plot(p, gx + (x * d), gy - y, bodyColor); } } 
    bool twoHumps = (variant % 2 == 0); 
    if (twoHumps) { 
        plot(p, gx - (4 * d), gy - 14, bodyColor); plot(p, gx - (3 * d), gy - 14, bodyColor); 
        plot(p, gx - (4 * d), gy - 15, bodyColor); plot(p, gx - (3 * d), gy - 15, bodyColor); 
        plot(p, gx + (1 * d), gy - 14, bodyColor); plot(p, gx + (2 * d), gy - 14, bodyColor); 
        plot(p, gx + (1 * d), gy - 15, bodyColor); plot(p, gx + (2 * d), gy - 15, bodyColor); 
    } else { 
        for(int x = -2; x <= 1; x++) { plot(p, gx + (x * d), gy - 14, bodyColor); plot(p, gx + (x * d), gy - 15, bodyColor); } 
        plot(p, gx - (1 * d), gy - 16, bodyColor); plot(p, gx, gy - 16, bodyColor); 
    } 
    for(int y = 12; y < 18; y++) { plot(p, gx + (6 * d), gy - y, bodyColor); plot(p, gx + (7 * d), gy - y, bodyColor); } 
    plot(p, gx + (6 * d), gy - 18, bodyColor); plot(p, gx + (7 * d), gy - 18, bodyColor); 
    plot(p, gx + (8 * d), gy - 18, bodyColor); plot(p, gx + (6 * d), gy - 19, bodyColor); 
    plot(p, gx + (7 * d), gy - 19, bodyColor); plot(p, gx + (5 * d), gy - 19, legColor); 
    plot(p, gx + (7 * d), gy - 19, legColor); plot(p, gx - (8 * d), gy - 10, legColor); plot(p, gx - (8 * d), gy - 9, bodyColor); 
}

void PropSystem::drawIgloo(QPainter& p, int gx, int gy, int worldGX, int variant, const QHash<int,int>& heightMap) { 
    QColor ice(220, 230, 255); QColor iceShadow(180, 190, 220); QColor dark(50, 50, 60); 
    int r = 14 + (variant % 3); int centerGroundWorldY = heightMap.value(worldGX, 0); int camYOffset = gy - centerGroundWorldY; 
    int peakScreenY = 999999; 
    for(int dx = -r; dx <= r; dx++) { 
        int wgx = worldGX + dx; if(heightMap.contains(wgx)) { 
            int groundScreenY = heightMap.value(wgx) + camYOffset; 
            if(groundScreenY < peakScreenY) { peakScreenY = groundScreenY; } 
        } 
    } 
    if (peakScreenY == 999999) peakScreenY = gy; 
    for(int dx = -r; dx <= r; dx++) { 
        int wgx = worldGX + dx; int groundScreenY = gy; 
        if(heightMap.contains(wgx)) { groundScreenY = heightMap.value(wgx) + camYOffset; } 
        int h = std::round(std::sqrt(r*r - dx*dx)); int domeTopY = peakScreenY - h; 
        for (int y = domeTopY; y < groundScreenY; y++) { 
            bool isFoundation = (y >= peakScreenY); bool isShadow = (dx > r/3) || (y > peakScreenY - r/4 && !isFoundation); 
            QColor c = (isShadow || isFoundation) ? iceShadow : ice; plot(p, gx + dx, y, c); 
        } 
    } 
    int tunW = 6; int tunH = 8; int tunBaseY = peakScreenY; 
    for(int dx = -tunW; dx <= tunW; dx++) { 
        int wgx = worldGX + dx; int groundScreenY = gy; 
        if(heightMap.contains(wgx)) groundScreenY = heightMap.value(wgx) + camYOffset; 
        int tunTopY = tunBaseY - tunH; 
        for(int y = tunTopY; y < groundScreenY; y++) { plot(p, gx + dx, y, iceShadow); } 
    } 
    for(int dx = -3; dx <= 3; dx++) { 
        int wgx = worldGX + dx; int groundScreenY = gy; 
        if(heightMap.contains(wgx)) groundScreenY = heightMap.value(wgx) + camYOffset; 
        int holeTopY = tunBaseY - (tunH - 2); 
        for(int y = holeTopY; y < groundScreenY; y++) { plot(p, gx + dx, y, dark); } 
    } 
}

void PropSystem::drawPenguin(QPainter& p, int gx, int gy, int variant, bool flipped) { 
    int d = flipped ? -1 : 1; QColor black(30, 30, 40); QColor white(240, 240, 250); QColor orange(255, 140, 0); 
    plot(p, gx+(1*d), gy, orange); plot(p, gx+(2*d), gy, orange); plot(p, gx-(1*d), gy, orange); 
    for(int y=1; y<9; y++) for(int x=-2; x<=2; x++) plot(p, gx+(x*d), gy-y, black); 
    for(int y=1; y<8; y++) { plot(p, gx+(1*d), gy-y, white); plot(p, gx+(2*d), gy-y, white); } 
    for(int y=9; y<=11; y++) for(int x=-2; x<=2; x++) plot(p, gx+(x*d), gy-y, black); 
    plot(p, gx+(1*d), gy-10, white); plot(p, gx+(3*d), gy-10, orange); plot(p, gx-(1*d), gy-5, black); plot(p, gx-(2*d), gy-4, black); 
}

void PropSystem::drawSnowman(QPainter& p, int gx, int gy, int variant) { 
    QColor snow(250, 250, 255); QColor carrot(255, 140, 0); QColor stick(80, 60, 40); QColor coal(20, 20, 20); QColor tooth(255, 255, 255); 
    plot(p, gx-2, gy, snow); plot(p, gx-1, gy, snow); plot(p, gx+1, gy, snow); plot(p, gx+2, gy, snow); 
    for(int y=1; y<6; y++) { for(int x=-3; x<=3; x++) plot(p, gx+x, gy-y, snow); } 
    plot(p, gx, gy-2, coal); plot(p, gx, gy-4, coal); 
    for(int y=6; y<9; y++) { for(int x=-2; x<=2; x++) plot(p, gx+x, gy-y, snow); } 
    plot(p, gx, gy-7, coal); 
    for(int y=9; y<16; y++) { for(int x=-2; x<=2; x++) plot(p, gx+x, gy-y, snow); } 
    plot(p, gx-3, gy-10, snow); plot(p, gx+3, gy-10, snow); plot(p, gx-1, gy-13, coal); plot(p, gx+1, gy-13, coal); 
    plot(p, gx, gy-12, carrot); plot(p, gx+1, gy-12, carrot); plot(p, gx+2, gy-11, carrot); plot(p, gx, gy-10, tooth); 
    plot(p, gx, gy-16, stick); plot(p, gx-1, gy-17, stick); plot(p, gx+1, gy-17, stick); 
    plot(p, gx-3, gy-7, stick); plot(p, gx-4, gy-6, stick); plot(p, gx+3, gy-7, stick); plot(p, gx+4, gy-8, stick); 
}

void PropSystem::drawIceSpike(QPainter& p, int gx, int gy, int variant) { 
    QColor ice(180, 230, 255); int h = 5 + variant * 2; 
    for(int y=0; y<h; y++) { plot(p, gx, gy-y, ice); if(y < h/2) { plot(p, gx-1, gy-y, ice); plot(p, gx+1, gy-y, ice); } } 
}

void PropSystem::drawUFO(QPainter& p, int gx, int gy, int variant) { 
    QColor metal(150, 150, 160); QColor glass(100, 200, 255); QColor light = (variant % 2 == 0) ? QColor(255, 50, 50) : QColor(50, 255, 50); 
    plot(p, gx, gy-2, glass); plot(p, gx-1, gy-2, glass); plot(p, gx+1, gy-2, glass); plot(p, gx, gy-3, glass); 
    for(int x=-4; x<=4; x++) plot(p, gx+x, gy-1, metal); for(int x=-2; x<=2; x++) plot(p, gx+x, gy, metal); 
    plot(p, gx-3, gy-1, light); plot(p, gx+3, gy-1, light); plot(p, gx, gy, light); 
}

void PropSystem::drawRover(QPainter& p, int gx, int gy, int worldGX, int variant, bool flipped, const QHash<int,int>& heightMap) { 
    int d = flipped ? -1 : 1; 
    QColor wheelC(30, 30, 35); QColor chassisC(220, 220, 220); QColor detailC(50, 50, 60); QColor lensC(20, 30, 80); QColor gold(200, 170, 50); QColor strutC(40, 40, 50); 
    int centerGroundWorldY = heightMap.value(worldGX, 0); int camYOffset = gy - centerGroundWorldY; 
    int peakScreenY = 999999; 
    for(int dx = -6; dx <= 6; dx++) { int wgx = worldGX + dx; if(heightMap.contains(wgx)) { int sGY = heightMap.value(wgx) + camYOffset; if(sGY < peakScreenY) peakScreenY = sGY; } } 
    if(peakScreenY == 999999) peakScreenY = gy; 
    int chassisBaseY = peakScreenY - 2; 
    auto drawAdaptiveWheel = [&](int offsetX) { 
        int wheelWorldGX = worldGX + offsetX; int wheelScreenX = gx + offsetX; int groundY = peakScreenY + 5; 
        if (heightMap.contains(wheelWorldGX)) { groundY = heightMap.value(wheelWorldGX) + camYOffset; } 
        int wheelY = groundY; 
        for(int y = chassisBaseY; y < wheelY; y++) { plot(p, wheelScreenX, y, strutC); plot(p, wheelScreenX + 1, y, strutC); } 
        plot(p, wheelScreenX, wheelY, wheelC); plot(p, wheelScreenX+1, wheelY, wheelC); plot(p, wheelScreenX, wheelY-1, wheelC); plot(p, wheelScreenX+1, wheelY-1, wheelC); 
    }; 
    drawAdaptiveWheel(-5 * d); drawAdaptiveWheel(-1 * d); drawAdaptiveWheel(5 * d); 
    int bodyY = chassisBaseY - 1; plot(p, gx-(5*d), bodyY, detailC); plot(p, gx-(1*d), bodyY, detailC); plot(p, gx+(5*d), bodyY, detailC); 
    for(int x=-6; x<=6; x++) { plot(p, gx+(x*d), bodyY-1, chassisC); plot(p, gx+(x*d), bodyY-2, chassisC); } 
    plot(p, gx-(5*d), bodyY-3, detailC); plot(p, gx-(6*d), bodyY-3, detailC); plot(p, gx-(5*d), bodyY-4, detailC); 
    int mastX = gx + (4*d); plot(p, mastX, bodyY-3, detailC); plot(p, mastX, bodyY-4, detailC); plot(p, mastX, bodyY-5, detailC); 
    plot(p, mastX+(1*d), bodyY-6, chassisC); plot(p, mastX+(1*d), bodyY-6, lensC); 
    int dishX = gx - (1*d); plot(p, dishX, bodyY-3, detailC); plot(p, dishX-1, bodyY-4, gold); plot(p, dishX, bodyY-4, gold); plot(p, dishX+1, bodyY-4, gold); plot(p, dishX-2, bodyY-5, gold); plot(p, dishX+2, bodyY-5, gold); 
}

void PropSystem::drawAlien(QPainter& p, int gx, int gy, int variant) { 
    QColor skin(50, 220, 80); QColor dark(30, 150, 50); QColor eyeWhite(255, 255, 255); QColor eyeBlack(0, 0, 0); 
    for(int y=0; y<6; y++) { plot(p, gx, gy-y, skin); plot(p, gx-1, gy-y, skin); plot(p, gx+1, gy-y, skin); } 
    plot(p, gx-2, gy, dark); plot(p, gx+2, gy, dark); 
    if (variant % 2 == 0) { plot(p, gx-2, gy-3, skin); plot(p, gx-3, gy-4, skin); plot(p, gx+2, gy-3, skin); } 
    else { plot(p, gx+2, gy-3, skin); plot(p, gx+3, gy-4, skin); plot(p, gx-2, gy-3, skin); } 
    for(int y=6; y<10; y++) { for(int x=-2; x<=2; x++) plot(p, gx+x, gy-y, skin); } 
    plot(p, gx, gy-10, dark); plot(p, gx, gy-11, dark); plot(p, gx, gy-12, skin); 
    plot(p, gx-1, gy-7, eyeBlack); plot(p, gx-1, gy-8, eyeBlack); plot(p, gx+1, gy-7, eyeBlack); plot(p, gx+1, gy-8, eyeWhite); 
}
\end{lstlisting}

media.h
\begin{lstlisting}[style=cgstyle,language=C++]
#pragma once

#include <QObject>
#include <QVector>

class QAudioOutput;
class QMediaPlayer;
class QSoundEffect;
class QPropertyAnimation;

class Media : public QObject {
    Q_OBJECT
public:
    explicit Media(QObject* parent = nullptr);
    ~Media();

    void setupBgm();
    void setBgmVolume(qreal v);
    void playBgm();
    void stopBgm();

    void setStageBgm(int levelIndex);

    void startAccelLoop();
    void stopAccelLoop();

    void playNitroOnce();

    void coinPickup();
    void fuelPickup();

    void playGameOverOnce();

private:
    QAudioOutput* m_bgmOut = nullptr;
    QMediaPlayer* m_bgm    = nullptr;

    QVector<QSoundEffect*> m_driveSfx;
    QPropertyAnimation* m_accelFade = nullptr;

    QSoundEffect* m_nitroSfx = nullptr;

    QVector<QMediaPlayer*> m_coinPlayers;
    QVector<QAudioOutput*> m_coinOuts;
    int m_nextCoinPl = -1;

    QVector<QMediaPlayer*> m_fuelPlayers;
    QVector<QAudioOutput*> m_fuelOuts;
    int m_nextFuelPl = -1;

    QAudioOutput* m_gameOverOut = nullptr;
    QMediaPlayer* m_gameOver    = nullptr;
};
\end{lstlisting}

media.cpp
\begin{lstlisting}[style=cgstyle,language=C++]
#include "media.h"

#include <QAudioOutput>
#include <QMediaPlayer>
#include <QMediaDevices>
#include <QSoundEffect>
#include <QPropertyAnimation>
#include <QCoreApplication>
#include <QFile>
#include <QUrl>

namespace {

QUrl pickBgmUrl(const QString& alias, const QString& fileName)
{
    const QString qrcPath = QString(":/audio/%1").arg(alias);
    if (QFile::exists(qrcPath)) {
        return QUrl(QStringLiteral("qrc:/audio/") + alias);
    }

    const QString fsPath =
        QCoreApplication::applicationDirPath() + "/assets/audio/" + fileName;
    if (QFile::exists(fsPath)) {
        return QUrl::fromLocalFile(fsPath);
    }

    return {};
}

QUrl defaultBgmUrl()
{
    const QString qrcPath = QStringLiteral(":/audio/bgm.mp3");
    if (QFile::exists(qrcPath)) {
        return QUrl(QStringLiteral("qrc:/audio/bgm.mp3"));
    }

    const QString fsPath =
        QCoreApplication::applicationDirPath() + "/assets/audio/bgm.mp3";
    if (QFile::exists(fsPath)) {
        return QUrl::fromLocalFile(fsPath);
    }

    return {};
}

} 

Media::Media(QObject* parent)
    : QObject(parent)
{
    auto* e = new QSoundEffect(this);
    e->setSource(QUrl(QStringLiteral("qrc:/sfx/accelerate.wav")));
    e->setLoopCount(1);
    e->setVolume(0.35);
    m_driveSfx.push_back(e);

    m_nitroSfx = new QSoundEffect(this);
    m_nitroSfx->setSource(QUrl(QStringLiteral("qrc:/sfx/nitro.wav")));
    m_nitroSfx->setLoopCount(1);
    m_nitroSfx->setVolume(0.35);

    m_gameOverOut = new QAudioOutput(this);
    m_gameOverOut->setVolume(0.35);
    m_gameOver = new QMediaPlayer(this);
    m_gameOver->setAudioOutput(m_gameOverOut);
    m_gameOver->setSource(QUrl(QStringLiteral("qrc:/sfx/gameOver.mp3")));

    const char* coinPath = "qrc:/sfx/coin.mp3";
    for (int i = 0; i < 3; ++i) {
        auto* out = new QAudioOutput(this);
        out->setVolume(0.35);
        auto* p = new QMediaPlayer(this);
        p->setAudioOutput(out);
        p->setSource(QUrl(coinPath));
        m_coinOuts.push_back(out);
        m_coinPlayers.push_back(p);
    }

    const char* fuelPath = "qrc:/sfx/fuel.mp3";
    for (int i = 0; i < 3; ++i) {
        auto* out = new QAudioOutput(this);
        out->setVolume(0.35);
        auto* p = new QMediaPlayer(this);
        p->setAudioOutput(out);
        p->setSource(QUrl(fuelPath));
        m_fuelOuts.push_back(out);
        m_fuelPlayers.push_back(p);
    }
}

Media::~Media() = default;

void Media::setupBgm()
{
    m_bgmOut = new QAudioOutput(this);
    m_bgmOut->setVolume(1);
    m_bgm = new QMediaPlayer(this);
    m_bgm->setAudioOutput(m_bgmOut);
    m_bgm->setLoops(QMediaPlayer::Infinite);

    const QUrl src = defaultBgmUrl();
    if (!src.isEmpty()) {
        m_bgm->setSource(src);
    }
}

void Media::setBgmVolume(qreal v)
{
    if (m_bgmOut) {
        m_bgmOut->setVolume(v);
    }
}

void Media::playBgm()
{
    if (m_bgm) {
        m_bgm->play();
    }
}

void Media::stopBgm()
{
    if (m_bgm) {
        m_bgm->stop();
    }
}

void Media::setStageBgm(int levelIndex)
{
    if (!m_bgm) return;

    QUrl src;
    switch (levelIndex) {
    case 0: src = pickBgmUrl("bgm_meadow.mp3", "bgm_meadow.mp3"); break;
    case 1: src = pickBgmUrl("bgm_desert.mp3", "bgm_desert.mp3"); break;
    case 2: src = pickBgmUrl("bgm_tundra.mp3", "bgm_tundra.mp3"); break;
    case 3: src = pickBgmUrl("bgm_lunar.mp3", "bgm_lunar.mp3"); break;
    case 4: src = pickBgmUrl("bgm_martian.mp3", "bgm_martian.mp3"); break;
    case 5: src = pickBgmUrl("bgm_nightlife.mp3", "bgm_nightlife.mp3"); break;
    default: break;
    }

    if (src.isEmpty()) src = defaultBgmUrl();
    if (!src.isEmpty()) m_bgm->setSource(src);
    m_bgm->play();
}

void Media::startAccelLoop()
{
    if (m_driveSfx.isEmpty()) return;
    auto* e = m_driveSfx[0];

    if (m_accelFade) {
        m_accelFade->stop();
        delete m_accelFade;
        m_accelFade = nullptr;
    }

    e->setLoopCount(QSoundEffect::Infinite);
    e->setVolume(1.0);
    if (!e->isPlaying()) e->play();
}

void Media::stopAccelLoop()
{
    if (m_driveSfx.isEmpty()) return;
    auto* e = m_driveSfx[0];

    if (m_accelFade) {
        m_accelFade->stop();
        delete m_accelFade;
        m_accelFade = nullptr;
    }

    m_accelFade = new QPropertyAnimation(e, "volume", this);
    m_accelFade->setStartValue(e->volume());
    m_accelFade->setEndValue(0.0);
    m_accelFade->setDuration(250);

    connect(m_accelFade, &QPropertyAnimation::finished, this, [this, e] {
        e->stop();
        e->setVolume(0.0);
        if (m_accelFade) {
            m_accelFade->deleteLater();
            m_accelFade = nullptr;
        }
    });

    m_accelFade->start();
}

void Media::playNitroOnce()
{
    if (!m_nitroSfx) return;
    m_nitroSfx->stop();
    m_nitroSfx->setLoopCount(1);
    m_nitroSfx->setVolume(0.35);
    m_nitroSfx->play();
}

void Media::coinPickup()
{
    if (m_coinPlayers.isEmpty()) return;
    m_nextCoinPl = (m_nextCoinPl + 1) % m_coinPlayers.size();
    auto* p = m_coinPlayers[m_nextCoinPl];
    p->setPosition(0);
    p->play();
}

void Media::fuelPickup()
{
    if (m_fuelPlayers.isEmpty()) return;
    m_nextFuelPl = (m_nextFuelPl + 1) % m_fuelPlayers.size();
    auto* p = m_fuelPlayers[m_nextFuelPl];
    p->setPosition(0);
    p->play();
}

void Media::playGameOverOnce()
{
    if (!m_gameOver) return;
    m_gameOver->setPosition(0);
    m_gameOver->play();
}
\end{lstlisting}

assets.qrc (Resource Mapping)
\begin{lstlisting}[style=cgstyle,language=XML]
<RCC>
  <qresource prefix="/audio">
    <file alias="bgm.mp3">assets/audio/bgm.mp3</file>
    <file alias="bgm_meadow.mp3">assets/audio/bgm.mp3</file>
    <file alias="bgm_desert.mp3">assets/audio/bgm_desert.mp3</file>
    <file alias="bgm_tundra.mp3">assets/audio/bgm_tundra.mp3</file>
    <file alias="bgm_lunar.mp3">assets/audio/bgm_lunar.mp3</file>
    <file alias="bgm_martian.mp3">assets/audio/bgm_martian.mp3</file>
    <file alias="bgm_nightlife.mp3">assets/audio/bgm_nightlife.mp3</file>
  </qresource>
  <qresource prefix="/sfx">
    <file alias="accelerate.wav">assets/audio/accelerate.wav</file>
    <file alias="nitro.wav">assets/audio/nitro.wav</file>
    <file alias="coin.mp3">assets/audio/coin.mp3</file>
    <file alias="fuel.mp3">assets/audio/fuel.mp3</file>
    <file alias="gameOver.mp3">assets/audio/gameOver.mp3</file>
  </qresource>
</RCC>
\end{lstlisting}
\begin{figure}[H]
  \centering
  % Meadow
  \begin{subfigure}{1.0\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/meadow.png}
    \caption{Meadow: The starting biome featuring grassy slopes, procedural trees, and scattered rocks.}
  \end{subfigure}
  \par\bigskip % Vertical spacing

  % Desert
  \begin{subfigure}{1.0\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/desert.png}
    \caption{Desert: Arid sand dunes populated by cacti, tumbleweeds, and camels.}
  \end{subfigure}
  
  % Main caption for the first part
  \label{fig:levels_earth}
\end{figure}

% Second part of Earth Biomes (Tundra) - Moves to next page automatically if needed
\begin{figure}[H]
  \ContinuedFloat % Keeps the Figure number same as above (e.g., Figure 1)
  \centering
  % Tundra
  \begin{subfigure}{1.0\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/tundra.png}
    \caption{Tundra: Snowy peaks and icy terrain with penguins, igloos, and snowmen.}
  \end{subfigure}
  
  \caption[]{Earth-based biomes showcasing distinct color palettes and procedural environmental props.} % Empty bracket [] prevents duplicate entry in List of Figures
\end{figure}

% === EXOTIC BIOMES (Split across pages) ===

\begin{figure}[H]
  \centering
  % Lunar
  \begin{subfigure}{1.0\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/lunar.png}
    \caption{Lunar: A dark, low-gravity moonscape with craters and hovering UFOs.}
  \end{subfigure}
  \par\bigskip

  % Martian
  \begin{subfigure}{1.0\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/martian.png}
    \caption{Martian: Red planet terrain featuring exploration rovers and alien lifeforms.}
  \end{subfigure}

  \caption{Exotic and urban biomes introducing unique visual styles and lighting effects.}
  \label{fig:levels_exotic}
\end{figure}

% Second part of Exotic Biomes (Nightlife)
\begin{figure}[H]
  \ContinuedFloat
  \centering
  % Nightlife
  \begin{subfigure}{1.0\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/nightlife.png}
    \caption{Nightlife: A neon-lit urban environment with procedurally generated skyscrapers and street lamps.}
  \end{subfigure}

  \caption[]{Exotic and urban biomes.}
\end{figure}
\clearpage
\subsubsection*{Feature: Local Leaderboard and Persistence System}
\textbf{Relevant classes and functions:} \texttt{LeaderboardManager}, \texttt{LeaderboardWidget}, \texttt{MainWindow::showGameOver()}, \texttt{QSettings}.

To provide long-term player engagement, I implemented a persistent local leaderboard system that tracks high scores for each biome. The system is architected using a separation of concerns pattern: the \texttt{LeaderboardManager} handles data persistence and sorting logic, while the \texttt{LeaderboardWidget} handles the custom pixel-art rendering of the overlay.

\paragraph{Data Persistence and Identity.}
Instead of using an external database, I utilized \texttt{QSettings} to store high scores locally in the system registry or configuration files. To distinguish entries, I generate a unique device identifier using \texttt{QSysInfo::machineUniqueId()}. This allows the system to be extended in the future for network synchronization while currently serving as a local user tag.

The data is structured as a list of \texttt{LeaderboardEntry} structs, each containing the stage name, user ID, and score. When the application starts, these are deserialized from storage. When a game ends, the new score is compared against existing records. If a personal best for that specific stage is achieved, the record is updated, the list is re-sorted, and the data is flushed back to storage.

\paragraph{Sorting Logic.}
To ensure a consistent display, I enforce a deterministic sorting order. Entries are primarily grouped by \texttt{stageName} and secondarily sorted by \texttt{score} in descending order:
\[
    \text{Order}(A, B) = 
    \begin{cases} 
      \text{Score}_A > \text{Score}_B, & \text{if } \text{Stage}_A = \text{Stage}_B \\
      \text{Stage}_A < \text{Stage}_B, & \text{otherwise}
    \end{cases}
\]

\paragraph{Custom UI Rendering.}
The \texttt{LeaderboardWidget} is a custom QWidget that overlays the game window. Rather than using standard Qt UI controls, I implemented a custom \texttt{paintEvent} to draw the scoreboard using the game's specific color palette and pixel-font aesthetic. The background is rendered as a semi-transparent dark overlay (`rgba(28, 24, 36, 240)`) to maintain visual continuity with the game's "Nightlife" and "Space" themes.

\bigskip
\noindent\textbf{Source Code.} Below are the complete implementations of the scoreboard logic and the integration points within the main window.

scoreboard.h 
\begin{lstlisting}[style=cgstyle,language=C++]
#pragma once

#include <QObject>
#include <QWidget>
#include <QVector>
#include <QString>

class QPaintEvent;
class QKeyEvent;
class QMouseEvent;

struct LeaderboardEntry {
    QString stageName;
    QString userName;
    int     score = 0;
};

class LeaderboardWidget : public QWidget {
    Q_OBJECT
public:
    explicit LeaderboardWidget(QWidget* parent = nullptr);
    void setEntries(const QVector<LeaderboardEntry>& entries);

signals:
    void closed();

protected:
    void paintEvent(QPaintEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;

private:
    QVector<LeaderboardEntry> m_entries;
};

class LeaderboardManager : public QObject {
    Q_OBJECT
public:
    explicit LeaderboardManager(QObject* parent = nullptr);
    void submitScore(const QString& stageName, int score);
    void refreshLeaderboard();

signals:
    void leaderboardUpdated(const QVector<LeaderboardEntry>& entries);

private:
    QString deviceId() const;
    void    loadFromSettings();
    void    saveToSettings() const;

    QVector<LeaderboardEntry> m_entries;
};
\end{lstlisting}

scoreboard.cpp 
\begin{lstlisting}[style=cgstyle,language=C++]
#include "scoreboard.h"
#include <QPainter>
#include <QPaintEvent>
#include <QKeyEvent>
#include <QMouseEvent>
#include <QPalette>
#include <QSysInfo>
#include <QSettings>
#include <algorithm>

LeaderboardWidget::LeaderboardWidget(QWidget* parent) : QWidget(parent)
{
    setAttribute(Qt::WA_StyledBackground, true);
    setAutoFillBackground(true);

    QPalette pal = palette();
    pal.setColor(QPalette::Window, QColor(0, 0, 0, 210));
    setPalette(pal);

    setFocusPolicy(Qt::StrongFocus);
    hide();
}

void LeaderboardWidget::setEntries(const QVector<LeaderboardEntry>& entries)
{
    m_entries = entries;
    update();
}

void LeaderboardWidget::paintEvent(QPaintEvent* event)
{
    Q_UNUSED(event);
    QPainter p(this);
    p.setRenderHint(QPainter::Antialiasing, false);
    p.setRenderHint(QPainter::TextAntialiasing, true);

    const QRect panel = rect().adjusted(width() * 0.1, height() * 0.1, -width() * 0.1, -height() * 0.1);

    p.fillRect(panel, QColor(28, 24, 36, 240));
    p.setPen(QColor(80, 70, 100));
    p.drawRect(panel.adjusted(0, 0, -1, -1));

    QFont titleFont;
    titleFont.setFamily("Monospace");
    titleFont.setBold(true);
    titleFont.setPixelSize(24);
    titleFont.setStyleStrategy(QFont::NoAntialias);
    p.setFont(titleFont);
    p.setPen(QColor(230, 230, 240));

    const QString title = QStringLiteral("SCOREBOARD");
    QFontMetrics tfm(titleFont);
    int titleW = tfm.horizontalAdvance(title);
    int titleX = panel.center().x() - titleW / 2;
    int titleY = panel.top() + tfm.ascent() + 16;
    p.drawText(titleX, titleY, title);

    QFont headerFont;
    headerFont.setFamily("Monospace");
    headerFont.setBold(true);
    headerFont.setPixelSize(14);
    headerFont.setStyleStrategy(QFont::NoAntialias);

    QFont rowFont = headerFont;
    rowFont.setBold(false);

    const int topMargin = 60;
    const int rowHeight = 26;

    int colStageX = panel.left() + 40;
    int colScoreX = panel.right() - 160;

    p.setFont(headerFont);
    p.setPen(QColor(200, 200, 210));
    int headerY = panel.top() + topMargin;
    p.drawText(colStageX, headerY, QStringLiteral("STAGE"));
    p.drawText(colScoreX, headerY, QStringLiteral("BEST SCORE"));

    p.setPen(QColor(80, 70, 100));
    p.drawLine(panel.left() + 20, headerY + 6,
               panel.right() - 20, headerY + 6);

    p.setFont(rowFont);
    p.setPen(QColor(230, 230, 240));

    if (m_entries.isEmpty()) {
        const QString msg = QStringLiteral("No scores yet. Play a game to create a record.");
        QFontMetrics rfm(rowFont);
        int w = rfm.horizontalAdvance(msg);
        int x = panel.center().x() - w / 2;
        int y = headerY + rowHeight * 2;
        p.drawText(x, y, msg);
        return;
    }

    int y = headerY + rowHeight;
    for (int i = 0; i < m_entries.size(); ++i) {
        const LeaderboardEntry& e = m_entries[i];

        if (i % 2 == 0) {
            QRect rowRect(panel.left() + 10, y - rowHeight + 6, panel.width() - 20, rowHeight);
            p.fillRect(rowRect, QColor(40, 34, 50, 160));
        }

        p.setPen(QColor(220, 220, 230));
        p.drawText(colStageX, y, e.stageName);
        p.drawText(colScoreX, y, QString::number(e.score));

        y += rowHeight;
        if (y > panel.bottom() - 20) break;
    }

    QFont hintFont;
    hintFont.setFamily("Monospace");
    hintFont.setPixelSize(10);
    hintFont.setStyleStrategy(QFont::NoAntialias);
    p.setFont(hintFont);
    p.setPen(QColor(170, 170, 190));
    const QString hint = QStringLiteral("[S] or [Esc] to close");
    QFontMetrics hfm(hintFont);
    int hw = hfm.horizontalAdvance(hint);
    int hx = panel.center().x() - hw / 2;
    int hy = panel.bottom() - 12;
    p.drawText(hx, hy, hint);
}

void LeaderboardWidget::keyPressEvent(QKeyEvent* event)
{
    if (event->key() == Qt::Key_S || event->key() == Qt::Key_Escape) {
        hide();
        emit closed();
        return;
    }
    QWidget::keyPressEvent(event);
}

void LeaderboardWidget::mousePressEvent(QMouseEvent* event)
{
    Q_UNUSED(event);
    hide();
    emit closed();
}

LeaderboardManager::LeaderboardManager(QObject* parent)
    : QObject(parent)
{
    loadFromSettings();
}

QString LeaderboardManager::deviceId() const
{
    QByteArray id = QSysInfo::machineUniqueId();
    if (!id.isEmpty())
        return QString::fromLatin1(id.toHex());

    QString host = QSysInfo::machineHostName();
    if (!host.isEmpty())
        return host;

    return QStringLiteral("UNKNOWN_DEVICE");
}

void LeaderboardManager::submitScore(const QString& stageName, int score)
{
    const QString user = deviceId();

    bool found = false;
    for (auto &e : m_entries) {
        if (e.stageName == stageName && e.userName == user) {
            if (score > e.score)
                e.score = score;
            found = true;
            break;
        }
    }

    if (!found) {
        LeaderboardEntry e;
        e.stageName = stageName;
        e.userName  = user;
        e.score     = score;
        m_entries.push_back(e);
    }

    std::sort(m_entries.begin(), m_entries.end(),
              [](const LeaderboardEntry& a, const LeaderboardEntry& b) {
                  if (a.stageName == b.stageName)
                      return a.score > b.score;
                  return a.stageName < b.stageName;
              });

    saveToSettings();
    emit leaderboardUpdated(m_entries);
}

void LeaderboardManager::refreshLeaderboard()
{
    emit leaderboardUpdated(m_entries);
}

void LeaderboardManager::loadFromSettings()
{
    m_entries.clear();

    QSettings s("JU", "F1PixelGrid");
    int n = s.beginReadArray("leaderboard");
    for (int i = 0; i < n; ++i) {
        s.setArrayIndex(i);
        LeaderboardEntry e;
        e.stageName = s.value("stage").toString();
        e.userName  = s.value("user").toString();
        e.score     = s.value("score").toInt();
        if (!e.stageName.isEmpty())
            m_entries.push_back(e);
    }
    s.endArray();

    std::sort(m_entries.begin(), m_entries.end(),
              [](const LeaderboardEntry& a, const LeaderboardEntry& b) {
                  if (a.stageName == b.stageName)
                      return a.score > b.score;
                  return a.stageName < b.stageName;
              });
}

void LeaderboardManager::saveToSettings() const
{
    QSettings s("JU", "F1PixelGrid");
    s.beginWriteArray("leaderboard");
    for (int i = 0; i < m_entries.size(); ++i) {
        s.setArrayIndex(i);
        s.setValue("stage", m_entries[i].stageName);
        s.setValue("user",  m_entries[i].userName);
        s.setValue("score", m_entries[i].score);
    }
    s.endArray();
    s.sync();
}
\end{lstlisting}

mainwindow.cpp (Integration Excerpts)
\begin{lstlisting}[style=cgstyle,language=C++]
// Integration within the Constructor
MainWindow::MainWindow(QWidget *parent)
    : QWidget(parent),
    m_rng(std::random_device{}() ),
    m_dist(0.0f, 1.0f)
{
    // ... initialization ...

    m_leaderboardMgr = new LeaderboardManager(this);
    m_leaderboardWidget = new LeaderboardWidget(this);
    m_leaderboardWidget->setGeometry(rect());
    m_leaderboardWidget->hide();

    connect(m_leaderboardMgr, &LeaderboardManager::leaderboardUpdated,
            m_leaderboardWidget, &LeaderboardWidget::setEntries);

    connect(m_leaderboardWidget, &LeaderboardWidget::closed, this, [this]{
        if (m_timer && !m_intro && !m_outro) {
            m_timer->start();
        }
        setFocus();
    });
    
    // ... rest of constructor ...
}

// Integration within Game Over Logic
void MainWindow::showGameOver() {
    if (m_media) m_media->playGameOverOnce();
    
    if (m_leaderboardMgr) {
        QString stageName = QStringLiteral("UNKNOWN");
        if (level_index >= 0 && level_index < m_levelNames.size()) {
            stageName = m_levelNames[level_index];
        }
        m_leaderboardMgr->submitScore(stageName, m_score);
    }
    
    // ... existing game over logic ...
}

// Integration within Key Handling
void MainWindow::keyPressEvent(QKeyEvent *event) {
    // ... other keys ...
    
    switch (event->key()) {
        case Qt::Key_S:
            if (m_leaderboardWidget && m_leaderboardMgr) {
                if (m_timer && m_timer->isActive()) {
                    m_timer->stop();
                }
                m_leaderboardWidget->setGeometry(rect());
                m_leaderboardWidget->show();
                m_leaderboardWidget->raise();
                m_leaderboardWidget->setFocus();
                m_leaderboardMgr->refreshLeaderboard();
            }
            break;
            
    // ... remaining cases ...
    }
}
\end{lstlisting}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/scoreboard.png}
  \caption{Local Leaderboard System: The custom overlay widget displaying persistent high scores for each biome, rendered with a semi-transparent background and pixel-perfect typography to match the game's aesthetic.}
  \label{fig:scoreboard}
\end{figure}

% ------------------------------------------------------------
% SECTION 4: CONCLUSION and LIMITATION
% ------------------------------------------------------------
\subsection*{4. Challenges \& Limitation}
\addcontentsline{toc}{subsection}{4. Challenges \& Limitation}
\subsection*{Challenges}
\begin{itemize}
    \item \textbf{Physics tuning:} Designing simple custom physics such that the three–wheel car feels responsive, but still unstable enough to punish careless driving, required repeated tuning of gravity, traction, damping and spring parameters across all stages.
    \item \textbf{Procedural terrain:} Generating terrain that looks organic while avoiding impossible slopes or unfair obstacles was challenging. The random walk–based height model had to be carefully constrained for each biome.
    \item \textbf{Pixel-grid UI:} All HUD elements and overlays are rendered through a manual pixel–grid system. Ensuring text readability, layout consistency and visual clarity across different window sizes and aspect ratios was non-trivial.
\end{itemize}

\subsection*{Limitations}
\begin{itemize}
    \item \textbf{Simplified physics:} The physics model is intentionally lightweight and 2D, without full rigid–body dynamics or continuous collision detection, so extreme configurations can occasionally produce visually unrealistic behaviour.
    \item \textbf{Limited content variety:} Terrain, coins, fuel pickups and props are procedurally generated but follow fixed parameter ranges per stage. Over long play sessions this can lead to repetitive patterns and predictable difficulty.
    \item \textbf{Local-only experience:} The leaderboard is strictly local, with no networking, cloud sync or cross-device progression. Additionally, there is no support for configurable key bindings, mobile/touch input schemes or accessibility-oriented options.
\end{itemize}


% ------------------------------------------------------------
% SECTION 5: CONCLUSION and FUTURE SCOPE
% ------------------------------------------------------------
\subsection*{5. Conclusion \& Future Scope}
\addcontentsline{toc}{subsection}{5. Conclusion \& Future Scope}
\subsection*{Conclusion}
\begin{itemize}
    \item \textbf{Integration of CG concepts:} The project combines line and circle rasterization, scan-line polygon filling, affine transformations and basic viewing ideas into a single interactive application, reinforcing core computer graphics topics.
    \item \textbf{Coherent game loop:} A simple physics engine, procedural terrain and HUD rendering are integrated within a Qt-based framework using a custom pixel-grid renderer and a fixed-timestep update loop.
    \item \textbf{Educational value:} The implementation illustrates trade-offs between visual style, responsiveness and algorithmic simplicity, providing a concrete, playable demonstration of techniques taught in the course.
\end{itemize}

\subsection*{Future Scope}
\begin{itemize}
    \item \textbf{Enhanced physics:} Upgrade to a more robust rigid-body model with better suspension, contact handling and continuous collision detection, improving realism without sacrificing responsiveness.
    \item \textbf{Richer content:} Diversify terrain and prop generation, add dynamic events (bridges, hazards, alternative routes) and introduce structured missions, obstacles and additional power-ups to increase replay value.
    \item \textbf{Multiplayer gameplay:} Add local split-screen or online multiplayer modes, enabling races between players on the same terrain seed, shared leaderboards and cooperative or competitive challenges.
    \item \textbf{Platform and UX improvements:} Introduce online leaderboards, configurable controls, support for gamepads and touch input, as well as basic accessibility settings (color/contrast options, UI scaling).
\end{itemize}

\end{document}